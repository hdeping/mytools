var sources = {
    "keys": [
        "./init/main.c",
        "./lib/execve.c",
        "./lib/ctype.c",
        "./lib/errno.c",
        "./lib/string.c",
        "./lib/_exit.c",
        "./lib/setsid.c",
        "./lib/malloc.c",
        "./lib/wait.c",
        "./lib/write.c",
        "./lib/dup.c",
        "./lib/open.c",
        "./lib/close.c",
        "./mm/memory.c",
        "./fs/super.c",
        "./fs/file_table.c",
        "./fs/buffer.c",
        "./fs/pipe.c",
        "./fs/exec.c",
        "./fs/bitmap.c",
        "./fs/file_dev.c",
        "./fs/inode.c",
        "./fs/truncate.c",
        "./fs/ioctl.c",
        "./fs/namei.c",
        "./fs/block_dev.c",
        "./fs/read_write.c",
        "./fs/stat.c",
        "./fs/fcntl.c",
        "./fs/open.c",
        "./fs/char_dev.c",
        "./kernel/sched.c",
        "./kernel/sys.c",
        "./kernel/mktime.c",
        "./kernel/fork.c",
        "./kernel/traps.c",
        "./kernel/printk.c",
        "./kernel/exit.c",
        "./kernel/panic.c",
        "./kernel/vsprintf.c",
        "./kernel/math/math_emulate.c",
        "./kernel/chr_drv/serial.c",
        "./kernel/chr_drv/tty_ioctl.c",
        "./kernel/chr_drv/console.c",
        "./kernel/chr_drv/tty_io.c",
        "./kernel/blk_drv/ramdisk.c",
        "./kernel/blk_drv/ll_rw_blk.c",
        "./kernel/blk_drv/floppy.c",
        "./kernel/blk_drv/hd.c",
        "./kernel/signal.c",
        "./include/time.h",
        "./include/utime.h",
        "./include/asm/segment.h",
        "./include/asm/io.h",
        "./include/asm/memory.h",
        "./include/asm/system.h",
        "./include/unistd.h",
        "./include/stddef.h",
        "./include/fcntl.h",
        "./include/signal.h",
        "./include/sys/types.h",
        "./include/sys/times.h",
        "./include/sys/wait.h",
        "./include/sys/stat.h",
        "./include/sys/utsname.h",
        "./include/ctype.h",
        "./include/linux/head.h",
        "./include/linux/tty.h",
        "./include/linux/config.h",
        "./include/linux/mm.h",
        "./include/linux/hdreg.h",
        "./include/linux/fdreg.h",
        "./include/linux/kernel.h",
        "./include/linux/sys.h",
        "./include/linux/sched.h",
        "./include/linux/fs.h",
        "./include/errno.h",
        "./include/termios.h",
        "./include/a.out.h",
        "./include/stdarg.h",
        "./include/const.h",
        "./include/string.h",
        "./kernel/blk_drv/blk.h"
    ],
    "values": [
        "/*\n *  linux/init/main.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#define __LIBRARY__\n#include <unistd.h>\n#include <time.h>\n\n/*\n * we need this inline - forking from kernel space will result\n * in NO COPY ON WRITE (!!!), until an execve is executed. This\n * is no problem, but for the stack. This is handled by not letting\n * main() use the stack at all after fork(). Thus, no function\n * calls - which means inline code for fork too, as otherwise we\n * would use the stack upon exit from 'fork()'.\n *\n * Actually only pause and fork are needed inline, so that there\n * won't be any messing with the stack from main(), but we define\n * some others too.\n */\nstatic inline int fork(void) __attribute__((always_inline));\nstatic inline int pause(void) __attribute__((always_inline));\nstatic inline _syscall0(int,fork)\nstatic inline _syscall0(int,pause)\nstatic inline _syscall1(int,setup,void *,BIOS)\nstatic inline _syscall0(int,sync)\n\n#include <linux/tty.h>\n#include <linux/sched.h>\n#include <linux/head.h>\n#include <asm/system.h>\n#include <asm/io.h>\n\n#include <stddef.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n\n#include <linux/fs.h>\n\nstatic char printbuf[1024];\n\nextern int vsprintf();\nextern void init(void);\nextern void blk_dev_init(void);\nextern void chr_dev_init(void);\nextern void hd_init(void);\nextern void floppy_init(void);\nextern void mem_init(long start, long end);\nextern long rd_init(long mem_start, int length);\nextern long kernel_mktime(struct tm * tm);\nextern long startup_time;\n\n/*\n * This is set up by the setup-routine at boot-time\n */\n#define EXT_MEM_K (*(unsigned short *)0x90002)\n#define DRIVE_INFO (*(struct drive_info *)0x90080)\n#define ORIG_ROOT_DEV (*(unsigned short *)0x901FC)\n\n/*\n * Yeah, yeah, it's ugly, but I cannot find how to do this correctly\n * and this seems to work. I anybody has more info on the real-time\n * clock I'd be interested. Most of this was trial and error, and some\n * bios-listing reading. Urghh.\n */\n\n#define CMOS_READ(addr) ({ \\\noutb_p(0x80|addr,0x70); \\\ninb_p(0x71); \\\n})\n\n#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)\n\nstatic void time_init(void)\n{\n\tstruct tm time;\n\n\tdo {\n\t\ttime.tm_sec = CMOS_READ(0);\n\t\ttime.tm_min = CMOS_READ(2);\n\t\ttime.tm_hour = CMOS_READ(4);\n\t\ttime.tm_mday = CMOS_READ(7);\n\t\ttime.tm_mon = CMOS_READ(8);\n\t\ttime.tm_year = CMOS_READ(9);\n\t} while (time.tm_sec != CMOS_READ(0));\n\tBCD_TO_BIN(time.tm_sec);\n\tBCD_TO_BIN(time.tm_min);\n\tBCD_TO_BIN(time.tm_hour);\n\tBCD_TO_BIN(time.tm_mday);\n\tBCD_TO_BIN(time.tm_mon);\n\tBCD_TO_BIN(time.tm_year);\n\ttime.tm_mon--;\n\tstartup_time = kernel_mktime(&time);\n}\n\nstatic long memory_end = 0;\nstatic long buffer_memory_end = 0;\nstatic long main_memory_start = 0;\n\nstruct drive_info { char dummy[32]; } drive_info;\n\nvoid main(void)\t\t/* This really IS void, no error here. */\n{\t\t\t/* The startup routine assumes (well, ...) this */\n/*\n * Interrupts are still disabled. Do necessary setups, then\n * enable them\n */\n\n \tROOT_DEV = ORIG_ROOT_DEV;\n \tdrive_info = DRIVE_INFO;\n\tmemory_end = (1<<20) + (EXT_MEM_K<<10);\n\tmemory_end &= 0xfffff000;\n\tif (memory_end > 16*1024*1024)\n\t\tmemory_end = 16*1024*1024;\n\tif (memory_end > 12*1024*1024) \n\t\tbuffer_memory_end = 4*1024*1024;\n\telse if (memory_end > 6*1024*1024)\n\t\tbuffer_memory_end = 2*1024*1024;\n\telse\n\t\tbuffer_memory_end = 1*1024*1024;\n\tmain_memory_start = buffer_memory_end;\n#ifdef RAMDISK_SIZE\n\tmain_memory_start += rd_init(main_memory_start, RAMDISK_SIZE*1024);\n#endif\n\tmem_init(main_memory_start,memory_end);\n\ttrap_init();\n\tblk_dev_init();\n\tchr_dev_init();\n\ttty_init();\n\ttime_init();\n\tsched_init();\n\tbuffer_init(buffer_memory_end);\n\thd_init();\n\tfloppy_init();\n\tsti();\n\tmove_to_user_mode();\n\tif (!fork()) {\t\t/* we count on this going ok */\n\t\tinit();\n\t}\n/*\n *   NOTE!!   For any other task 'pause()' would mean we have to get a\n * signal to awaken, but task0 is the sole exception (see 'schedule()')\n * as task 0 gets activated at every idle moment (when no other tasks\n * can run). For task0 'pause()' just means we go check if some other\n * task can run, and if not we return here.\n */\n\tfor(;;) pause();\n}\n\nstatic int printf(const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\twrite(1,printbuf,i=vsprintf(printbuf, fmt, args));\n\tva_end(args);\n\treturn i;\n}\n\nstatic char * argv_rc[] = { \"/bin/sh\", NULL };\nstatic char * envp_rc[] = { \"HOME=/\", NULL };\n\nstatic char * argv[] = { \"-/bin/sh\",NULL };\nstatic char * envp[] = { \"HOME=/usr/root\", NULL };\n\nvoid init(void)\n{\n\tint pid,i;\n\n\tsetup((void *) &drive_info);\n\t(void) open(\"/dev/tty0\",O_RDWR,0);\n\t(void) dup(0);\n\t(void) dup(0);\n\tprintf(\"%d buffers = %d bytes buffer space\\n\\r\",NR_BUFFERS,\n\t\tNR_BUFFERS*BLOCK_SIZE);\n\tprintf(\"Free mem: %d bytes\\n\\r\",memory_end-main_memory_start);\n\tif (!(pid=fork())) {\n\t\tclose(0);\n\t\tif (open(\"/etc/rc\",O_RDONLY,0))\n\t\t\t_exit(1);\n\t\texecve(\"/bin/sh\",argv_rc,envp_rc);\n\t\t_exit(2);\n\t}\n\tif (pid>0)\n\t\twhile (pid != wait(&i))\n\t\t\t/* nothing */;\n\twhile (1) {\n\t\tif ((pid=fork())<0) {\n\t\t\tprintf(\"Fork failed in init\\r\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!pid) {\n\t\t\tclose(0);close(1);close(2);\n\t\t\tsetsid();\n\t\t\t(void) open(\"/dev/tty0\",O_RDWR,0);\n\t\t\t(void) dup(0);\n\t\t\t(void) dup(0);\n\t\t\t_exit(execve(\"/bin/sh\",argv,envp));\n\t\t}\n\t\twhile (1)\n\t\t\tif (pid == wait(&i))\n\t\t\t\tbreak;\n\t\tprintf(\"\\n\\rchild %d died with code %04x\\n\\r\",pid,i);\n\t\tsync();\n\t}\n\t_exit(0);\t/* NOTE! _exit, not exit() */\n}",
        "/*\n *  linux/lib/execve.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#define __LIBRARY__\n#include <unistd.h>\n\n_syscall3(int,execve,const char *,file,char **,argv,char **,envp)",
        "/*\n *  linux/lib/ctype.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <ctype.h>\n\nchar _ctmp;\nunsigned char _ctype[] = {0x00,\t\t\t/* EOF */\n_C,_C,_C,_C,_C,_C,_C,_C,\t\t\t/* 0-7 */\n_C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C,\t\t/* 8-15 */\n_C,_C,_C,_C,_C,_C,_C,_C,\t\t\t/* 16-23 */\n_C,_C,_C,_C,_C,_C,_C,_C,\t\t\t/* 24-31 */\n_S|_SP,_P,_P,_P,_P,_P,_P,_P,\t\t\t/* 32-39 */\n_P,_P,_P,_P,_P,_P,_P,_P,\t\t\t/* 40-47 */\n_D,_D,_D,_D,_D,_D,_D,_D,\t\t\t/* 48-55 */\n_D,_D,_P,_P,_P,_P,_P,_P,\t\t\t/* 56-63 */\n_P,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U,\t/* 64-71 */\n_U,_U,_U,_U,_U,_U,_U,_U,\t\t\t/* 72-79 */\n_U,_U,_U,_U,_U,_U,_U,_U,\t\t\t/* 80-87 */\n_U,_U,_U,_P,_P,_P,_P,_P,\t\t\t/* 88-95 */\n_P,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L,\t/* 96-103 */\n_L,_L,_L,_L,_L,_L,_L,_L,\t\t\t/* 104-111 */\n_L,_L,_L,_L,_L,_L,_L,_L,\t\t\t/* 112-119 */\n_L,_L,_L,_P,_P,_P,_P,_C,\t\t\t/* 120-127 */\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t\t/* 128-143 */\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t\t/* 144-159 */\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t\t/* 160-175 */\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t\t/* 176-191 */\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t\t/* 192-207 */\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t\t/* 208-223 */\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\t\t/* 224-239 */\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\t\t/* 240-255 */\n",
        "/*\n *  linux/lib/errno.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\nint errno;",
        "/*\n *  linux/lib/string.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#ifndef __GNUC__\n#error I want gcc!\n#endif\n\n#define extern\n#define inline\n#define static\n#define __LIBRARY__\n#include <string.h>",
        "/*\n *  linux/lib/_exit.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#define __LIBRARY__\n#include <unistd.h>\n\nvoid _exit(int exit_code)\n{\n\t__asm__ __volatile__ (\"int $0x80\"::\"a\" (__NR_exit),\"b\" (exit_code));\n}",
        "/*\n *  linux/lib/setsid.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#define __LIBRARY__\n#include <unistd.h>\n\n_syscall0(pid_t,setsid)",
        "/*\n * malloc.c --- a general purpose kernel memory allocator for Linux.\n * \n * Written by Theodore Ts'o (tytso@mit.edu), 11/29/91\n *\n * This routine is written to be as fast as possible, so that it\n * can be called from the interrupt level.\n *\n * Limitations: maximum size of memory we can allocate using this routine\n *\tis 4k, the size of a page in Linux.\n *\n * The general game plan is that each page (called a bucket) will only hold\n * objects of a given size.  When all of the object on a page are released,\n * the page can be returned to the general free pool.  When malloc() is\n * called, it looks for the smallest bucket size which will fulfill its\n * request, and allocate a piece of memory from that bucket pool.\n *\n * Each bucket has as its control block a bucket descriptor which keeps \n * track of how many objects are in use on that page, and the free list\n * for that page.  Like the buckets themselves, bucket descriptors are\n * stored on pages requested from get_free_page().  However, unlike buckets,\n * pages devoted to bucket descriptor pages are never released back to the\n * system.  Fortunately, a system should probably only need 1 or 2 bucket\n * descriptor pages, since a page can hold 256 bucket descriptors (which\n * corresponds to 1 megabyte worth of bucket pages.)  If the kernel is using \n * that much allocated memory, it's probably doing something wrong.  :-)\n *\n * Note: malloc() and free() both call get_free_page() and free_page()\n *\tin sections of code where interrupts are turned off, to allow\n *\tmalloc() and free() to be safely called from an interrupt routine.\n *\t(We will probably need this functionality when networking code,\n *\tparticularily things like NFS, is added to Linux.)  However, this\n *\tpresumes that get_free_page() and free_page() are interrupt-level\n *\tsafe, which they may not be once paging is added.  If this is the\n *\tcase, we will need to modify malloc() to keep a few unused pages\n *\t\"pre-allocated\" so that it can safely draw upon those pages if\n * \tit is called from an interrupt routine.\n *\n * \tAnother concern is that get_free_page() should not sleep; if it \n *\tdoes, the code is carefully ordered so as to avoid any race \n *\tconditions.  The catch is that if malloc() is called re-entrantly, \n *\tthere is a chance that unecessary pages will be grabbed from the \n *\tsystem.  Except for the pages for the bucket descriptor page, the \n *\textra pages will eventually get released back to the system, though,\n *\tso it isn't all that bad.\n */\n\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <asm/system.h>\n\nstruct bucket_desc {\t/* 16 bytes */\n\tvoid\t\t\t*page;\n\tstruct bucket_desc\t*next;\n\tvoid\t\t\t*freeptr;\n\tunsigned short\t\trefcnt;\n\tunsigned short\t\tbucket_size;\n};\n\nstruct _bucket_dir {\t/* 8 bytes */\n\tint\t\t\tsize;\n\tstruct bucket_desc\t*chain;\n};\n\n/*\n * The following is the where we store a pointer to the first bucket\n * descriptor for a given size.  \n *\n * If it turns out that the Linux kernel allocates a lot of objects of a\n * specific size, then we may want to add that specific size to this list,\n * since that will allow the memory to be allocated more efficiently.\n * However, since an entire page must be dedicated to each specific size\n * on this list, some amount of temperance must be exercised here.\n *\n * Note that this list *must* be kept in order.\n */\nstruct _bucket_dir bucket_dir[] = {\n\t{ 16,\t(struct bucket_desc *) 0},\n\t{ 32,\t(struct bucket_desc *) 0},\n\t{ 64,\t(struct bucket_desc *) 0},\n\t{ 128,\t(struct bucket_desc *) 0},\n\t{ 256,\t(struct bucket_desc *) 0},\n\t{ 512,\t(struct bucket_desc *) 0},\n\t{ 1024,\t(struct bucket_desc *) 0},\n\t{ 2048, (struct bucket_desc *) 0},\n\t{ 4096, (struct bucket_desc *) 0},\n\t{ 0,    (struct bucket_desc *) 0}};   /* End of list marker */\n\n/*\n * This contains a linked list of free bucket descriptor blocks\n */\nstruct bucket_desc *free_bucket_desc = (struct bucket_desc *) 0;\n\n/*\n * This routine initializes a bucket description page.\n */\nstatic inline void init_bucket_desc()\n{\n\tstruct bucket_desc *bdesc, *first;\n\tint\ti;\n\t\n\tfirst = bdesc = (struct bucket_desc *) get_free_page();\n\tif (!bdesc)\n\t\tpanic(\"Out of memory in init_bucket_desc()\");\n\tfor (i = PAGE_SIZE/sizeof(struct bucket_desc); i > 1; i--) {\n\t\tbdesc->next = bdesc+1;\n\t\tbdesc++;\n\t}\n\t/*\n\t * This is done last, to avoid race conditions in case \n\t * get_free_page() sleeps and this routine gets called again....\n\t */\n\tbdesc->next = free_bucket_desc;\n\tfree_bucket_desc = first;\n}\n\nvoid *malloc(unsigned int len)\n{\n\tstruct _bucket_dir\t*bdir;\n\tstruct bucket_desc\t*bdesc;\n\tvoid\t\t\t*retval;\n\n\t/*\n\t * First we search the bucket_dir to find the right bucket change\n\t * for this request.\n\t */\n\tfor (bdir = bucket_dir; bdir->size; bdir++)\n\t\tif (bdir->size >= len)\n\t\t\tbreak;\n\tif (!bdir->size) {\n\t\tprintk(\"malloc called with impossibly large argument (%d)\\n\",\n\t\t\tlen);\n\t\tpanic(\"malloc: bad arg\");\n\t}\n\t/*\n\t * Now we search for a bucket descriptor which has free space\n\t */\n\tcli();\t/* Avoid race conditions */\n\tfor (bdesc = bdir->chain; bdesc; bdesc = bdesc->next) \n\t\tif (bdesc->freeptr)\n\t\t\tbreak;\n\t/*\n\t * If we didn't find a bucket with free space, then we'll \n\t * allocate a new one.\n\t */\n\tif (!bdesc) {\n\t\tchar\t\t*cp;\n\t\tint\t\ti;\n\n\t\tif (!free_bucket_desc)\t\n\t\t\tinit_bucket_desc();\n\t\tbdesc = free_bucket_desc;\n\t\tfree_bucket_desc = bdesc->next;\n\t\tbdesc->refcnt = 0;\n\t\tbdesc->bucket_size = bdir->size;\n\t\tbdesc->page = bdesc->freeptr = (void *) (cp = (char *) get_free_page());\n\t\tif (!cp)\n\t\t\tpanic(\"Out of memory in kernel malloc()\");\n\t\t/* Set up the chain of free objects */\n\t\tfor (i=PAGE_SIZE/bdir->size; i > 1; i--) {\n\t\t\t*((char **) cp) = cp + bdir->size;\n\t\t\tcp += bdir->size;\n\t\t}\n\t\t*((char **) cp) = 0;\n\t\tbdesc->next = bdir->chain; /* OK, link it in! */\n\t\tbdir->chain = bdesc;\n\t}\n\tretval = (void *) bdesc->freeptr;\n\tbdesc->freeptr = *((void **) retval);\n\tbdesc->refcnt++;\n\tsti();\t/* OK, we're safe again */\n\treturn(retval);\n}\n\n/*\n * Here is the free routine.  If you know the size of the object that you\n * are freeing, then free_s() will use that information to speed up the\n * search for the bucket descriptor.\n * \n * We will #define a macro so that \"free(x)\" is becomes \"free_s(x, 0)\"\n */\nvoid free_s(void *obj, int size)\n{\n\tvoid\t\t*page;\n\tstruct _bucket_dir\t*bdir;\n\tstruct bucket_desc\t*bdesc, *prev;\n\tbdesc = prev = 0;\n\t/* Calculate what page this object lives in */\n\tpage = (void *)  ((unsigned long) obj & 0xfffff000);\n\t/* Now search the buckets looking for that page */\n\tfor (bdir = bucket_dir; bdir->size; bdir++) {\n\t\tprev = 0;\n\t\t/* If size is zero then this conditional is always false */\n\t\tif (bdir->size < size)\n\t\t\tcontinue;\n\t\tfor (bdesc = bdir->chain; bdesc; bdesc = bdesc->next) {\n\t\t\tif (bdesc->page == page) \n\t\t\t\tgoto found;\n\t\t\tprev = bdesc;\n\t\t}\n\t}\n\tpanic(\"Bad address passed to kernel free_s()\");\nfound:\n\tcli(); /* To avoid race conditions */\n\t*((void **)obj) = bdesc->freeptr;\n\tbdesc->freeptr = obj;\n\tbdesc->refcnt--;\n\tif (bdesc->refcnt == 0) {\n\t\t/*\n\t\t * We need to make sure that prev is still accurate.  It\n\t\t * may not be, if someone rudely interrupted us....\n\t\t */\n\t\tif ((prev && (prev->next != bdesc)) ||\n\t\t    (!prev && (bdir->chain != bdesc)))\n\t\t\tfor (prev = bdir->chain; prev; prev = prev->next)\n\t\t\t\tif (prev->next == bdesc)\n\t\t\t\t\tbreak;\n\t\tif (prev)\n\t\t\tprev->next = bdesc->next;\n\t\telse {\n\t\t\tif (bdir->chain != bdesc)\n\t\t\t\tpanic(\"malloc bucket chains corrupted\");\n\t\t\tbdir->chain = bdesc->next;\n\t\t}\n\t\tfree_page((unsigned long) bdesc->page);\n\t\tbdesc->next = free_bucket_desc;\n\t\tfree_bucket_desc = bdesc;\n\t}\n\tsti();\n\treturn;\n}\n",
        "/*\n *  linux/lib/wait.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#define __LIBRARY__\n#include <unistd.h>\n#include <sys/wait.h>\n\n_syscall3(pid_t,waitpid,pid_t,pid,int *,wait_stat,int,options)\n\npid_t wait(int * wait_stat)\n{\n\treturn waitpid(-1,wait_stat,0);\n}",
        "/*\n *  linux/lib/write.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#define __LIBRARY__\n#include <unistd.h>\n\n_syscall3(int,write,int,fd,const char *,buf,off_t,count)",
        "/*\n *  linux/lib/dup.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#define __LIBRARY__\n#include <unistd.h>\n\n_syscall1(int,dup,int,fd)",
        "/*\n *  linux/lib/open.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#define __LIBRARY__\n#include <unistd.h>\n#include <stdarg.h>\n\nint open(const char * filename, int flag, ...)\n{\n\tregister int res;\n\tva_list arg;\n\n\tva_start(arg,flag);\n\t__asm__(\"int $0x80\"\n\t\t:\"=a\" (res)\n\t\t:\"0\" (__NR_open),\"b\" (filename),\"c\" (flag),\n\t\t\"d\" (va_arg(arg,int)));\n\tif (res>=0)\n\t\treturn res;\n\terrno = -res;\n\treturn -1;\n}",
        "/*\n *  linux/lib/close.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#define __LIBRARY__\n#include <unistd.h>\n\n_syscall1(int,close,int,fd)",
        "/*\n *  linux/mm/memory.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * demand-loading started 01.12.91 - seems it is high on the list of\n * things wanted, and it should be easy to implement. - Linus\n */\n\n/*\n * Ok, demand-loading was easy, shared pages a little bit tricker. Shared\n * pages started 02.12.91, seems to work. - Linus.\n *\n * Tested sharing by executing about 30 /bin/sh: under the old kernel it\n * would have taken more than the 6M I have free, but it worked well as\n * far as I could see.\n *\n * Also corrected some \"invalidate()\"s - I wasn't doing enough of them.\n */\n\n#include <signal.h>\n\n#include <asm/system.h>\n\n#include <linux/sched.h>\n#include <linux/head.h>\n#include <linux/kernel.h>\n\nvoid do_exit(long code);\n\nstatic inline void oom(void)\n{\n\tprintk(\"out of memory\\n\\r\");\n\tdo_exit(SIGSEGV);\n}\n\n#define invalidate() \\\n__asm__(\"movl %%eax,%%cr3\"::\"a\" (0))\n\n/* these are not to be changed without changing head.s etc */\n#define LOW_MEM 0x100000\n#define PAGING_MEMORY (15*1024*1024)\n#define PAGING_PAGES (PAGING_MEMORY>>12)\n#define MAP_NR(addr) (((addr)-LOW_MEM)>>12)\n#define USED 100\n\n#define CODE_SPACE(addr) ((((addr)+4095)&~4095) < \\\ncurrent->start_code + current->end_code)\n\nstatic long HIGH_MEMORY = 0;\n\n#define copy_page(from,to) \\\n__asm__(\"cld ; rep ; movsl\"::\"S\" (from),\"D\" (to),\"c\" (1024))\n\nstatic unsigned char mem_map [ PAGING_PAGES ] = {0,};\n\n/*\n * Get physical address of first (actually last :-) free page, and mark it\n * used. If no free pages left, return 0.\n */\nunsigned long get_free_page(void)\n{\nregister unsigned long __res asm(\"ax\");\n\n__asm__(\"std ; repne ; scasb\\n\\t\"\n\t\"jne 1f\\n\\t\"\n\t\"movb $1,1(%%edi)\\n\\t\"\n\t\"sall $12,%%ecx\\n\\t\"\n\t\"addl %2,%%ecx\\n\\t\"\n\t\"movl %%ecx,%%edx\\n\\t\"\n\t\"movl $1024,%%ecx\\n\\t\"\n\t\"leal 4092(%%edx),%%edi\\n\\t\"\n\t\"rep ; stosl\\n\\t\"\n\t\" movl %%edx,%%eax\\n\"\n\t\"1: cld\"\n\t:\"=a\" (__res)\n\t:\"0\" (0),\"i\" (LOW_MEM),\"c\" (PAGING_PAGES),\n\t\"D\" (mem_map+PAGING_PAGES-1)\n\t);\nreturn __res;\n}\n\n/*\n * Free a page of memory at physical address 'addr'. Used by\n * 'free_page_tables()'\n */\nvoid free_page(unsigned long addr)\n{\n\tif (addr < LOW_MEM) return;\n\tif (addr >= HIGH_MEMORY)\n\t\tpanic(\"trying to free nonexistent page\");\n\taddr -= LOW_MEM;\n\taddr >>= 12;\n\tif (mem_map[addr]--) return;\n\tmem_map[addr]=0;\n\tpanic(\"trying to free free page\");\n}\n\n/*\n * This function frees a continuos block of page tables, as needed\n * by 'exit()'. As does copy_page_tables(), this handles only 4Mb blocks.\n */\nint free_page_tables(unsigned long from,unsigned long size)\n{\n\tunsigned long *pg_table;\n\tunsigned long * dir, nr;\n\n\tif (from & 0x3fffff)\n\t\tpanic(\"free_page_tables called with wrong alignment\");\n\tif (!from)\n\t\tpanic(\"Trying to free up swapper memory space\");\n\tsize = (size + 0x3fffff) >> 22;\n\tdir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */\n\tfor ( ; size-->0 ; dir++) {\n\t\tif (!(1 & *dir))\n\t\t\tcontinue;\n\t\tpg_table = (unsigned long *) (0xfffff000 & *dir);\n\t\tfor (nr=0 ; nr<1024 ; nr++) {\n\t\t\tif (1 & *pg_table)\n\t\t\t\tfree_page(0xfffff000 & *pg_table);\n\t\t\t*pg_table = 0;\n\t\t\tpg_table++;\n\t\t}\n\t\tfree_page(0xfffff000 & *dir);\n\t\t*dir = 0;\n\t}\n\tinvalidate();\n\treturn 0;\n}\n\n/*\n *  Well, here is one of the most complicated functions in mm. It\n * copies a range of linerar addresses by copying only the pages.\n * Let's hope this is bug-free, 'cause this one I don't want to debug :-)\n *\n * Note! We don't copy just any chunks of memory - addresses have to\n * be divisible by 4Mb (one page-directory entry), as this makes the\n * function easier. It's used only by fork anyway.\n *\n * NOTE 2!! When from==0 we are copying kernel space for the first\n * fork(). Then we DONT want to copy a full page-directory entry, as\n * that would lead to some serious memory waste - we just copy the\n * first 160 pages - 640kB. Even that is more than we need, but it\n * doesn't take any more memory - we don't copy-on-write in the low\n * 1 Mb-range, so the pages can be shared with the kernel. Thus the\n * special case for nr=xxxx.\n */\nint copy_page_tables(unsigned long from,unsigned long to,long size)\n{\n\tunsigned long * from_page_table;\n\tunsigned long * to_page_table;\n\tunsigned long this_page;\n\tunsigned long * from_dir, * to_dir;\n\tunsigned long nr;\n\n\tif ((from&0x3fffff) || (to&0x3fffff))\n\t\tpanic(\"copy_page_tables called with wrong alignment\");\n\tfrom_dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */\n\tto_dir = (unsigned long *) ((to>>20) & 0xffc);\n\tsize = ((unsigned) (size+0x3fffff)) >> 22;\n\tfor( ; size-->0 ; from_dir++,to_dir++) {\n\t\tif (1 & *to_dir)\n\t\t\tpanic(\"copy_page_tables: already exist\");\n\t\tif (!(1 & *from_dir))\n\t\t\tcontinue;\n\t\tfrom_page_table = (unsigned long *) (0xfffff000 & *from_dir);\n\t\tif (!(to_page_table = (unsigned long *) get_free_page()))\n\t\t\treturn -1;\t/* Out of memory, see freeing */\n\t\t*to_dir = ((unsigned long) to_page_table) | 7;\n\t\tnr = (from==0)?0xA0:1024;\n\t\tfor ( ; nr-- > 0 ; from_page_table++,to_page_table++) {\n\t\t\tthis_page = *from_page_table;\n\t\t\tif (!(1 & this_page))\n\t\t\t\tcontinue;\n\t\t\tthis_page &= ~2;\n\t\t\t*to_page_table = this_page;\n\t\t\tif (this_page > LOW_MEM) {\n\t\t\t\t*from_page_table = this_page;\n\t\t\t\tthis_page -= LOW_MEM;\n\t\t\t\tthis_page >>= 12;\n\t\t\t\tmem_map[this_page]++;\n\t\t\t}\n\t\t}\n\t}\n\tinvalidate();\n\treturn 0;\n}\n\n/*\n * This function puts a page in memory at the wanted address.\n * It returns the physical address of the page gotten, 0 if\n * out of memory (either when trying to access page-table or\n * page.)\n */\nunsigned long put_page(unsigned long page,unsigned long address)\n{\n\tunsigned long tmp, *page_table;\n\n/* NOTE !!! This uses the fact that _pg_dir=0 */\n\n\tif (page < LOW_MEM || page >= HIGH_MEMORY)\n\t\tprintk(\"Trying to put page %p at %p\\n\",page,address);\n\tif (mem_map[(page-LOW_MEM)>>12] != 1)\n\t\tprintk(\"mem_map disagrees with %p at %p\\n\",page,address);\n\tpage_table = (unsigned long *) ((address>>20) & 0xffc);\n\tif ((*page_table)&1)\n\t\tpage_table = (unsigned long *) (0xfffff000 & *page_table);\n\telse {\n\t\tif (!(tmp=get_free_page()))\n\t\t\treturn 0;\n\t\t*page_table = tmp|7;\n\t\tpage_table = (unsigned long *) tmp;\n\t}\n\tpage_table[(address>>12) & 0x3ff] = page | 7;\n/* no need for invalidate */\n\treturn page;\n}\n\nvoid un_wp_page(unsigned long * table_entry)\n{\n\tunsigned long old_page,new_page;\n\n\told_page = 0xfffff000 & *table_entry;\n\tif (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)]==1) {\n\t\t*table_entry |= 2;\n\t\tinvalidate();\n\t\treturn;\n\t}\n\tif (!(new_page=get_free_page()))\n\t\toom();\n\tif (old_page >= LOW_MEM)\n\t\tmem_map[MAP_NR(old_page)]--;\n\t*table_entry = new_page | 7;\n\tinvalidate();\n\tcopy_page(old_page,new_page);\n}\t\n\n/*\n * This routine handles present pages, when users try to write\n * to a shared page. It is done by copying the page to a new address\n * and decrementing the shared-page counter for the old page.\n *\n * If it's in code space we exit with a segment error.\n */\nvoid do_wp_page(unsigned long error_code,unsigned long address)\n{\n#if 0\n/* we cannot do this yet: the estdio library writes to code space */\n/* stupid, stupid. I really want the libc.a from GNU */\n\tif (CODE_SPACE(address))\n\t\tdo_exit(SIGSEGV);\n#endif\n\tun_wp_page((unsigned long *)\n\t\t(((address>>10) & 0xffc) + (0xfffff000 &\n\t\t*((unsigned long *) ((address>>20) &0xffc)))));\n\n}\n\nvoid write_verify(unsigned long address)\n{\n\tunsigned long page;\n\n\tif (!( (page = *((unsigned long *) ((address>>20) & 0xffc)) )&1))\n\t\treturn;\n\tpage &= 0xfffff000;\n\tpage += ((address>>10) & 0xffc);\n\tif ((3 & *(unsigned long *) page) == 1)  /* non-writeable, present */\n\t\tun_wp_page((unsigned long *) page);\n\treturn;\n}\n\nvoid get_empty_page(unsigned long address)\n{\n\tunsigned long tmp;\n\n\tif (!(tmp=get_free_page()) || !put_page(tmp,address)) {\n\t\tfree_page(tmp);\t\t/* 0 is ok - ignored */\n\t\toom();\n\t}\n}\n\n/*\n * try_to_share() checks the page at address \"address\" in the task \"p\",\n * to see if it exists, and if it is clean. If so, share it with the current\n * task.\n *\n * NOTE! This assumes we have checked that p != current, and that they\n * share the same executable.\n */\nstatic int try_to_share(unsigned long address, struct task_struct * p)\n{\n\tunsigned long from;\n\tunsigned long to;\n\tunsigned long from_page;\n\tunsigned long to_page;\n\tunsigned long phys_addr;\n\n\tfrom_page = to_page = ((address>>20) & 0xffc);\n\tfrom_page += ((p->start_code>>20) & 0xffc);\n\tto_page += ((current->start_code>>20) & 0xffc);\n/* is there a page-directory at from? */\n\tfrom = *(unsigned long *) from_page;\n\tif (!(from & 1))\n\t\treturn 0;\n\tfrom &= 0xfffff000;\n\tfrom_page = from + ((address>>10) & 0xffc);\n\tphys_addr = *(unsigned long *) from_page;\n/* is the page clean and present? */\n\tif ((phys_addr & 0x41) != 0x01)\n\t\treturn 0;\n\tphys_addr &= 0xfffff000;\n\tif (phys_addr >= HIGH_MEMORY || phys_addr < LOW_MEM)\n\t\treturn 0;\n\tto = *(unsigned long *) to_page;\n\tif (!(to & 1)) {\n\t\tif ((to = get_free_page()))\n\t\t\t*(unsigned long *) to_page = to | 7;\n\t\telse\n\t\t\toom();\n\t}\n\tto &= 0xfffff000;\n\tto_page = to + ((address>>10) & 0xffc);\n\tif (1 & *(unsigned long *) to_page)\n\t\tpanic(\"try_to_share: to_page already exists\");\n/* share them: write-protect */\n\t*(unsigned long *) from_page &= ~2;\n\t*(unsigned long *) to_page = *(unsigned long *) from_page;\n\tinvalidate();\n\tphys_addr -= LOW_MEM;\n\tphys_addr >>= 12;\n\tmem_map[phys_addr]++;\n\treturn 1;\n}\n\n/*\n * share_page() tries to find a process that could share a page with\n * the current one. Address is the address of the wanted page relative\n * to the current data space.\n *\n * We first check if it is at all feasible by checking executable->i_count.\n * It should be >1 if there are other tasks sharing this inode.\n */\nstatic int share_page(unsigned long address)\n{\n\tstruct task_struct ** p;\n\n\tif (!current->executable)\n\t\treturn 0;\n\tif (current->executable->i_count < 2)\n\t\treturn 0;\n\tfor (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\tif (current == *p)\n\t\t\tcontinue;\n\t\tif ((*p)->executable != current->executable)\n\t\t\tcontinue;\n\t\tif (try_to_share(address,*p))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid do_no_page(unsigned long error_code,unsigned long address)\n{\n\tint nr[4];\n\tunsigned long tmp;\n\tunsigned long page;\n\tint block,i;\n\n\taddress &= 0xfffff000;\n\ttmp = address - current->start_code;\n\tif (!current->executable || tmp >= current->end_data) {\n\t\tget_empty_page(address);\n\t\treturn;\n\t}\n\tif (share_page(tmp))\n\t\treturn;\n\tif (!(page = get_free_page()))\n\t\toom();\n/* remember that 1 block is used for header */\n\tblock = 1 + tmp/BLOCK_SIZE;\n\tfor (i=0 ; i<4 ; block++,i++)\n\t\tnr[i] = bmap(current->executable,block);\n\tbread_page(page,current->executable->i_dev,nr);\n\ti = tmp + 4096 - current->end_data;\n\ttmp = page + 4096;\n\twhile (i-- > 0) {\n\t\ttmp--;\n\t\t*(char *)tmp = 0;\n\t}\n\tif (put_page(page,address))\n\t\treturn;\n\tfree_page(page);\n\toom();\n}\n\nvoid mem_init(long start_mem, long end_mem)\n{\n\tint i;\n\n\tHIGH_MEMORY = end_mem;\n\tfor (i=0 ; i<PAGING_PAGES ; i++)\n\t\tmem_map[i] = USED;\n\ti = MAP_NR(start_mem);\n\tend_mem -= start_mem;\n\tend_mem >>= 12;\n\twhile (end_mem-->0)\n\t\tmem_map[i++]=0;\n}\n\nvoid calc_mem(void)\n{\n\tint i,j,k,free=0;\n\tlong * pg_tbl;\n\n\tfor(i=0 ; i<PAGING_PAGES ; i++)\n\t\tif (!mem_map[i]) free++;\n\tprintk(\"%d pages free (of %d)\\n\\r\",free,PAGING_PAGES);\n\tfor(i=2 ; i<1024 ; i++) {\n\t\tif (1&pg_dir[i]) {\n\t\t\tpg_tbl=(long *) (0xfffff000 & pg_dir[i]);\n\t\t\tfor(j=k=0 ; j<1024 ; j++)\n\t\t\t\tif (pg_tbl[j]&1)\n\t\t\t\t\tk++;\n\t\t\tprintk(\"Pg-dir[%d] uses %d pages\\n\",i,k);\n\t\t}\n\t}\n}",
        "/*\n *  linux/fs/super.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * super.c contains code to handle the super-block tables.\n */\n#include <linux/config.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/system.h>\n\n#include <errno.h>\n#include <sys/stat.h>\n\nint sync_dev(int dev);\nvoid wait_for_keypress(void);\n\n/* set_bit uses setb, as gas doesn't recognize setc */\n#define set_bit(bitnr,addr) ({ \\\nregister int __res ; \\\n__asm__(\"bt %2,%3;setb %%al\":\"=a\" (__res):\"a\" (0),\"r\" (bitnr),\"m\" (*(addr))); \\\n__res; })\n\nstruct super_block super_block[NR_SUPER];\n/* this is initialized in init/main.c */\nint ROOT_DEV = 0;\n\nstatic void lock_super(struct super_block * sb)\n{\n\tcli();\n\twhile (sb->s_lock)\n\t\tsleep_on(&(sb->s_wait));\n\tsb->s_lock = 1;\n\tsti();\n}\n\nstatic void free_super(struct super_block * sb)\n{\n\tcli();\n\tsb->s_lock = 0;\n\twake_up(&(sb->s_wait));\n\tsti();\n}\n\nstatic void wait_on_super(struct super_block * sb)\n{\n\tcli();\n\twhile (sb->s_lock)\n\t\tsleep_on(&(sb->s_wait));\n\tsti();\n}\n\nstruct super_block * get_super(int dev)\n{\n\tstruct super_block * s;\n\n\tif (!dev)\n\t\treturn NULL;\n\ts = 0+super_block;\n\twhile (s < NR_SUPER+super_block)\n\t\tif (s->s_dev == dev) {\n\t\t\twait_on_super(s);\n\t\t\tif (s->s_dev == dev)\n\t\t\t\treturn s;\n\t\t\ts = 0+super_block;\n\t\t} else\n\t\t\ts++;\n\treturn NULL;\n}\n\nvoid put_super(int dev)\n{\n\tstruct super_block * sb;\n\t/* struct m_inode * inode;*/\n\tint i;\n\n\tif (dev == ROOT_DEV) {\n\t\tprintk(\"root diskette changed: prepare for armageddon\\n\\r\");\n\t\treturn;\n\t}\n\tif (!(sb = get_super(dev)))\n\t\treturn;\n\tif (sb->s_imount) {\n\t\tprintk(\"Mounted disk changed - tssk, tssk\\n\\r\");\n\t\treturn;\n\t}\n\tlock_super(sb);\n\tsb->s_dev = 0;\n\tfor(i=0;i<I_MAP_SLOTS;i++)\n\t\tbrelse(sb->s_imap[i]);\n\tfor(i=0;i<Z_MAP_SLOTS;i++)\n\t\tbrelse(sb->s_zmap[i]);\n\tfree_super(sb);\n\treturn;\n}\n\nstatic struct super_block * read_super(int dev)\n{\n\tstruct super_block * s;\n\tstruct buffer_head * bh;\n\tint i,block;\n\n\tif (!dev)\n\t\treturn NULL;\n\tcheck_disk_change(dev);\n\tif ((s = get_super(dev)))\n\t\treturn s;\n\tfor (s = 0+super_block ;; s++) {\n\t\tif (s >= NR_SUPER+super_block)\n\t\t\treturn NULL;\n\t\tif (!s->s_dev)\n\t\t\tbreak;\n\t}\n\ts->s_dev = dev;\n\ts->s_isup = NULL;\n\ts->s_imount = NULL;\n\ts->s_time = 0;\n\ts->s_rd_only = 0;\n\ts->s_dirt = 0;\n\tlock_super(s);\n\tif (!(bh = bread(dev,1))) {\n\t\ts->s_dev=0;\n\t\tfree_super(s);\n\t\treturn NULL;\n\t}\n\t*((struct d_super_block *) s) =\n\t\t*((struct d_super_block *) bh->b_data);\n\tbrelse(bh);\n\tif (s->s_magic != SUPER_MAGIC) {\n\t\ts->s_dev = 0;\n\t\tfree_super(s);\n\t\treturn NULL;\n\t}\n\tfor (i=0;i<I_MAP_SLOTS;i++)\n\t\ts->s_imap[i] = NULL;\n\tfor (i=0;i<Z_MAP_SLOTS;i++)\n\t\ts->s_zmap[i] = NULL;\n\tblock=2;\n\tfor (i=0 ; i < s->s_imap_blocks ; i++)\n\t\tif ((s->s_imap[i]=bread(dev,block)))\n\t\t\tblock++;\n\t\telse\n\t\t\tbreak;\n\tfor (i=0 ; i < s->s_zmap_blocks ; i++)\n\t\tif ((s->s_zmap[i]=bread(dev,block)))\n\t\t\tblock++;\n\t\telse\n\t\t\tbreak;\n\tif (block != 2+s->s_imap_blocks+s->s_zmap_blocks) {\n\t\tfor(i=0;i<I_MAP_SLOTS;i++)\n\t\t\tbrelse(s->s_imap[i]);\n\t\tfor(i=0;i<Z_MAP_SLOTS;i++)\n\t\t\tbrelse(s->s_zmap[i]);\n\t\ts->s_dev=0;\n\t\tfree_super(s);\n\t\treturn NULL;\n\t}\n\ts->s_imap[0]->b_data[0] |= 1;\n\ts->s_zmap[0]->b_data[0] |= 1;\n\tfree_super(s);\n\treturn s;\n}\n\nint sys_umount(char * dev_name)\n{\n\tstruct m_inode * inode;\n\tstruct super_block * sb;\n\tint dev;\n\n\tif (!(inode=namei(dev_name)))\n\t\treturn -ENOENT;\n\tdev = inode->i_zone[0];\n\tif (!S_ISBLK(inode->i_mode)) {\n\t\tiput(inode);\n\t\treturn -ENOTBLK;\n\t}\n\tiput(inode);\n\tif (dev==ROOT_DEV)\n\t\treturn -EBUSY;\n\tif (!(sb=get_super(dev)) || !(sb->s_imount))\n\t\treturn -ENOENT;\n\tif (!sb->s_imount->i_mount)\n\t\tprintk(\"Mounted inode has i_mount=0\\n\");\n\tfor (inode=inode_table+0 ; inode<inode_table+NR_INODE ; inode++)\n\t\tif (inode->i_dev==dev && inode->i_count)\n\t\t\t\treturn -EBUSY;\n\tsb->s_imount->i_mount=0;\n\tiput(sb->s_imount);\n\tsb->s_imount = NULL;\n\tiput(sb->s_isup);\n\tsb->s_isup = NULL;\n\tput_super(dev);\n\tsync_dev(dev);\n\treturn 0;\n}\n\nint sys_mount(char * dev_name, char * dir_name, int rw_flag)\n{\n\tstruct m_inode * dev_i, * dir_i;\n\tstruct super_block * sb;\n\tint dev;\n\n\tif (!(dev_i=namei(dev_name)))\n\t\treturn -ENOENT;\n\tdev = dev_i->i_zone[0];\n\tif (!S_ISBLK(dev_i->i_mode)) {\n\t\tiput(dev_i);\n\t\treturn -EPERM;\n\t}\n\tiput(dev_i);\n\tif (!(dir_i=namei(dir_name)))\n\t\treturn -ENOENT;\n\tif (dir_i->i_count != 1 || dir_i->i_num == ROOT_INO) {\n\t\tiput(dir_i);\n\t\treturn -EBUSY;\n\t}\n\tif (!S_ISDIR(dir_i->i_mode)) {\n\t\tiput(dir_i);\n\t\treturn -EPERM;\n\t}\n\tif (!(sb=read_super(dev))) {\n\t\tiput(dir_i);\n\t\treturn -EBUSY;\n\t}\n\tif (sb->s_imount) {\n\t\tiput(dir_i);\n\t\treturn -EBUSY;\n\t}\n\tif (dir_i->i_mount) {\n\t\tiput(dir_i);\n\t\treturn -EPERM;\n\t}\n\tsb->s_imount=dir_i;\n\tdir_i->i_mount=1;\n\tdir_i->i_dirt=1;\t\t/* NOTE! we don't iput(dir_i) */\n\treturn 0;\t\t\t/* we do that in umount */\n}\n\nvoid mount_root(void)\n{\n\tint i,free;\n\tstruct super_block * p;\n\tstruct m_inode * mi;\n\n\tif (32 != sizeof (struct d_inode))\n\t\tpanic(\"bad i-node size\");\n\tfor(i=0;i<NR_FILE;i++)\n\t\tfile_table[i].f_count=0;\n\tif (MAJOR(ROOT_DEV) == 2) {\n\t\tprintk(\"Insert root floppy and press ENTER\");\n\t\twait_for_keypress();\n\t}\n\tfor(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {\n\t\tp->s_dev = 0;\n\t\tp->s_lock = 0;\n\t\tp->s_wait = NULL;\n\t}\n\tif (!(p=read_super(ROOT_DEV)))\n\t\tpanic(\"Unable to mount root\");\n\tif (!(mi=iget(ROOT_DEV,ROOT_INO)))\n\t\tpanic(\"Unable to read root i-node\");\n\tmi->i_count += 3 ;\t/* NOTE! it is logically used 4 times, not 1 */\n\tp->s_isup = p->s_imount = mi;\n\tcurrent->pwd = mi;\n\tcurrent->root = mi;\n\tfree=0;\n\ti=p->s_nzones;\n\twhile (-- i >= 0)\n\t\tif (!set_bit(i&8191,p->s_zmap[i>>13]->b_data))\n\t\t\tfree++;\n\tprintk(\"%d/%d free blocks\\n\\r\",free,p->s_nzones);\n\tfree=0;\n\ti=p->s_ninodes+1;\n\twhile (-- i >= 0)\n\t\tif (!set_bit(i&8191,p->s_imap[i>>13]->b_data))\n\t\t\tfree++;\n\tprintk(\"%d/%d free inodes\\n\\r\",free,p->s_ninodes);\n}",
        "/*\n *  linux/fs/file_table.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <linux/fs.h>\n\nstruct file file_table[NR_FILE];",
        "/*\n *  linux/fs/buffer.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n *  'buffer.c' implements the buffer-cache functions. Race-conditions have\n * been avoided by NEVER letting a interrupt change a buffer (except for the\n * data, of course), but instead letting the caller do it. NOTE! As interrupts\n * can wake up a caller, some cli-sti sequences are needed to check for\n * sleep-on-calls. These should be extremely quick, though (I hope).\n */\n\n/*\n * NOTE! There is one discordant note here: checking floppies for\n * disk change. This is where it fits best, I think, as it should\n * invalidate changed floppy-disk-caches.\n */\n\n#include <stdarg.h>\n \n#include <linux/config.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/system.h>\n#include <asm/io.h>\n\nextern int end;\nextern void put_super(int);\nextern void invalidate_inodes(int);\n\nstruct buffer_head * start_buffer = (struct buffer_head *) &end;\nstruct buffer_head * hash_table[NR_HASH];\nstatic struct buffer_head * free_list;\nstatic struct task_struct * buffer_wait = NULL;\nint NR_BUFFERS = 0;\n\nstatic inline void wait_on_buffer(struct buffer_head * bh)\n{\n\tcli();\n\twhile (bh->b_lock)\n\t\tsleep_on(&bh->b_wait);\n\tsti();\n}\n\nint sys_sync(void)\n{\n\tint i;\n\tstruct buffer_head * bh;\n\n\tsync_inodes();\t\t/* write out inodes into buffers */\n\tbh = start_buffer;\n\tfor (i=0 ; i<NR_BUFFERS ; i++,bh++) {\n\t\twait_on_buffer(bh);\n\t\tif (bh->b_dirt)\n\t\t\tll_rw_block(WRITE,bh);\n\t}\n\treturn 0;\n}\n\nint sync_dev(int dev)\n{\n\tint i;\n\tstruct buffer_head * bh;\n\n\tbh = start_buffer;\n\tfor (i=0 ; i<NR_BUFFERS ; i++,bh++) {\n\t\tif (bh->b_dev != dev)\n\t\t\tcontinue;\n\t\twait_on_buffer(bh);\n\t\tif (bh->b_dev == dev && bh->b_dirt)\n\t\t\tll_rw_block(WRITE,bh);\n\t}\n\tsync_inodes();\n\tbh = start_buffer;\n\tfor (i=0 ; i<NR_BUFFERS ; i++,bh++) {\n\t\tif (bh->b_dev != dev)\n\t\t\tcontinue;\n\t\twait_on_buffer(bh);\n\t\tif (bh->b_dev == dev && bh->b_dirt)\n\t\t\tll_rw_block(WRITE,bh);\n\t}\n\treturn 0;\n}\n\nstatic inline void invalidate_buffers(int dev)\n{\n\tint i;\n\tstruct buffer_head * bh;\n\n\tbh = start_buffer;\n\tfor (i=0 ; i<NR_BUFFERS ; i++,bh++) {\n\t\tif (bh->b_dev != dev)\n\t\t\tcontinue;\n\t\twait_on_buffer(bh);\n\t\tif (bh->b_dev == dev)\n\t\t\tbh->b_uptodate = bh->b_dirt = 0;\n\t}\n}\n\n/*\n * This routine checks whether a floppy has been changed, and\n * invalidates all buffer-cache-entries in that case. This\n * is a relatively slow routine, so we have to try to minimize using\n * it. Thus it is called only upon a 'mount' or 'open'. This\n * is the best way of combining speed and utility, I think.\n * People changing diskettes in the middle of an operation deserve\n * to loose :-)\n *\n * NOTE! Although currently this is only for floppies, the idea is\n * that any additional removable block-device will use this routine,\n * and that mount/open needn't know that floppies/whatever are\n * special.\n */\nvoid check_disk_change(int dev)\n{\n\tint i;\n\n\tif (MAJOR(dev) != 2)\n\t\treturn;\n\tif (!floppy_change(dev & 0x03))\n\t\treturn;\n\tfor (i=0 ; i<NR_SUPER ; i++)\n\t\tif (super_block[i].s_dev == dev)\n\t\t\tput_super(super_block[i].s_dev);\n\tinvalidate_inodes(dev);\n\tinvalidate_buffers(dev);\n}\n\n#define _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)\n#define hash(dev,block) hash_table[_hashfn(dev,block)]\n\nstatic inline void remove_from_queues(struct buffer_head * bh)\n{\n/* remove from hash-queue */\n\tif (bh->b_next)\n\t\tbh->b_next->b_prev = bh->b_prev;\n\tif (bh->b_prev)\n\t\tbh->b_prev->b_next = bh->b_next;\n\tif (hash(bh->b_dev,bh->b_blocknr) == bh)\n\t\thash(bh->b_dev,bh->b_blocknr) = bh->b_next;\n/* remove from free list */\n\tif (!(bh->b_prev_free) || !(bh->b_next_free))\n\t\tpanic(\"Free block list corrupted\");\n\tbh->b_prev_free->b_next_free = bh->b_next_free;\n\tbh->b_next_free->b_prev_free = bh->b_prev_free;\n\tif (free_list == bh)\n\t\tfree_list = bh->b_next_free;\n}\n\nstatic inline void insert_into_queues(struct buffer_head * bh)\n{\n/* put at end of free list */\n\tbh->b_next_free = free_list;\n\tbh->b_prev_free = free_list->b_prev_free;\n\tfree_list->b_prev_free->b_next_free = bh;\n\tfree_list->b_prev_free = bh;\n/* put the buffer in new hash-queue if it has a device */\n\tbh->b_prev = NULL;\n\tbh->b_next = NULL;\n\tif (!bh->b_dev)\n\t\treturn;\n\tbh->b_next = hash(bh->b_dev,bh->b_blocknr);\n\thash(bh->b_dev,bh->b_blocknr) = bh;\n\tbh->b_next->b_prev = bh;\n}\n\nstatic struct buffer_head * find_buffer(int dev, int block)\n{\t\t\n\tstruct buffer_head * tmp;\n\n\tfor (tmp = hash(dev,block) ; tmp != NULL ; tmp = tmp->b_next)\n\t\tif (tmp->b_dev==dev && tmp->b_blocknr==block)\n\t\t\treturn tmp;\n\treturn NULL;\n}\n\n/*\n * Why like this, I hear you say... The reason is race-conditions.\n * As we don't lock buffers (unless we are readint them, that is),\n * something might happen to it while we sleep (ie a read-error\n * will force it bad). This shouldn't really happen currently, but\n * the code is ready.\n */\nstruct buffer_head * get_hash_table(int dev, int block)\n{\n\tstruct buffer_head * bh;\n\n\tfor (;;) {\n\t\tif (!(bh=find_buffer(dev,block)))\n\t\t\treturn NULL;\n\t\tbh->b_count++;\n\t\twait_on_buffer(bh);\n\t\tif (bh->b_dev == dev && bh->b_blocknr == block)\n\t\t\treturn bh;\n\t\tbh->b_count--;\n\t}\n}\n\n/*\n * Ok, this is getblk, and it isn't very clear, again to hinder\n * race-conditions. Most of the code is seldom used, (ie repeating),\n * so it should be much more efficient than it looks.\n *\n * The algoritm is changed: hopefully better, and an elusive bug removed.\n */\n#define BADNESS(bh) (((bh)->b_dirt<<1)+(bh)->b_lock)\nstruct buffer_head * getblk(int dev,int block)\n{\n\tstruct buffer_head * tmp, * bh;\n\nrepeat:\n\tif ((bh = get_hash_table(dev,block)))\n\t\treturn bh;\n\ttmp = free_list;\n\tdo {\n\t\tif (tmp->b_count)\n\t\t\tcontinue;\n\t\tif (!bh || BADNESS(tmp)<BADNESS(bh)) {\n\t\t\tbh = tmp;\n\t\t\tif (!BADNESS(tmp))\n\t\t\t\tbreak;\n\t\t}\n/* and repeat until we find something good */\n\t} while ((tmp = tmp->b_next_free) != free_list);\n\tif (!bh) {\n\t\tsleep_on(&buffer_wait);\n\t\tgoto repeat;\n\t}\n\twait_on_buffer(bh);\n\tif (bh->b_count)\n\t\tgoto repeat;\n\twhile (bh->b_dirt) {\n\t\tsync_dev(bh->b_dev);\n\t\twait_on_buffer(bh);\n\t\tif (bh->b_count)\n\t\t\tgoto repeat;\n\t}\n/* NOTE!! While we slept waiting for this block, somebody else might */\n/* already have added \"this\" block to the cache. check it */\n\tif (find_buffer(dev,block))\n\t\tgoto repeat;\n/* OK, FINALLY we know that this buffer is the only one of it's kind, */\n/* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */\n\tbh->b_count=1;\n\tbh->b_dirt=0;\n\tbh->b_uptodate=0;\n\tremove_from_queues(bh);\n\tbh->b_dev=dev;\n\tbh->b_blocknr=block;\n\tinsert_into_queues(bh);\n\treturn bh;\n}\n\nvoid brelse(struct buffer_head * buf)\n{\n\tif (!buf)\n\t\treturn;\n\twait_on_buffer(buf);\n\tif (!(buf->b_count--))\n\t\tpanic(\"Trying to free free buffer\");\n\twake_up(&buffer_wait);\n}\n\n/*\n * bread() reads a specified block and returns the buffer that contains\n * it. It returns NULL if the block was unreadable.\n */\nstruct buffer_head * bread(int dev,int block)\n{\n\tstruct buffer_head * bh;\n\n\tif (!(bh=getblk(dev,block)))\n\t\tpanic(\"bread: getblk returned NULL\\n\");\n\tif (bh->b_uptodate)\n\t\treturn bh;\n\tll_rw_block(READ,bh);\n\twait_on_buffer(bh);\n\tif (bh->b_uptodate)\n\t\treturn bh;\n\tbrelse(bh);\n\treturn NULL;\n}\n\n#define COPYBLK(from,to) \\\n__asm__(\"cld\\n\\t\" \\\n\t\"rep\\n\\t\" \\\n\t\"movsl\\n\\t\" \\\n\t::\"c\" (BLOCK_SIZE/4),\"S\" (from),\"D\" (to) \\\n\t)\n\n/*\n * bread_page reads four buffers into memory at the desired address. It's\n * a function of its own, as there is some speed to be got by reading them\n * all at the same time, not waiting for one to be read, and then another\n * etc.\n */\nvoid bread_page(unsigned long address,int dev,int b[4])\n{\n\tstruct buffer_head * bh[4];\n\tint i;\n\n\tfor (i=0 ; i<4 ; i++)\n\t\tif (b[i]) {\n\t\t\tif ((bh[i] = getblk(dev,b[i])))\n\t\t\t\tif (!bh[i]->b_uptodate)\n\t\t\t\t\tll_rw_block(READ,bh[i]);\n\t\t} else\n\t\t\tbh[i] = NULL;\n\tfor (i=0 ; i<4 ; i++,address += BLOCK_SIZE)\n\t\tif (bh[i]) {\n\t\t\twait_on_buffer(bh[i]);\n\t\t\tif (bh[i]->b_uptodate)\n\t\t\t\tCOPYBLK((unsigned long) bh[i]->b_data,address);\n\t\t\tbrelse(bh[i]);\n\t\t}\n}\n\n/*\n * Ok, breada can be used as bread, but additionally to mark other\n * blocks for reading as well. End the argument list with a negative\n * number.\n */\nstruct buffer_head * breada(int dev,int first, ...)\n{\n\tva_list args;\n\tstruct buffer_head * bh, *tmp;\n\n\tva_start(args,first);\n\tif (!(bh=getblk(dev,first)))\n\t\tpanic(\"bread: getblk returned NULL\\n\");\n\tif (!bh->b_uptodate)\n\t\tll_rw_block(READ,bh);\n\twhile ((first=va_arg(args,int))>=0) {\n\t\ttmp=getblk(dev,first);\n\t\tif (tmp) {\n\t\t\tif (!tmp->b_uptodate)\n\t\t\t\tll_rw_block(READA,tmp);\n\t\t\ttmp->b_count--;\n\t\t}\n\t}\n\tva_end(args);\n\twait_on_buffer(bh);\n\tif (bh->b_uptodate)\n\t\treturn bh;\n\tbrelse(bh);\n\treturn (NULL);\n}\n\nvoid buffer_init(long buffer_end)\n{\n\tstruct buffer_head * h = start_buffer;\n\tvoid * b;\n\tint i;\n\n\tif (buffer_end == 1<<20)\n\t\tb = (void *) (640*1024);\n\telse\n\t\tb = (void *) buffer_end;\n\twhile ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) {\n\t\th->b_dev = 0;\n\t\th->b_dirt = 0;\n\t\th->b_count = 0;\n\t\th->b_lock = 0;\n\t\th->b_uptodate = 0;\n\t\th->b_wait = NULL;\n\t\th->b_next = NULL;\n\t\th->b_prev = NULL;\n\t\th->b_data = (char *) b;\n\t\th->b_prev_free = h-1;\n\t\th->b_next_free = h+1;\n\t\th++;\n\t\tNR_BUFFERS++;\n\t\tif (b == (void *) 0x100000)\n\t\t\tb = (void *) 0xA0000;\n\t}\n\th--;\n\tfree_list = start_buffer;\n\tfree_list->b_prev_free = h;\n\th->b_next_free = free_list;\n\tfor (i=0;i<NR_HASH;i++)\n\t\thash_table[i]=NULL;\n}\t",
        "/*\n *  linux/fs/pipe.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <signal.h>\n\n#include <linux/sched.h>\n#include <linux/mm.h>\t/* for get_free_page */\n#include <asm/segment.h>\n\nint read_pipe(struct m_inode * inode, char * buf, int count)\n{\n\tint chars, size, read = 0;\n\n\twhile (count>0) {\n\t\twhile (!(size=PIPE_SIZE(*inode))) {\n\t\t\twake_up(&inode->i_wait);\n\t\t\tif (inode->i_count != 2) /* are there any writers? */\n\t\t\t\treturn read;\n\t\t\tsleep_on(&inode->i_wait);\n\t\t}\n\t\tchars = PAGE_SIZE-PIPE_TAIL(*inode);\n\t\tif (chars > count)\n\t\t\tchars = count;\n\t\tif (chars > size)\n\t\t\tchars = size;\n\t\tcount -= chars;\n\t\tread += chars;\n\t\tsize = PIPE_TAIL(*inode);\n\t\tPIPE_TAIL(*inode) += chars;\n\t\tPIPE_TAIL(*inode) &= (PAGE_SIZE-1);\n\t\twhile (chars-->0)\n\t\t\tput_fs_byte(((char *)inode->i_size)[size++],buf++);\n\t}\n\twake_up(&inode->i_wait);\n\treturn read;\n}\n\t\nint write_pipe(struct m_inode * inode, char * buf, int count)\n{\n\tint chars, size, written = 0;\n\n\twhile (count>0) {\n\t\twhile (!(size=(PAGE_SIZE-1)-PIPE_SIZE(*inode))) {\n\t\t\twake_up(&inode->i_wait);\n\t\t\tif (inode->i_count != 2) { /* no readers */\n\t\t\t\tcurrent->signal |= (1<<(SIGPIPE-1));\n\t\t\t\treturn written?written:-1;\n\t\t\t}\n\t\t\tsleep_on(&inode->i_wait);\n\t\t}\n\t\tchars = PAGE_SIZE-PIPE_HEAD(*inode);\n\t\tif (chars > count)\n\t\t\tchars = count;\n\t\tif (chars > size)\n\t\t\tchars = size;\n\t\tcount -= chars;\n\t\twritten += chars;\n\t\tsize = PIPE_HEAD(*inode);\n\t\tPIPE_HEAD(*inode) += chars;\n\t\tPIPE_HEAD(*inode) &= (PAGE_SIZE-1);\n\t\twhile (chars-->0)\n\t\t\t((char *)inode->i_size)[size++]=get_fs_byte(buf++);\n\t}\n\twake_up(&inode->i_wait);\n\treturn written;\n}\n\nint sys_pipe(unsigned long * fildes)\n{\n\tstruct m_inode * inode;\n\tstruct file * f[2];\n\tint fd[2];\n\tint i,j;\n\n\tj=0;\n\tfor(i=0;j<2 && i<NR_FILE;i++)\n\t\tif (!file_table[i].f_count)\n\t\t\t(f[j++]=i+file_table)->f_count++;\n\tif (j==1)\n\t\tf[0]->f_count=0;\n\tif (j<2)\n\t\treturn -1;\n\tj=0;\n\tfor(i=0;j<2 && i<NR_OPEN;i++)\n\t\tif (!current->filp[i]) {\n\t\t\tcurrent->filp[ fd[j]=i ] = f[j];\n\t\t\tj++;\n\t\t}\n\tif (j==1)\n\t\tcurrent->filp[fd[0]]=NULL;\n\tif (j<2) {\n\t\tf[0]->f_count=f[1]->f_count=0;\n\t\treturn -1;\n\t}\n\tif (!(inode=get_pipe_inode())) {\n\t\tcurrent->filp[fd[0]] =\n\t\t\tcurrent->filp[fd[1]] = NULL;\n\t\tf[0]->f_count = f[1]->f_count = 0;\n\t\treturn -1;\n\t}\n\tf[0]->f_inode = f[1]->f_inode = inode;\n\tf[0]->f_pos = f[1]->f_pos = 0;\n\tf[0]->f_mode = 1;\t\t/* read */\n\tf[1]->f_mode = 2;\t\t/* write */\n\tput_fs_long(fd[0],0+fildes);\n\tput_fs_long(fd[1],1+fildes);\n\treturn 0;\n}",
        "/*\n *  linux/fs/exec.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * #!-checking implemented by tytso.\n */\n\n/*\n * Demand-loading implemented 01.12.91 - no need to read anything but\n * the header into memory. The inode of the executable is put into\n * \"current->executable\", and page faults do the actual loading. Clean.\n *\n * Once more I can proudly say that linux stood up to being changed: it\n * was less than 2 hours work to get demand-loading completely implemented.\n */\n\n#include <errno.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <a.out.h>\n\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <asm/segment.h>\n\nextern int sys_exit(int exit_code);\nextern int sys_close(int fd);\n\n/*\n * MAX_ARG_PAGES defines the number of pages allocated for arguments\n * and envelope for the new program. 32 should suffice, this gives\n * a maximum env+arg of 128kB !\n */\n#define MAX_ARG_PAGES 32\n\n/*\n * create_tables() parses the env- and arg-strings in new user\n * memory and creates the pointer tables from them, and puts their\n * addresses on the \"stack\", returning the new stack pointer value.\n */\nstatic unsigned long * create_tables(char * p,int argc,int envc)\n{\n\tunsigned long *argv,*envp;\n\tunsigned long * sp;\n\n\tsp = (unsigned long *) (0xfffffffc & (unsigned long) p);\n\tsp -= envc+1;\n\tenvp = sp;\n\tsp -= argc+1;\n\targv = sp;\n\tput_fs_long((unsigned long)envp,--sp);\n\tput_fs_long((unsigned long)argv,--sp);\n\tput_fs_long((unsigned long)argc,--sp);\n\twhile (argc-->0) {\n\t\tput_fs_long((unsigned long) p,argv++);\n\t\twhile (get_fs_byte(p++)) /* nothing */ ;\n\t}\n\tput_fs_long(0,argv);\n\twhile (envc-->0) {\n\t\tput_fs_long((unsigned long) p,envp++);\n\t\twhile (get_fs_byte(p++)) /* nothing */ ;\n\t}\n\tput_fs_long(0,envp);\n\treturn sp;\n}\n\n/*\n * count() counts the number of arguments/envelopes\n */\nstatic int count(char ** argv)\n{\n\tint i=0;\n\tchar ** tmp;\n\n\tif ((tmp = argv))\n\t\twhile (get_fs_long((unsigned long *) (tmp++)))\n\t\t\ti++;\n\n\treturn i;\n}\n\n/*\n * 'copy_string()' copies argument/envelope strings from user\n * memory to free pages in kernel mem. These are in a format ready\n * to be put directly into the top of new user memory.\n *\n * Modified by TYT, 11/24/91 to add the from_kmem argument, which specifies\n * whether the string and the string array are from user or kernel segments:\n * \n * from_kmem     argv *        argv **\n *    0          user space    user space\n *    1          kernel space  user space\n *    2          kernel space  kernel space\n * \n * We do this by playing games with the fs segment register.  Since it\n * it is expensive to load a segment register, we try to avoid calling\n * set_fs() unless we absolutely have to.\n */\nstatic unsigned long copy_strings(int argc,char ** argv,unsigned long *page,\n\t\tunsigned long p, int from_kmem)\n{\n\tchar *tmp, *pag=NULL;\n\tint len, offset = 0;\n\tunsigned long old_fs, new_fs;\n\n\tif (!p)\n\t\treturn 0;\t/* bullet-proofing */\n\tnew_fs = get_ds();\n\told_fs = get_fs();\n\tif (from_kmem==2)\n\t\tset_fs(new_fs);\n\twhile (argc-- > 0) {\n\t\tif (from_kmem == 1)\n\t\t\tset_fs(new_fs);\n\t\tif (!(tmp = (char *)get_fs_long(((unsigned long *)argv)+argc)))\n\t\t\tpanic(\"argc is wrong\");\n\t\tif (from_kmem == 1)\n\t\t\tset_fs(old_fs);\n\t\tlen=0;\t\t/* remember zero-padding */\n\t\tdo {\n\t\t\tlen++;\n\t\t} while (get_fs_byte(tmp++));\n\t\tif (p-len < 0) {\t/* this shouldn't happen - 128kB */\n\t\t\tset_fs(old_fs);\n\t\t\treturn 0;\n\t\t}\n\t\twhile (len) {\n\t\t\t--p; --tmp; --len;\n\t\t\tif (--offset < 0) {\n\t\t\t\toffset = p % PAGE_SIZE;\n\t\t\t\tif (from_kmem==2)\n\t\t\t\t\tset_fs(old_fs);\n\t\t\t\tif (!(pag = (char *) page[p/PAGE_SIZE]) &&\n\t\t\t\t    !(pag = (char *) (page[p/PAGE_SIZE] =\n\t\t\t\t      get_free_page()))) \n\t\t\t\t\treturn 0;\n\t\t\t\tif (from_kmem==2)\n\t\t\t\t\tset_fs(new_fs);\n\n\t\t\t}\n\t\t\t*(pag + offset) = get_fs_byte(tmp);\n\t\t}\n\t}\n\tif (from_kmem==2)\n\t\tset_fs(old_fs);\n\treturn p;\n}\n\nstatic unsigned long change_ldt(unsigned long text_size,unsigned long * page)\n{\n\tunsigned long code_limit,data_limit,code_base,data_base;\n\tint i;\n\n\tcode_limit = text_size+PAGE_SIZE -1;\n\tcode_limit &= 0xFFFFF000;\n\tdata_limit = 0x4000000;\n\tcode_base = get_base(current->ldt[1]);\n\tdata_base = code_base;\n\tset_base(current->ldt[1],code_base);\n\tset_limit(current->ldt[1],code_limit);\n\tset_base(current->ldt[2],data_base);\n\tset_limit(current->ldt[2],data_limit);\n/* make sure fs points to the NEW data segment */\n\t__asm__(\"pushl $0x17\\n\\tpop %%fs\"::);\n\tdata_base += data_limit;\n\tfor (i=MAX_ARG_PAGES-1 ; i>=0 ; i--) {\n\t\tdata_base -= PAGE_SIZE;\n\t\tif (page[i])\n\t\t\tput_page(page[i],data_base);\n\t}\n\treturn data_limit;\n}\n\n/*\n * 'do_execve()' executes a new program.\n */\nint do_execve(unsigned long * eip,long tmp,char * filename,\n\tchar ** argv, char ** envp)\n{\n\tstruct m_inode * inode;\n\tstruct buffer_head * bh;\n\tstruct exec ex;\n\tunsigned long page[MAX_ARG_PAGES];\n\tint i,argc,envc;\n\tint e_uid, e_gid;\n\tint retval;\n\tint sh_bang = 0;\n\tunsigned long p=PAGE_SIZE*MAX_ARG_PAGES-4;\n\n\tif ((0xffff & eip[1]) != 0x000f)\n\t\tpanic(\"execve called from supervisor mode\");\n\tfor (i=0 ; i<MAX_ARG_PAGES ; i++)\t/* clear page-table */\n\t\tpage[i]=0;\n\tif (!(inode=namei(filename)))\t\t/* get executables inode */\n\t\treturn -ENOENT;\n\targc = count(argv);\n\tenvc = count(envp);\n\t\nrestart_interp:\n\tif (!S_ISREG(inode->i_mode)) {\t/* must be regular file */\n\t\tretval = -EACCES;\n\t\tgoto exec_error2;\n\t}\n\ti = inode->i_mode;\n\te_uid = (i & S_ISUID) ? inode->i_uid : current->euid;\n\te_gid = (i & S_ISGID) ? inode->i_gid : current->egid;\n\tif (current->euid == inode->i_uid)\n\t\ti >>= 6;\n\telse if (current->egid == inode->i_gid)\n\t\ti >>= 3;\n\tif (!(i & 1) &&\n\t    !((inode->i_mode & 0111) && suser())) {\n\t\tretval = -ENOEXEC;\n\t\tgoto exec_error2;\n\t}\n\tif (!(bh = bread(inode->i_dev,inode->i_zone[0]))) {\n\t\tretval = -EACCES;\n\t\tgoto exec_error2;\n\t}\n\tex = *((struct exec *) bh->b_data);\t/* read exec-header */\n\tif ((bh->b_data[0] == '#') && (bh->b_data[1] == '!') && (!sh_bang)) {\n\t\t/*\n\t\t * This section does the #! interpretation.\n\t\t * Sorta complicated, but hopefully it will work.  -TYT\n\t\t */\n\n\t\tchar buf[1023], *cp, *interp, *i_name, *i_arg;\n\t\tunsigned long old_fs;\n\n\t\tstrncpy(buf, bh->b_data+2, 1022);\n\t\tbrelse(bh);\n\t\tiput(inode);\n\t\tbuf[1022] = '\\0';\n\t\tif ((cp = strchr(buf, '\\n'))) {\n\t\t\t*cp = '\\0';\n\t\t\tfor (cp = buf; (*cp == ' ') || (*cp == '\\t'); cp++);\n\t\t}\n\t\tif (!cp || *cp == '\\0') {\n\t\t\tretval = -ENOEXEC; /* No interpreter name found */\n\t\t\tgoto exec_error1;\n\t\t}\n\t\tinterp = i_name = cp;\n\t\ti_arg = 0;\n\t\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++) {\n \t\t\tif (*cp == '/')\n\t\t\t\ti_name = cp+1;\n\t\t}\n\t\tif (*cp) {\n\t\t\t*cp++ = '\\0';\n\t\t\ti_arg = cp;\n\t\t}\n\t\t/*\n\t\t * OK, we've parsed out the interpreter name and\n\t\t * (optional) argument.\n\t\t */\n\t\tif (sh_bang++ == 0) {\n\t\t\tp = copy_strings(envc, envp, page, p, 0);\n\t\t\tp = copy_strings(--argc, argv+1, page, p, 0);\n\t\t}\n\t\t/*\n\t\t * Splice in (1) the interpreter's name for argv[0]\n\t\t *           (2) (optional) argument to interpreter\n\t\t *           (3) filename of shell script\n\t\t *\n\t\t * This is done in reverse order, because of how the\n\t\t * user environment and arguments are stored.\n\t\t */\n\t\tp = copy_strings(1, &filename, page, p, 1);\n\t\targc++;\n\t\tif (i_arg) {\n\t\t\tp = copy_strings(1, &i_arg, page, p, 2);\n\t\t\targc++;\n\t\t}\n\t\tp = copy_strings(1, &i_name, page, p, 2);\n\t\targc++;\n\t\tif (!p) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto exec_error1;\n\t\t}\n\t\t/*\n\t\t * OK, now restart the process with the interpreter's inode.\n\t\t */\n\t\told_fs = get_fs();\n\t\tset_fs(get_ds());\n\t\tif (!(inode=namei(interp))) { /* get executables inode */\n\t\t\tset_fs(old_fs);\n\t\t\tretval = -ENOENT;\n\t\t\tgoto exec_error1;\n\t\t}\n\t\tset_fs(old_fs);\n\t\tgoto restart_interp;\n\t}\n\tbrelse(bh);\n\tif (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||\n\t\tex.a_text+ex.a_data+ex.a_bss>0x3000000 ||\n\t\tinode->i_size < ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) {\n\t\tretval = -ENOEXEC;\n\t\tgoto exec_error2;\n\t}\n\tif (N_TXTOFF(ex) != BLOCK_SIZE) {\n\t\tprintk(\"%s: N_TXTOFF != BLOCK_SIZE. See a.out.h.\", filename);\n\t\tretval = -ENOEXEC;\n\t\tgoto exec_error2;\n\t}\n\tif (!sh_bang) {\n\t\tp = copy_strings(envc,envp,page,p,0);\n\t\tp = copy_strings(argc,argv,page,p,0);\n\t\tif (!p) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto exec_error2;\n\t\t}\n\t}\n/* OK, This is the point of no return */\n\tif (current->executable)\n\t\tiput(current->executable);\n\tcurrent->executable = inode;\n\tfor (i=0 ; i<32 ; i++) {\n\t\tif (current->sigaction[i].sa_handler != SIG_IGN)\n\t\t\tcurrent->sigaction[i].sa_handler = NULL;\n\t}\n\tfor (i=0 ; i<NR_OPEN ; i++)\n\t\tif ((current->close_on_exec>>i)&1)\n\t\t\tsys_close(i);\n\tcurrent->close_on_exec = 0;\n\tfree_page_tables(get_base(current->ldt[1]),get_limit(0x0f));\n\tfree_page_tables(get_base(current->ldt[2]),get_limit(0x17));\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n\tcurrent->used_math = 0;\n\tp += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;\n\tp = (unsigned long) create_tables((char *)p,argc,envc);\n\tcurrent->brk = ex.a_bss +\n\t\t(current->end_data = ex.a_data +\n\t\t(current->end_code = ex.a_text));\n\tcurrent->start_stack = p & 0xfffff000;\n\tcurrent->euid = e_uid;\n\tcurrent->egid = e_gid;\n\ti = ex.a_text+ex.a_data;\n\twhile (i&0xfff)\n\t\tput_fs_byte(0,(char *) (i++));\n\teip[0] = ex.a_entry;\t\t/* eip, magic happens :-) */\n\teip[3] = p;\t\t\t/* stack pointer */\n\treturn 0;\nexec_error2:\n\tiput(inode);\nexec_error1:\n\tfor (i=0 ; i<MAX_ARG_PAGES ; i++)\n\t\tfree_page(page[i]);\n\treturn(retval);\n}",
        "/*\n *  linux/fs/bitmap.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/* bitmap.c contains the code that handles the inode and block bitmaps */\n#include <string.h>\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define clear_block(addr) \\\n__asm__ __volatile__ (\"cld\\n\\t\" \\\n\t\"rep\\n\\t\" \\\n\t\"stosl\" \\\n\t::\"a\" (0),\"c\" (BLOCK_SIZE/4),\"D\" ((long) (addr)))\n\n#define set_bit(nr,addr) ({\\\nregister int res ; \\\n__asm__ __volatile__(\"btsl %2,%3\\n\\tsetb %%al\": \\\n\"=a\" (res):\"0\" (0),\"r\" (nr),\"m\" (*(addr))); \\\nres;})\n\n#define clear_bit(nr,addr) ({\\\nregister int res ; \\\n__asm__ __volatile__(\"btrl %2,%3\\n\\tsetnb %%al\": \\\n\"=a\" (res):\"0\" (0),\"r\" (nr),\"m\" (*(addr))); \\\nres;})\n\n#define find_first_zero(addr) ({ \\\nint __res; \\\n__asm__ __volatile__ (\"cld\\n\" \\\n\t\"1:\\tlodsl\\n\\t\" \\\n\t\"notl %%eax\\n\\t\" \\\n\t\"bsfl %%eax,%%edx\\n\\t\" \\\n\t\"je 2f\\n\\t\" \\\n\t\"addl %%edx,%%ecx\\n\\t\" \\\n\t\"jmp 3f\\n\" \\\n\t\"2:\\taddl $32,%%ecx\\n\\t\" \\\n\t\"cmpl $8192,%%ecx\\n\\t\" \\\n\t\"jl 1b\\n\" \\\n\t\"3:\" \\\n\t:\"=c\" (__res):\"c\" (0),\"S\" (addr)); \\\n__res;})\n\nvoid free_block(int dev, int block)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh;\n\n\tif (!(sb = get_super(dev)))\n\t\tpanic(\"trying to free block on nonexistent device\");\n\tif (block < sb->s_firstdatazone || block >= sb->s_nzones)\n\t\tpanic(\"trying to free block not in datazone\");\n\tbh = get_hash_table(dev,block);\n\tif (bh) {\n\t\tif (bh->b_count != 1) {\n\t\t\tprintk(\"trying to free block (%04x:%d), count=%d\\n\",\n\t\t\t\tdev,block,bh->b_count);\n\t\t\treturn;\n\t\t}\n\t\tbh->b_dirt=0;\n\t\tbh->b_uptodate=0;\n\t\tbrelse(bh);\n\t}\n\tblock -= sb->s_firstdatazone - 1 ;\n\tif (clear_bit(block&8191,sb->s_zmap[block/8192]->b_data)) {\n\t\tprintk(\"block (%04x:%d) \",dev,block+sb->s_firstdatazone-1);\n\t\tpanic(\"free_block: bit already cleared\");\n\t}\n\tsb->s_zmap[block/8192]->b_dirt = 1;\n}\n\nint new_block(int dev)\n{\n\tstruct buffer_head * bh;\n\tstruct super_block * sb;\n\tint i,j;\n\n\tif (!(sb = get_super(dev)))\n\t\tpanic(\"trying to get new block from nonexistant device\");\n\tj = 8192;\n\tfor (i=0 ; i<8 ; i++)\n\t\tif ((bh=sb->s_zmap[i]))\n\t\t\tif ((j=find_first_zero(bh->b_data))<8192)\n\t\t\t\tbreak;\n\tif (i>=8 || !bh || j>=8192)\n\t\treturn 0;\n\tif (set_bit(j,bh->b_data))\n\t\tpanic(\"new_block: bit already set\");\n\tbh->b_dirt = 1;\n\tj += i*8192 + sb->s_firstdatazone-1;\n\tif (j >= sb->s_nzones)\n\t\treturn 0;\n\tif (!(bh=getblk(dev,j)))\n\t\tpanic(\"new_block: cannot get block\");\n\tif (bh->b_count != 1)\n\t\tpanic(\"new block: count is != 1\");\n\tclear_block(bh->b_data);\n\tbh->b_uptodate = 1;\n\tbh->b_dirt = 1;\n\tbrelse(bh);\n\treturn j;\n}\n\nvoid free_inode(struct m_inode * inode)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh;\n\n\tif (!inode)\n\t\treturn;\n\tif (!inode->i_dev) {\n\t\tmemset(inode,0,sizeof(*inode));\n\t\treturn;\n\t}\n\tif (inode->i_count>1) {\n\t\tprintk(\"trying to free inode with count=%d\\n\",inode->i_count);\n\t\tpanic(\"free_inode\");\n\t}\n\tif (inode->i_nlinks)\n\t\tpanic(\"trying to free inode with links\");\n\tif (!(sb = get_super(inode->i_dev)))\n\t\tpanic(\"trying to free inode on nonexistent device\");\n\tif (inode->i_num < 1 || inode->i_num > sb->s_ninodes)\n\t\tpanic(\"trying to free inode 0 or nonexistant inode\");\n\tif (!(bh=sb->s_imap[inode->i_num>>13]))\n\t\tpanic(\"nonexistent imap in superblock\");\n\tif (clear_bit(inode->i_num&8191,bh->b_data))\n\t\tprintk(\"free_inode: bit already cleared.\\n\\r\");\n\tbh->b_dirt = 1;\n\tmemset(inode,0,sizeof(*inode));\n}\n\nstruct m_inode * new_inode(int dev)\n{\n\tstruct m_inode * inode;\n\tstruct super_block * sb;\n\tstruct buffer_head * bh;\n\tint i,j;\n\n\tif (!(inode=get_empty_inode()))\n\t\treturn NULL;\n\tif (!(sb = get_super(dev)))\n\t\tpanic(\"new_inode with unknown device\");\n\tj = 8192;\n\tfor (i=0 ; i<8 ; i++)\n\t\tif ((bh=sb->s_imap[i]))\n\t\t\tif ((j=find_first_zero(bh->b_data))<8192)\n\t\t\t\tbreak;\n\tif (!bh || j >= 8192 || j+i*8192 > sb->s_ninodes) {\n\t\tiput(inode);\n\t\treturn NULL;\n\t}\n\tif (set_bit(j,bh->b_data))\n\t\tpanic(\"new_inode: bit already set\");\n\tbh->b_dirt = 1;\n\tinode->i_count=1;\n\tinode->i_nlinks=1;\n\tinode->i_dev=dev;\n\tinode->i_uid=current->euid;\n\tinode->i_gid=current->egid;\n\tinode->i_dirt=1;\n\tinode->i_num = j + i*8192;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\treturn inode;\n}",
        "/*\n *  linux/fs/file_dev.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <errno.h>\n#include <fcntl.h>\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/segment.h>\n\n#define MIN(a,b) (((a)<(b))?(a):(b))\n#define MAX(a,b) (((a)>(b))?(a):(b))\n\nint file_read(struct m_inode * inode, struct file * filp, char * buf, int count)\n{\n\tint left,chars,nr;\n\tstruct buffer_head * bh;\n\n\tif ((left=count)<=0)\n\t\treturn 0;\n\twhile (left) {\n\t\tif ((nr = bmap(inode,(filp->f_pos)/BLOCK_SIZE))) {\n\t\t\tif (!(bh=bread(inode->i_dev,nr)))\n\t\t\t\tbreak;\n\t\t} else\n\t\t\tbh = NULL;\n\t\tnr = filp->f_pos % BLOCK_SIZE;\n\t\tchars = MIN( BLOCK_SIZE-nr , left );\n\t\tfilp->f_pos += chars;\n\t\tleft -= chars;\n\t\tif (bh) {\n\t\t\tchar * p = nr + bh->b_data;\n\t\t\twhile (chars-->0)\n\t\t\t\tput_fs_byte(*(p++),buf++);\n\t\t\tbrelse(bh);\n\t\t} else {\n\t\t\twhile (chars-->0)\n\t\t\t\tput_fs_byte(0,buf++);\n\t\t}\n\t}\n\tinode->i_atime = CURRENT_TIME;\n\treturn (count-left)?(count-left):-ERROR;\n}\n\nint file_write(struct m_inode * inode, struct file * filp, char * buf, int count)\n{\n\toff_t pos;\n\tint block,c;\n\tstruct buffer_head * bh;\n\tchar * p;\n\tint i=0;\n\n/*\n * ok, append may not work when many processes are writing at the same time\n * but so what. That way leads to madness anyway.\n */\n\tif (filp->f_flags & O_APPEND)\n\t\tpos = inode->i_size;\n\telse\n\t\tpos = filp->f_pos;\n\twhile (i<count) {\n\t\tif (!(block = create_block(inode,pos/BLOCK_SIZE)))\n\t\t\tbreak;\n\t\tif (!(bh=bread(inode->i_dev,block)))\n\t\t\tbreak;\n\t\tc = pos % BLOCK_SIZE;\n\t\tp = c + bh->b_data;\n\t\tbh->b_dirt = 1;\n\t\tc = BLOCK_SIZE-c;\n\t\tif (c > count-i) c = count-i;\n\t\tpos += c;\n\t\tif (pos > inode->i_size) {\n\t\t\tinode->i_size = pos;\n\t\t\tinode->i_dirt = 1;\n\t\t}\n\t\ti += c;\n\t\twhile (c-->0)\n\t\t\t*(p++) = get_fs_byte(buf++);\n\t\tbrelse(bh);\n\t}\n\tinode->i_mtime = CURRENT_TIME;\n\tif (!(filp->f_flags & O_APPEND)) {\n\t\tfilp->f_pos = pos;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\treturn (i?i:-1);\n}",
        "/*\n *  linux/fs/inode.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <string.h> \n#include <sys/stat.h>\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <asm/system.h>\n\nstruct m_inode inode_table[NR_INODE]={{0,},};\n\nstatic void read_inode(struct m_inode * inode);\nstatic void write_inode(struct m_inode * inode);\n\nstatic inline void wait_on_inode(struct m_inode * inode)\n{\n\tcli();\n\twhile (inode->i_lock)\n\t\tsleep_on(&inode->i_wait);\n\tsti();\n}\n\nstatic inline void lock_inode(struct m_inode * inode)\n{\n\tcli();\n\twhile (inode->i_lock)\n\t\tsleep_on(&inode->i_wait);\n\tinode->i_lock=1;\n\tsti();\n}\n\nstatic inline void unlock_inode(struct m_inode * inode)\n{\n\tinode->i_lock=0;\n\twake_up(&inode->i_wait);\n}\n\nvoid invalidate_inodes(int dev)\n{\n\tint i;\n\tstruct m_inode * inode;\n\n\tinode = 0+inode_table;\n\tfor(i=0 ; i<NR_INODE ; i++,inode++) {\n\t\twait_on_inode(inode);\n\t\tif (inode->i_dev == dev) {\n\t\t\tif (inode->i_count)\n\t\t\t\tprintk(\"inode in use on removed disk\\n\\r\");\n\t\t\tinode->i_dev = inode->i_dirt = 0;\n\t\t}\n\t}\n}\n\nvoid sync_inodes(void)\n{\n\tint i;\n\tstruct m_inode * inode;\n\n\tinode = 0+inode_table;\n\tfor(i=0 ; i<NR_INODE ; i++,inode++) {\n\t\twait_on_inode(inode);\n\t\tif (inode->i_dirt && !inode->i_pipe)\n\t\t\twrite_inode(inode);\n\t}\n}\n\nstatic int _bmap(struct m_inode * inode,int block,int create)\n{\n\tstruct buffer_head * bh;\n\tint i;\n\n\tif (block<0)\n\t\tpanic(\"_bmap: block<0\");\n\tif (block >= 7+512+512*512)\n\t\tpanic(\"_bmap: block>big\");\n\tif (block<7) {\n\t\tif (create && !inode->i_zone[block])\n\t\t\tif ((inode->i_zone[block]=new_block(inode->i_dev))) {\n\t\t\t\tinode->i_ctime=CURRENT_TIME;\n\t\t\t\tinode->i_dirt=1;\n\t\t\t}\n\t\treturn inode->i_zone[block];\n\t}\n\tblock -= 7;\n\tif (block<512) {\n\t\tif (create && !inode->i_zone[7])\n\t\t\tif ((inode->i_zone[7]=new_block(inode->i_dev))) {\n\t\t\t\tinode->i_dirt=1;\n\t\t\t\tinode->i_ctime=CURRENT_TIME;\n\t\t\t}\n\t\tif (!inode->i_zone[7])\n\t\t\treturn 0;\n\t\tif (!(bh = bread(inode->i_dev,inode->i_zone[7])))\n\t\t\treturn 0;\n\t\ti = ((unsigned short *) (bh->b_data))[block];\n\t\tif (create && !i)\n\t\t\tif ((i=new_block(inode->i_dev))) {\n\t\t\t\t((unsigned short *) (bh->b_data))[block]=i;\n\t\t\t\tbh->b_dirt=1;\n\t\t\t}\n\t\tbrelse(bh);\n\t\treturn i;\n\t}\n\tblock -= 512;\n\tif (create && !inode->i_zone[8])\n\t\tif ((inode->i_zone[8]=new_block(inode->i_dev))) {\n\t\t\tinode->i_dirt=1;\n\t\t\tinode->i_ctime=CURRENT_TIME;\n\t\t}\n\tif (!inode->i_zone[8])\n\t\treturn 0;\n\tif (!(bh=bread(inode->i_dev,inode->i_zone[8])))\n\t\treturn 0;\n\ti = ((unsigned short *)bh->b_data)[block>>9];\n\tif (create && !i)\n\t\tif ((i=new_block(inode->i_dev))) {\n\t\t\t((unsigned short *) (bh->b_data))[block>>9]=i;\n\t\t\tbh->b_dirt=1;\n\t\t}\n\tbrelse(bh);\n\tif (!i)\n\t\treturn 0;\n\tif (!(bh=bread(inode->i_dev,i)))\n\t\treturn 0;\n\ti = ((unsigned short *)bh->b_data)[block&511];\n\tif (create && !i)\n\t\tif ((i=new_block(inode->i_dev))) {\n\t\t\t((unsigned short *) (bh->b_data))[block&511]=i;\n\t\t\tbh->b_dirt=1;\n\t\t}\n\tbrelse(bh);\n\treturn i;\n}\n\nint bmap(struct m_inode * inode,int block)\n{\n\treturn _bmap(inode,block,0);\n}\n\nint create_block(struct m_inode * inode, int block)\n{\n\treturn _bmap(inode,block,1);\n}\n\t\t\nvoid iput(struct m_inode * inode)\n{\n\tif (!inode)\n\t\treturn;\n\twait_on_inode(inode);\n\tif (!inode->i_count)\n\t\tpanic(\"iput: trying to free free inode\");\n\tif (inode->i_pipe) {\n\t\twake_up(&inode->i_wait);\n\t\tif (--inode->i_count)\n\t\t\treturn;\n\t\tfree_page(inode->i_size);\n\t\tinode->i_count=0;\n\t\tinode->i_dirt=0;\n\t\tinode->i_pipe=0;\n\t\treturn;\n\t}\n\tif (!inode->i_dev) {\n\t\tinode->i_count--;\n\t\treturn;\n\t}\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tsync_dev(inode->i_zone[0]);\n\t\twait_on_inode(inode);\n\t}\nrepeat:\n\tif (inode->i_count>1) {\n\t\tinode->i_count--;\n\t\treturn;\n\t}\n\tif (!inode->i_nlinks) {\n\t\ttruncate(inode);\n\t\tfree_inode(inode);\n\t\treturn;\n\t}\n\tif (inode->i_dirt) {\n\t\twrite_inode(inode);\t/* we can sleep - so do again */\n\t\twait_on_inode(inode);\n\t\tgoto repeat;\n\t}\n\tinode->i_count--;\n\treturn;\n}\n\nstruct m_inode * get_empty_inode(void)\n{\n\tstruct m_inode * inode;\n\tstatic struct m_inode * last_inode = inode_table;\n\tint i;\n\n\tdo {\n\t\tinode = NULL;\n\t\tfor (i = NR_INODE; i ; i--) {\n\t\t\tif (++last_inode >= inode_table + NR_INODE)\n\t\t\t\tlast_inode = inode_table;\n\t\t\tif (!last_inode->i_count) {\n\t\t\t\tinode = last_inode;\n\t\t\t\tif (!inode->i_dirt && !inode->i_lock)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!inode) {\n\t\t\tfor (i=0 ; i<NR_INODE ; i++)\n\t\t\t\tprintk(\"%04x: %6d\\t\",inode_table[i].i_dev,\n\t\t\t\t\tinode_table[i].i_num);\n\t\t\tpanic(\"No free inodes in mem\");\n\t\t}\n\t\twait_on_inode(inode);\n\t\twhile (inode->i_dirt) {\n\t\t\twrite_inode(inode);\n\t\t\twait_on_inode(inode);\n\t\t}\n\t} while (inode->i_count);\n\tmemset(inode,0,sizeof(*inode));\n\tinode->i_count = 1;\n\treturn inode;\n}\n\nstruct m_inode * get_pipe_inode(void)\n{\n\tstruct m_inode * inode;\n\n\tif (!(inode = get_empty_inode()))\n\t\treturn NULL;\n\tif (!(inode->i_size=get_free_page())) {\n\t\tinode->i_count = 0;\n\t\treturn NULL;\n\t}\n\tinode->i_count = 2;\t/* sum of readers/writers */\n\tPIPE_HEAD(*inode) = PIPE_TAIL(*inode) = 0;\n\tinode->i_pipe = 1;\n\treturn inode;\n}\n\nstruct m_inode * iget(int dev,int nr)\n{\n\tstruct m_inode * inode, * empty;\n\n\tif (!dev)\n\t\tpanic(\"iget with dev==0\");\n\tempty = get_empty_inode();\n\tinode = inode_table;\n\twhile (inode < NR_INODE+inode_table) {\n\t\tif (inode->i_dev != dev || inode->i_num != nr) {\n\t\t\tinode++;\n\t\t\tcontinue;\n\t\t}\n\t\twait_on_inode(inode);\n\t\tif (inode->i_dev != dev || inode->i_num != nr) {\n\t\t\tinode = inode_table;\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_count++;\n\t\tif (inode->i_mount) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0 ; i<NR_SUPER ; i++)\n\t\t\t\tif (super_block[i].s_imount==inode)\n\t\t\t\t\tbreak;\n\t\t\tif (i >= NR_SUPER) {\n\t\t\t\tprintk(\"Mounted inode hasn't got sb\\n\");\n\t\t\t\tif (empty)\n\t\t\t\t\tiput(empty);\n\t\t\t\treturn inode;\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\tdev = super_block[i].s_dev;\n\t\t\tnr = ROOT_INO;\n\t\t\tinode = inode_table;\n\t\t\tcontinue;\n\t\t}\n\t\tif (empty)\n\t\t\tiput(empty);\n\t\treturn inode;\n\t}\n\tif (!empty)\n\t\treturn (NULL);\n\tinode=empty;\n\tinode->i_dev = dev;\n\tinode->i_num = nr;\n\tread_inode(inode);\n\treturn inode;\n}\n\nstatic void read_inode(struct m_inode * inode)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh;\n\tint block;\n\n\tlock_inode(inode);\n\tif (!(sb=get_super(inode->i_dev)))\n\t\tpanic(\"trying to read inode without dev\");\n\tblock = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +\n\t\t(inode->i_num-1)/INODES_PER_BLOCK;\n\tif (!(bh=bread(inode->i_dev,block)))\n\t\tpanic(\"unable to read i-node block\");\n\t*(struct d_inode *)inode =\n\t\t((struct d_inode *)bh->b_data)\n\t\t\t[(inode->i_num-1)%INODES_PER_BLOCK];\n\tbrelse(bh);\n\tunlock_inode(inode);\n}\n\nstatic void write_inode(struct m_inode * inode)\n{\n\tstruct super_block * sb;\n\tstruct buffer_head * bh;\n\tint block;\n\n\tlock_inode(inode);\n\tif (!inode->i_dirt || !inode->i_dev) {\n\t\tunlock_inode(inode);\n\t\treturn;\n\t}\n\tif (!(sb=get_super(inode->i_dev)))\n\t\tpanic(\"trying to write inode without device\");\n\tblock = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +\n\t\t(inode->i_num-1)/INODES_PER_BLOCK;\n\tif (!(bh=bread(inode->i_dev,block)))\n\t\tpanic(\"unable to read i-node block\");\n\t((struct d_inode *)bh->b_data)\n\t\t[(inode->i_num-1)%INODES_PER_BLOCK] =\n\t\t\t*(struct d_inode *)inode;\n\tbh->b_dirt=1;\n\tinode->i_dirt=0;\n\tbrelse(bh);\n\tunlock_inode(inode);\n}",
        "/*\n *  linux/fs/truncate.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <linux/sched.h>\n\n#include <sys/stat.h>\n\nstatic void free_ind(int dev,int block)\n{\n\tstruct buffer_head * bh;\n\tunsigned short * p;\n\tint i;\n\n\tif (!block)\n\t\treturn;\n\tif ((bh=bread(dev,block))) {\n\t\tp = (unsigned short *) bh->b_data;\n\t\tfor (i=0;i<512;i++,p++)\n\t\t\tif (*p)\n\t\t\t\tfree_block(dev,*p);\n\t\tbrelse(bh);\n\t}\n\tfree_block(dev,block);\n}\n\nstatic void free_dind(int dev,int block)\n{\n\tstruct buffer_head * bh;\n\tunsigned short * p;\n\tint i;\n\n\tif (!block)\n\t\treturn;\n\tif ((bh=bread(dev,block))) {\n\t\tp = (unsigned short *) bh->b_data;\n\t\tfor (i=0;i<512;i++,p++)\n\t\t\tif (*p)\n\t\t\t\tfree_ind(dev,*p);\n\t\tbrelse(bh);\n\t}\n\tfree_block(dev,block);\n}\n\nvoid truncate(struct m_inode * inode)\n{\n\tint i;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))\n\t\treturn;\n\tfor (i=0;i<7;i++)\n\t\tif (inode->i_zone[i]) {\n\t\t\tfree_block(inode->i_dev,inode->i_zone[i]);\n\t\t\tinode->i_zone[i]=0;\n\t\t}\n\tfree_ind(inode->i_dev,inode->i_zone[7]);\n\tfree_dind(inode->i_dev,inode->i_zone[8]);\n\tinode->i_zone[7] = inode->i_zone[8] = 0;\n\tinode->i_size = 0;\n\tinode->i_dirt = 1;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n}\n",
        "/*\n *  linux/fs/ioctl.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/* #include <string.h>*/\n#include <errno.h>\n#include <sys/stat.h>\n\n#include <linux/sched.h>\n\nextern int tty_ioctl(int dev, int cmd, int arg);\n\ntypedef int (*ioctl_ptr)(int dev,int cmd,int arg);\n\n#define NRDEVS ((sizeof (ioctl_table))/(sizeof (ioctl_ptr)))\n\nstatic ioctl_ptr ioctl_table[]={\n\tNULL,\t\t/* nodev */\n\tNULL,\t\t/* /dev/mem */\n\tNULL,\t\t/* /dev/fd */\n\tNULL,\t\t/* /dev/hd */\n\ttty_ioctl,\t/* /dev/ttyx */\n\ttty_ioctl,\t/* /dev/tty */\n\tNULL,\t\t/* /dev/lp */\n\tNULL};\t\t/* named pipes */\n\t\n\nint sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)\n{\t\n\tstruct file * filp;\n\tint dev,mode;\n\n\tif (fd >= NR_OPEN || !(filp = current->filp[fd]))\n\t\treturn -EBADF;\n\tmode=filp->f_inode->i_mode;\n\tif (!S_ISCHR(mode) && !S_ISBLK(mode))\n\t\treturn -EINVAL;\n\tdev = filp->f_inode->i_zone[0];\n\tif (MAJOR(dev) >= NRDEVS)\n\t\treturn -ENODEV;\n\tif (!ioctl_table[MAJOR(dev)])\n\t\treturn -ENOTTY;\n\treturn ioctl_table[MAJOR(dev)](dev,cmd,arg);\n}",
        "/*\n *  linux/fs/namei.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * Some corrections by tytso.\n */\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/segment.h>\n\n#include <string.h> \n#include <fcntl.h>\n#include <errno.h>\n#include <const.h>\n#include <sys/stat.h>\n\n#define ACC_MODE(x) (\"\\004\\002\\006\\377\"[(x)&O_ACCMODE])\n\n/*\n * comment out this line if you want names > NAME_LEN chars to be\n * truncated. Else they will be disallowed.\n */\n/* #define NO_TRUNCATE */\n\n#define MAY_EXEC 1\n#define MAY_WRITE 2\n#define MAY_READ 4\n\n/*\n *\tpermission()\n *\n * is used to check for read/write/execute permissions on a file.\n * I don't know if we should look at just the euid or both euid and\n * uid, but that should be easily changed.\n */\nstatic int permission(struct m_inode * inode,int mask)\n{\n\tint mode = inode->i_mode;\n\n/* special case: not even root can read/write a deleted file */\n\tif (inode->i_dev && !inode->i_nlinks)\n\t\treturn 0;\n\telse if (current->euid==inode->i_uid)\n\t\tmode >>= 6;\n\telse if (current->egid==inode->i_gid)\n\t\tmode >>= 3;\n\tif (((mode & mask & 0007) == mask) || suser())\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * ok, we cannot use strncmp, as the name is not in our data space.\n * Thus we'll have to use match. No big problem. Match also makes\n * some sanity tests.\n *\n * NOTE! unlike strncmp, match returns 1 for success, 0 for failure.\n */\nstatic int match(int len,const char * name,struct dir_entry * de)\n{\n\tregister int same ;\n\n\tif (!de || !de->inode || len > NAME_LEN)\n\t\treturn 0;\n\tif (len < NAME_LEN && de->name[len])\n\t\treturn 0;\n\t__asm__(\"cld\\n\\t\"\n\t\t\"fs ; repe ; cmpsb\\n\\t\"\n\t\t\"setz %%al\"\n\t\t:\"=a\" (same)\n\t\t:\"0\" (0),\"S\" ((long) name),\"D\" ((long) de->name),\"c\" (len)\n\t\t);\n\treturn same;\n}\n\n/*\n *\tfind_entry()\n *\n * finds an entry in the specified directory with the wanted name. It\n * returns the cache buffer in which the entry was found, and the entry\n * itself (as a parameter - res_dir). It does NOT read the inode of the\n * entry - you'll have to do that yourself if you want to.\n *\n * This also takes care of the few special cases due to '..'-traversal\n * over a pseudo-root and a mount point.\n */\nstatic struct buffer_head * find_entry(struct m_inode ** dir,\n\tconst char * name, int namelen, struct dir_entry ** res_dir)\n{\n\tint entries;\n\tint block,i;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\tstruct super_block * sb;\n\n#ifdef NO_TRUNCATE\n\tif (namelen > NAME_LEN)\n\t\treturn NULL;\n#else\n\tif (namelen > NAME_LEN)\n\t\tnamelen = NAME_LEN;\n#endif\n\tentries = (*dir)->i_size / (sizeof (struct dir_entry));\n\t*res_dir = NULL;\n\tif (!namelen)\n\t\treturn NULL;\n/* check for '..', as we might have to do some \"magic\" for it */\n\tif (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {\n/* '..' in a pseudo-root results in a faked '.' (just change namelen) */\n\t\tif ((*dir) == current->root)\n\t\t\tnamelen=1;\n\t\telse if ((*dir)->i_num == ROOT_INO) {\n/* '..' over a mount-point results in 'dir' being exchanged for the mounted\n   directory-inode. NOTE! We set mounted, so that we can iput the new dir */\n\t\t\tsb=get_super((*dir)->i_dev);\n\t\t\tif (sb->s_imount) {\n\t\t\t\tiput(*dir);\n\t\t\t\t(*dir)=sb->s_imount;\n\t\t\t\t(*dir)->i_count++;\n\t\t\t}\n\t\t}\n\t}\n\tif (!(block = (*dir)->i_zone[0]))\n\t\treturn NULL;\n\tif (!(bh = bread((*dir)->i_dev,block)))\n\t\treturn NULL;\n\ti = 0;\n\tde = (struct dir_entry *) bh->b_data;\n\twhile (i < entries) {\n\t\tif ((char *)de >= BLOCK_SIZE+bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||\n\t\t\t    !(bh = bread((*dir)->i_dev,block))) {\n\t\t\t\ti += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (match(namelen,name,de)) {\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tde++;\n\t\ti++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}\n\n/*\n *\tadd_entry()\n *\n * adds a file entry to the specified directory, using the same\n * semantics as find_entry(). It returns NULL if it failed.\n *\n * NOTE!! The inode part of 'de' is left at 0 - which means you\n * may not sleep between calling this and putting something into\n * the entry, as someone else might have used it while you slept.\n */\nstatic struct buffer_head * add_entry(struct m_inode * dir,\n\tconst char * name, int namelen, struct dir_entry ** res_dir)\n{\n\tint block,i;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\t*res_dir = NULL;\n#ifdef NO_TRUNCATE\n\tif (namelen > NAME_LEN)\n\t\treturn NULL;\n#else\n\tif (namelen > NAME_LEN)\n\t\tnamelen = NAME_LEN;\n#endif\n\tif (!namelen)\n\t\treturn NULL;\n\tif (!(block = dir->i_zone[0]))\n\t\treturn NULL;\n\tif (!(bh = bread(dir->i_dev,block)))\n\t\treturn NULL;\n\ti = 0;\n\tde = (struct dir_entry *) bh->b_data;\n\twhile (1) {\n\t\tif ((char *)de >= BLOCK_SIZE+bh->b_data) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tblock = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);\n\t\t\tif (!block)\n\t\t\t\treturn NULL;\n\t\t\tif (!(bh = bread(dir->i_dev,block))) {\n\t\t\t\ti += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (i*sizeof(struct dir_entry) >= dir->i_size) {\n\t\t\tde->inode=0;\n\t\t\tdir->i_size = (i+1)*sizeof(struct dir_entry);\n\t\t\tdir->i_dirt = 1;\n\t\t\tdir->i_ctime = CURRENT_TIME;\n\t\t}\n\t\tif (!de->inode) {\n\t\t\tdir->i_mtime = CURRENT_TIME;\n\t\t\tfor (i=0; i < NAME_LEN ; i++)\n\t\t\t\tde->name[i]=(i<namelen)?get_fs_byte(name+i):0;\n\t\t\tbh->b_dirt = 1;\n\t\t\t*res_dir = de;\n\t\t\treturn bh;\n\t\t}\n\t\tde++;\n\t\ti++;\n\t}\n\tbrelse(bh);\n\treturn NULL;\n}\n\n/*\n *\tget_dir()\n *\n * Getdir traverses the pathname until it hits the topmost directory.\n * It returns NULL on failure.\n */\nstatic struct m_inode * get_dir(const char * pathname)\n{\n\tchar c;\n\tconst char * thisname;\n\tstruct m_inode * inode;\n\tstruct buffer_head * bh;\n\tint namelen,inr,idev;\n\tstruct dir_entry * de;\n\n\tif (!current->root || !current->root->i_count)\n\t\tpanic(\"No root inode\");\n\tif (!current->pwd || !current->pwd->i_count)\n\t\tpanic(\"No cwd inode\");\n\tif ((c=get_fs_byte(pathname))=='/') {\n\t\tinode = current->root;\n\t\tpathname++;\n\t} else if (c)\n\t\tinode = current->pwd;\n\telse\n\t\treturn NULL;\t/* empty name is bad */\n\tinode->i_count++;\n\twhile (1) {\n\t\tthisname = pathname;\n\t\tif (!S_ISDIR(inode->i_mode) || !permission(inode,MAY_EXEC)) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor(namelen=0;(c=get_fs_byte(pathname++))&&(c!='/');namelen++)\n\t\t\t/* nothing */ ;\n\t\tif (!c)\n\t\t\treturn inode;\n\t\tif (!(bh = find_entry(&inode,thisname,namelen,&de))) {\n\t\t\tiput(inode);\n\t\t\treturn NULL;\n\t\t}\n\t\tinr = de->inode;\n\t\tidev = inode->i_dev;\n\t\tbrelse(bh);\n\t\tiput(inode);\n\t\tif (!(inode = iget(idev,inr)))\n\t\t\treturn NULL;\n\t}\n}\n\n/*\n *\tdir_namei()\n *\n * dir_namei() returns the inode of the directory of the\n * specified name, and the name within that directory.\n */\nstatic struct m_inode * dir_namei(const char * pathname,\n\tint * namelen, const char ** name)\n{\n\tchar c;\n\tconst char * basename;\n\tstruct m_inode * dir;\n\n\tif (!(dir = get_dir(pathname)))\n\t\treturn NULL;\n\tbasename = pathname;\n\twhile ((c=get_fs_byte(pathname++)))\n\t\tif (c=='/')\n\t\t\tbasename=pathname;\n\t*namelen = pathname-basename-1;\n\t*name = basename;\n\treturn dir;\n}\n\n/*\n *\tnamei()\n *\n * is used by most simple commands to get the inode of a specified name.\n * Open, link etc use their own routines, but this is enough for things\n * like 'chmod' etc.\n */\nstruct m_inode * namei(const char * pathname)\n{\n\tconst char * basename;\n\tint inr,dev,namelen;\n\tstruct m_inode * dir;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif (!(dir = dir_namei(pathname,&namelen,&basename)))\n\t\treturn NULL;\n\tif (!namelen)\t\t\t/* special case: '/usr/' etc */\n\t\treturn dir;\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tiput(dir);\n\t\treturn NULL;\n\t}\n\tinr = de->inode;\n\tdev = dir->i_dev;\n\tbrelse(bh);\n\tiput(dir);\n\tdir=iget(dev,inr);\n\tif (dir) {\n\t\tdir->i_atime=CURRENT_TIME;\n\t\tdir->i_dirt=1;\n\t}\n\treturn dir;\n}\n\n/*\n *\topen_namei()\n *\n * namei for open - this is in fact almost the whole open-routine.\n */\nint open_namei(const char * pathname, int flag, int mode,\n\tstruct m_inode ** res_inode)\n{\n\tconst char * basename;\n\tint inr,dev,namelen;\n\tstruct m_inode * dir, *inode;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif ((flag & O_TRUNC) && !(flag & O_ACCMODE))\n\t\tflag |= O_WRONLY;\n\tmode &= 0777 & ~current->umask;\n\tmode |= I_REGULAR;\n\tif (!(dir = dir_namei(pathname,&namelen,&basename)))\n\t\treturn -ENOENT;\n\tif (!namelen) {\t\t\t/* special case: '/usr/' etc */\n\t\tif (!(flag & (O_ACCMODE|O_CREAT|O_TRUNC))) {\n\t\t\t*res_inode=dir;\n\t\t\treturn 0;\n\t\t}\n\t\tiput(dir);\n\t\treturn -EISDIR;\n\t}\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tif (!(flag & O_CREAT)) {\n\t\t\tiput(dir);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (!permission(dir,MAY_WRITE)) {\n\t\t\tiput(dir);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tinode = new_inode(dir->i_dev);\n\t\tif (!inode) {\n\t\t\tiput(dir);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tinode->i_uid = current->euid;\n\t\tinode->i_mode = mode;\n\t\tinode->i_dirt = 1;\n\t\tbh = add_entry(dir,basename,namelen,&de);\n\t\tif (!bh) {\n\t\t\tinode->i_nlinks--;\n\t\t\tiput(inode);\n\t\t\tiput(dir);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tde->inode = inode->i_num;\n\t\tbh->b_dirt = 1;\n\t\tbrelse(bh);\n\t\tiput(dir);\n\t\t*res_inode = inode;\n\t\treturn 0;\n\t}\n\tinr = de->inode;\n\tdev = dir->i_dev;\n\tbrelse(bh);\n\tiput(dir);\n\tif (flag & O_EXCL)\n\t\treturn -EEXIST;\n\tif (!(inode=iget(dev,inr)))\n\t\treturn -EACCES;\n\tif ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||\n\t    !permission(inode,ACC_MODE(flag))) {\n\t\tiput(inode);\n\t\treturn -EPERM;\n\t}\n\tinode->i_atime = CURRENT_TIME;\n\tif (flag & O_TRUNC)\n\t\ttruncate(inode);\n\t*res_inode = inode;\n\treturn 0;\n}\n\nint sys_mknod(const char * filename, int mode, int dev)\n{\n\tconst char * basename;\n\tint namelen;\n\tstruct m_inode * dir, * inode;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\t\n\tif (!suser())\n\t\treturn -EPERM;\n\tif (!(dir = dir_namei(filename,&namelen,&basename)))\n\t\treturn -ENOENT;\n\tif (!namelen) {\n\t\tiput(dir);\n\t\treturn -ENOENT;\n\t}\n\tif (!permission(dir,MAY_WRITE)) {\n\t\tiput(dir);\n\t\treturn -EPERM;\n\t}\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (bh) {\n\t\tbrelse(bh);\n\t\tiput(dir);\n\t\treturn -EEXIST;\n\t}\n\tinode = new_inode(dir->i_dev);\n\tif (!inode) {\n\t\tiput(dir);\n\t\treturn -ENOSPC;\n\t}\n\tinode->i_mode = mode;\n\tif (S_ISBLK(mode) || S_ISCHR(mode))\n\t\tinode->i_zone[0] = dev;\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tinode->i_dirt = 1;\n\tbh = add_entry(dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tiput(dir);\n\t\tinode->i_nlinks=0;\n\t\tiput(inode);\n\t\treturn -ENOSPC;\n\t}\n\tde->inode = inode->i_num;\n\tbh->b_dirt = 1;\n\tiput(dir);\n\tiput(inode);\n\tbrelse(bh);\n\treturn 0;\n}\n\nint sys_mkdir(const char * pathname, int mode)\n{\n\tconst char * basename;\n\tint namelen;\n\tstruct m_inode * dir, * inode;\n\tstruct buffer_head * bh, *dir_block;\n\tstruct dir_entry * de;\n\n\tif (!suser())\n\t\treturn -EPERM;\n\tif (!(dir = dir_namei(pathname,&namelen,&basename)))\n\t\treturn -ENOENT;\n\tif (!namelen) {\n\t\tiput(dir);\n\t\treturn -ENOENT;\n\t}\n\tif (!permission(dir,MAY_WRITE)) {\n\t\tiput(dir);\n\t\treturn -EPERM;\n\t}\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (bh) {\n\t\tbrelse(bh);\n\t\tiput(dir);\n\t\treturn -EEXIST;\n\t}\n\tinode = new_inode(dir->i_dev);\n\tif (!inode) {\n\t\tiput(dir);\n\t\treturn -ENOSPC;\n\t}\n\tinode->i_size = 32;\n\tinode->i_dirt = 1;\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tif (!(inode->i_zone[0]=new_block(inode->i_dev))) {\n\t\tiput(dir);\n\t\tinode->i_nlinks--;\n\t\tiput(inode);\n\t\treturn -ENOSPC;\n\t}\n\tinode->i_dirt = 1;\n\tif (!(dir_block=bread(inode->i_dev,inode->i_zone[0]))) {\n\t\tiput(dir);\n\t\tfree_block(inode->i_dev,inode->i_zone[0]);\n\t\tinode->i_nlinks--;\n\t\tiput(inode);\n\t\treturn -ERROR;\n\t}\n\tde = (struct dir_entry *) dir_block->b_data;\n\tde->inode=inode->i_num;\n\tstrcpy(de->name,\".\");\n\tde++;\n\tde->inode = dir->i_num;\n\tstrcpy(de->name,\"..\");\n\tinode->i_nlinks = 2;\n\tdir_block->b_dirt = 1;\n\tbrelse(dir_block);\n\tinode->i_mode = I_DIRECTORY | (mode & 0777 & ~current->umask);\n\tinode->i_dirt = 1;\n\tbh = add_entry(dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tiput(dir);\n\t\tfree_block(inode->i_dev,inode->i_zone[0]);\n\t\tinode->i_nlinks=0;\n\t\tiput(inode);\n\t\treturn -ENOSPC;\n\t}\n\tde->inode = inode->i_num;\n\tbh->b_dirt = 1;\n\tdir->i_nlinks++;\n\tdir->i_dirt = 1;\n\tiput(dir);\n\tiput(inode);\n\tbrelse(bh);\n\treturn 0;\n}\n\n/*\n * routine to check that the specified directory is empty (for rmdir)\n */\nstatic int empty_dir(struct m_inode * inode)\n{\n\tint nr,block;\n\tint len;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tlen = inode->i_size / sizeof (struct dir_entry);\n\tif (len<2 || !inode->i_zone[0] ||\n\t    !(bh=bread(inode->i_dev,inode->i_zone[0]))) {\n\t    \tprintk(\"warning - bad directory on dev %04x\\n\",inode->i_dev);\n\t\treturn 0;\n\t}\n\tde = (struct dir_entry *) bh->b_data;\n\tif (de[0].inode != inode->i_num || !de[1].inode || \n\t    strcmp(\".\",de[0].name) || strcmp(\"..\",de[1].name)) {\n\t    \tprintk(\"warning - bad directory on dev %04x\\n\",inode->i_dev);\n\t\treturn 0;\n\t}\n\tnr = 2;\n\tde += 2;\n\twhile (nr<len) {\n\t\tif ((void *) de >= (void *) (bh->b_data+BLOCK_SIZE)) {\n\t\t\tbrelse(bh);\n\t\t\tblock=bmap(inode,nr/DIR_ENTRIES_PER_BLOCK);\n\t\t\tif (!block) {\n\t\t\t\tnr += DIR_ENTRIES_PER_BLOCK;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(bh=bread(inode->i_dev,block)))\n\t\t\t\treturn 0;\n\t\t\tde = (struct dir_entry *) bh->b_data;\n\t\t}\n\t\tif (de->inode) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\tde++;\n\t\tnr++;\n\t}\n\tbrelse(bh);\n\treturn 1;\n}\n\nint sys_rmdir(const char * name)\n{\n\tconst char * basename;\n\tint namelen;\n\tstruct m_inode * dir, * inode;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif (!suser())\n\t\treturn -EPERM;\n\tif (!(dir = dir_namei(name,&namelen,&basename)))\n\t\treturn -ENOENT;\n\tif (!namelen) {\n\t\tiput(dir);\n\t\treturn -ENOENT;\n\t}\n\tif (!permission(dir,MAY_WRITE)) {\n\t\tiput(dir);\n\t\treturn -EPERM;\n\t}\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tiput(dir);\n\t\treturn -ENOENT;\n\t}\n\tif (!(inode = iget(dir->i_dev, de->inode))) {\n\t\tiput(dir);\n\t\tbrelse(bh);\n\t\treturn -EPERM;\n\t}\n\tif ((dir->i_mode & S_ISVTX) && current->euid &&\n\t    inode->i_uid != current->euid) {\n\t\tiput(dir);\n\t\tiput(inode);\n\t\tbrelse(bh);\n\t\treturn -EPERM;\n\t}\n\tif (inode->i_dev != dir->i_dev || inode->i_count>1) {\n\t\tiput(dir);\n\t\tiput(inode);\n\t\tbrelse(bh);\n\t\treturn -EPERM;\n\t}\n\tif (inode == dir) {\t/* we may not delete \".\", but \"../dir\" is ok */\n\t\tiput(inode);\n\t\tiput(dir);\n\t\tbrelse(bh);\n\t\treturn -EPERM;\n\t}\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tiput(inode);\n\t\tiput(dir);\n\t\tbrelse(bh);\n\t\treturn -ENOTDIR;\n\t}\n\tif (!empty_dir(inode)) {\n\t\tiput(inode);\n\t\tiput(dir);\n\t\tbrelse(bh);\n\t\treturn -ENOTEMPTY;\n\t}\n\tif (inode->i_nlinks != 2)\n\t\tprintk(\"empty directory has nlink!=2 (%d)\",inode->i_nlinks);\n\tde->inode = 0;\n\tbh->b_dirt = 1;\n\tbrelse(bh);\n\tinode->i_nlinks=0;\n\tinode->i_dirt=1;\n\tdir->i_nlinks--;\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tdir->i_dirt=1;\n\tiput(dir);\n\tiput(inode);\n\treturn 0;\n}\n\nint sys_unlink(const char * name)\n{\n\tconst char * basename;\n\tint namelen;\n\tstruct m_inode * dir, * inode;\n\tstruct buffer_head * bh;\n\tstruct dir_entry * de;\n\n\tif (!(dir = dir_namei(name,&namelen,&basename)))\n\t\treturn -ENOENT;\n\tif (!namelen) {\n\t\tiput(dir);\n\t\treturn -ENOENT;\n\t}\n\tif (!permission(dir,MAY_WRITE)) {\n\t\tiput(dir);\n\t\treturn -EPERM;\n\t}\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tiput(dir);\n\t\treturn -ENOENT;\n\t}\n\tif (!(inode = iget(dir->i_dev, de->inode))) {\n\t\tiput(dir);\n\t\tbrelse(bh);\n\t\treturn -ENOENT;\n\t}\n\tif ((dir->i_mode & S_ISVTX) && !suser() &&\n\t    current->euid != inode->i_uid &&\n\t    current->euid != dir->i_uid) {\n\t\tiput(dir);\n\t\tiput(inode);\n\t\tbrelse(bh);\n\t\treturn -EPERM;\n\t}\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tiput(inode);\n\t\tiput(dir);\n\t\tbrelse(bh);\n\t\treturn -EPERM;\n\t}\n\tif (!inode->i_nlinks) {\n\t\tprintk(\"Deleting nonexistent file (%04x:%d), %d\\n\",\n\t\t\tinode->i_dev,inode->i_num,inode->i_nlinks);\n\t\tinode->i_nlinks=1;\n\t}\n\tde->inode = 0;\n\tbh->b_dirt = 1;\n\tbrelse(bh);\n\tinode->i_nlinks--;\n\tinode->i_dirt = 1;\n\tinode->i_ctime = CURRENT_TIME;\n\tiput(inode);\n\tiput(dir);\n\treturn 0;\n}\n\nint sys_link(const char * oldname, const char * newname)\n{\n\tstruct dir_entry * de;\n\tstruct m_inode * oldinode, * dir;\n\tstruct buffer_head * bh;\n\tconst char * basename;\n\tint namelen;\n\n\toldinode=namei(oldname);\n\tif (!oldinode)\n\t\treturn -ENOENT;\n\tif (S_ISDIR(oldinode->i_mode)) {\n\t\tiput(oldinode);\n\t\treturn -EPERM;\n\t}\n\tdir = dir_namei(newname,&namelen,&basename);\n\tif (!dir) {\n\t\tiput(oldinode);\n\t\treturn -EACCES;\n\t}\n\tif (!namelen) {\n\t\tiput(oldinode);\n\t\tiput(dir);\n\t\treturn -EPERM;\n\t}\n\tif (dir->i_dev != oldinode->i_dev) {\n\t\tiput(dir);\n\t\tiput(oldinode);\n\t\treturn -EXDEV;\n\t}\n\tif (!permission(dir,MAY_WRITE)) {\n\t\tiput(dir);\n\t\tiput(oldinode);\n\t\treturn -EACCES;\n\t}\n\tbh = find_entry(&dir,basename,namelen,&de);\n\tif (bh) {\n\t\tbrelse(bh);\n\t\tiput(dir);\n\t\tiput(oldinode);\n\t\treturn -EEXIST;\n\t}\n\tbh = add_entry(dir,basename,namelen,&de);\n\tif (!bh) {\n\t\tiput(dir);\n\t\tiput(oldinode);\n\t\treturn -ENOSPC;\n\t}\n\tde->inode = oldinode->i_num;\n\tbh->b_dirt = 1;\n\tbrelse(bh);\n\tiput(dir);\n\toldinode->i_nlinks++;\n\toldinode->i_ctime = CURRENT_TIME;\n\toldinode->i_dirt = 1;\n\tiput(oldinode);\n\treturn 0;\n}",
        "/*\n *  linux/fs/block_dev.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <errno.h>\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/segment.h>\n#include <asm/system.h>\n\nint block_write(int dev, long * pos, char * buf, int count)\n{\n\tint block = *pos >> BLOCK_SIZE_BITS;\n\tint offset = *pos & (BLOCK_SIZE-1);\n\tint chars;\n\tint written = 0;\n\tstruct buffer_head * bh;\n\tregister char * p;\n\n\twhile (count>0) {\n\t\tchars = BLOCK_SIZE - offset;\n\t\tif (chars > count)\n\t\t\tchars=count;\n\t\tif (chars == BLOCK_SIZE)\n\t\t\tbh = getblk(dev,block);\n\t\telse\n\t\t\tbh = breada(dev,block,block+1,block+2,-1);\n\t\tblock++;\n\t\tif (!bh)\n\t\t\treturn written?written:-EIO;\n\t\tp = offset + bh->b_data;\n\t\toffset = 0;\n\t\t*pos += chars;\n\t\twritten += chars;\n\t\tcount -= chars;\n\t\twhile (chars-->0)\n\t\t\t*(p++) = get_fs_byte(buf++);\n\t\tbh->b_dirt = 1;\n\t\tbrelse(bh);\n\t}\n\treturn written;\n}\n\nint block_read(int dev, unsigned long * pos, char * buf, int count)\n{\n\tint block = *pos >> BLOCK_SIZE_BITS;\n\tint offset = *pos & (BLOCK_SIZE-1);\n\tint chars;\n\tint read = 0;\n\tstruct buffer_head * bh;\n\tregister char * p;\n\n\twhile (count>0) {\n\t\tchars = BLOCK_SIZE-offset;\n\t\tif (chars > count)\n\t\t\tchars = count;\n\t\tif (!(bh = breada(dev,block,block+1,block+2,-1)))\n\t\t\treturn read?read:-EIO;\n\t\tblock++;\n\t\tp = offset + bh->b_data;\n\t\toffset = 0;\n\t\t*pos += chars;\n\t\tread += chars;\n\t\tcount -= chars;\n\t\twhile (chars-->0)\n\t\t\tput_fs_byte(*(p++),buf++);\n\t\tbrelse(bh);\n\t}\n\treturn read;\n}",
        "/*\n *  linux/fs/read_write.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <sys/stat.h>\n#include <errno.h>\n#include <sys/types.h>\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <asm/segment.h>\n\nextern int rw_char(int rw,int dev, char * buf, int count, off_t * pos);\nextern int read_pipe(struct m_inode * inode, char * buf, int count);\nextern int write_pipe(struct m_inode * inode, char * buf, int count);\nextern int block_read(int dev, off_t * pos, char * buf, int count);\nextern int block_write(int dev, off_t * pos, char * buf, int count);\nextern int file_read(struct m_inode * inode, struct file * filp,\n\t\tchar * buf, int count);\nextern int file_write(struct m_inode * inode, struct file * filp,\n\t\tchar * buf, int count);\n\nint sys_lseek(unsigned int fd,off_t offset, int origin)\n{\n\tstruct file * file;\n\tint tmp;\n\n\tif (fd >= NR_OPEN || !(file=current->filp[fd]) || !(file->f_inode)\n\t   || !IS_SEEKABLE(MAJOR(file->f_inode->i_dev)))\n\t\treturn -EBADF;\n\tif (file->f_inode->i_pipe)\n\t\treturn -ESPIPE;\n\tswitch (origin) {\n\t\tcase 0:\n\t\t\tif (offset<0) return -EINVAL;\n\t\t\tfile->f_pos=offset;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (file->f_pos+offset<0) return -EINVAL;\n\t\t\tfile->f_pos += offset;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif ((tmp=file->f_inode->i_size+offset) < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tfile->f_pos = tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\treturn file->f_pos;\n}\n\nint sys_read(unsigned int fd,char * buf,int count)\n{\n\tstruct file * file;\n\tstruct m_inode * inode;\n\n\tif (fd>=NR_OPEN || count<0 || !(file=current->filp[fd]))\n\t\treturn -EINVAL;\n\tif (!count)\n\t\treturn 0;\n\tverify_area(buf,count);\n\tinode = file->f_inode;\n\tif (inode->i_pipe)\n\t\treturn (file->f_mode&1)?read_pipe(inode,buf,count):-EIO;\n\tif (S_ISCHR(inode->i_mode))\n\t\treturn rw_char(READ,inode->i_zone[0],buf,count,&file->f_pos);\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn block_read(inode->i_zone[0],&file->f_pos,buf,count);\n\tif (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {\n\t\tif (count+file->f_pos > inode->i_size)\n\t\t\tcount = inode->i_size - file->f_pos;\n\t\tif (count<=0)\n\t\t\treturn 0;\n\t\treturn file_read(inode,file,buf,count);\n\t}\n\tprintk(\"(Read)inode->i_mode=%06o\\n\\r\",inode->i_mode);\n\treturn -EINVAL;\n}\n\nint sys_write(unsigned int fd,char * buf,int count)\n{\n\tstruct file * file;\n\tstruct m_inode * inode;\n\t\n\tif (fd>=NR_OPEN || count <0 || !(file=current->filp[fd]))\n\t\treturn -EINVAL;\n\tif (!count)\n\t\treturn 0;\n\tinode=file->f_inode;\n\tif (inode->i_pipe)\n\t\treturn (file->f_mode&2)?write_pipe(inode,buf,count):-EIO;\n\tif (S_ISCHR(inode->i_mode))\n\t\treturn rw_char(WRITE,inode->i_zone[0],buf,count,&file->f_pos);\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn block_write(inode->i_zone[0],&file->f_pos,buf,count);\n\tif (S_ISREG(inode->i_mode))\n\t\treturn file_write(inode,file,buf,count);\n\tprintk(\"(Write)inode->i_mode=%06o\\n\\r\",inode->i_mode);\n\treturn -EINVAL;\n}",
        "/*\n *  linux/fs/stat.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <errno.h>\n#include <sys/stat.h>\n\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/segment.h>\n\nstatic void cp_stat(struct m_inode * inode, struct stat * statbuf)\n{\n\tstruct stat tmp;\n\tint i;\n\n\tverify_area(statbuf,sizeof (* statbuf));\n\ttmp.st_dev = inode->i_dev;\n\ttmp.st_ino = inode->i_num;\n\ttmp.st_mode = inode->i_mode;\n\ttmp.st_nlink = inode->i_nlinks;\n\ttmp.st_uid = inode->i_uid;\n\ttmp.st_gid = inode->i_gid;\n\ttmp.st_rdev = inode->i_zone[0];\n\ttmp.st_size = inode->i_size;\n\ttmp.st_atime = inode->i_atime;\n\ttmp.st_mtime = inode->i_mtime;\n\ttmp.st_ctime = inode->i_ctime;\n\tfor (i=0 ; i<sizeof (tmp) ; i++)\n\t\tput_fs_byte(((char *) &tmp)[i],&((char *) statbuf)[i]);\n}\n\nint sys_stat(char * filename, struct stat * statbuf)\n{\n\tstruct m_inode * inode;\n\n\tif (!(inode=namei(filename)))\n\t\treturn -ENOENT;\n\tcp_stat(inode,statbuf);\n\tiput(inode);\n\treturn 0;\n}\n\nint sys_fstat(unsigned int fd, struct stat * statbuf)\n{\n\tstruct file * f;\n\tstruct m_inode * inode;\n\n\tif (fd >= NR_OPEN || !(f=current->filp[fd]) || !(inode=f->f_inode))\n\t\treturn -EBADF;\n\tcp_stat(inode,statbuf);\n\treturn 0;\n}",
        "/*\n *  linux/fs/fcntl.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/* #include <string.h> */\n#include <errno.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/segment.h>\n\n#include <fcntl.h>\n#include <sys/stat.h>\n\nextern int sys_close(int fd);\n\nstatic int dupfd(unsigned int fd, unsigned int arg)\n{\n\tif (fd >= NR_OPEN || !current->filp[fd])\n\t\treturn -EBADF;\n\tif (arg >= NR_OPEN)\n\t\treturn -EINVAL;\n\twhile (arg < NR_OPEN)\n\t\tif (current->filp[arg])\n\t\t\targ++;\n\t\telse\n\t\t\tbreak;\n\tif (arg >= NR_OPEN)\n\t\treturn -EMFILE;\n\tcurrent->close_on_exec &= ~(1<<arg);\n\t(current->filp[arg] = current->filp[fd])->f_count++;\n\treturn arg;\n}\n\nint sys_dup2(unsigned int oldfd, unsigned int newfd)\n{\n\tsys_close(newfd);\n\treturn dupfd(oldfd,newfd);\n}\n\nint sys_dup(unsigned int fildes)\n{\n\treturn dupfd(fildes,0);\n}\n\nint sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg)\n{\t\n\tstruct file * filp;\n\n\tif (fd >= NR_OPEN || !(filp = current->filp[fd]))\n\t\treturn -EBADF;\n\tswitch (cmd) {\n\t\tcase F_DUPFD:\n\t\t\treturn dupfd(fd,arg);\n\t\tcase F_GETFD:\n\t\t\treturn (current->close_on_exec>>fd)&1;\n\t\tcase F_SETFD:\n\t\t\tif (arg&1)\n\t\t\t\tcurrent->close_on_exec |= (1<<fd);\n\t\t\telse\n\t\t\t\tcurrent->close_on_exec &= ~(1<<fd);\n\t\t\treturn 0;\n\t\tcase F_GETFL:\n\t\t\treturn filp->f_flags;\n\t\tcase F_SETFL:\n\t\t\tfilp->f_flags &= ~(O_APPEND | O_NONBLOCK);\n\t\t\tfilp->f_flags |= arg & (O_APPEND | O_NONBLOCK);\n\t\t\treturn 0;\n\t\tcase F_GETLK:\tcase F_SETLK:\tcase F_SETLKW:\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n}",
        "/*\n *  linux/fs/open.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/* #include <string.h> */\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <utime.h>\n#include <sys/stat.h>\n\n#include <linux/sched.h>\n#include <linux/tty.h>\n#include <linux/kernel.h>\n#include <asm/segment.h>\n\nint sys_ustat(int dev, struct ustat * ubuf)\n{\n\treturn -ENOSYS;\n}\n\nint sys_utime(char * filename, struct utimbuf * times)\n{\n\tstruct m_inode * inode;\n\tlong actime,modtime;\n\n\tif (!(inode=namei(filename)))\n\t\treturn -ENOENT;\n\tif (times) {\n\t\tactime = get_fs_long((unsigned long *) &times->actime);\n\t\tmodtime = get_fs_long((unsigned long *) &times->modtime);\n\t} else\n\t\tactime = modtime = CURRENT_TIME;\n\tinode->i_atime = actime;\n\tinode->i_mtime = modtime;\n\tinode->i_dirt = 1;\n\tiput(inode);\n\treturn 0;\n}\n\n/*\n * XXX should we use the real or effective uid?  BSD uses the real uid,\n * so as to make this call useful to setuid programs.\n */\nint sys_access(const char * filename,int mode)\n{\n\tstruct m_inode * inode;\n\tint res, i_mode;\n\n\tmode &= 0007;\n\tif (!(inode=namei(filename)))\n\t\treturn -EACCES;\n\ti_mode = res = inode->i_mode & 0777;\n\tiput(inode);\n\tif (current->uid == inode->i_uid)\n\t\tres >>= 6;\n\telse if (current->gid == inode->i_gid)\n\t\tres >>= 6;\n\tif ((res & 0007 & mode) == mode)\n\t\treturn 0;\n\t/*\n\t * XXX we are doing this test last because we really should be\n\t * swapping the effective with the real user id (temporarily),\n\t * and then calling suser() routine.  If we do call the\n\t * suser() routine, it needs to be called last. \n\t */\n\tif ((!current->uid) &&\n\t    (!(mode & 1) || (i_mode & 0111)))\n\t\treturn 0;\n\treturn -EACCES;\n}\n\nint sys_chdir(const char * filename)\n{\n\tstruct m_inode * inode;\n\n\tif (!(inode = namei(filename)))\n\t\treturn -ENOENT;\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tiput(inode);\n\t\treturn -ENOTDIR;\n\t}\n\tiput(current->pwd);\n\tcurrent->pwd = inode;\n\treturn (0);\n}\n\nint sys_chroot(const char * filename)\n{\n\tstruct m_inode * inode;\n\n\tif (!(inode=namei(filename)))\n\t\treturn -ENOENT;\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tiput(inode);\n\t\treturn -ENOTDIR;\n\t}\n\tiput(current->root);\n\tcurrent->root = inode;\n\treturn (0);\n}\n\nint sys_chmod(const char * filename,int mode)\n{\n\tstruct m_inode * inode;\n\n\tif (!(inode=namei(filename)))\n\t\treturn -ENOENT;\n\tif ((current->euid != inode->i_uid) && !suser()) {\n\t\tiput(inode);\n\t\treturn -EACCES;\n\t}\n\tinode->i_mode = (mode & 07777) | (inode->i_mode & ~07777);\n\tinode->i_dirt = 1;\n\tiput(inode);\n\treturn 0;\n}\n\nint sys_chown(const char * filename,int uid,int gid)\n{\n\tstruct m_inode * inode;\n\n\tif (!(inode=namei(filename)))\n\t\treturn -ENOENT;\n\tif (!suser()) {\n\t\tiput(inode);\n\t\treturn -EACCES;\n\t}\n\tinode->i_uid=uid;\n\tinode->i_gid=gid;\n\tinode->i_dirt=1;\n\tiput(inode);\n\treturn 0;\n}\n\nint sys_open(const char * filename,int flag,int mode)\n{\n\tstruct m_inode * inode;\n\tstruct file * f;\n\tint i,fd;\n\n\tmode &= 0777 & ~current->umask;\n\tfor(fd=0 ; fd<NR_OPEN ; fd++)\n\t\tif (!current->filp[fd])\n\t\t\tbreak;\n\tif (fd>=NR_OPEN)\n\t\treturn -EINVAL;\n\tcurrent->close_on_exec &= ~(1<<fd);\n\tf=0+file_table;\n\tfor (i=0 ; i<NR_FILE ; i++,f++)\n\t\tif (!f->f_count) break;\n\tif (i>=NR_FILE)\n\t\treturn -EINVAL;\n\t(current->filp[fd]=f)->f_count++;\n\tif ((i=open_namei(filename,flag,mode,&inode))<0) {\n\t\tcurrent->filp[fd]=NULL;\n\t\tf->f_count=0;\n\t\treturn i;\n\t}\n/* ttys are somewhat special (ttyxx major==4, tty major==5) */\n\tif (S_ISCHR(inode->i_mode)) {\n\t\tif (MAJOR(inode->i_zone[0])==4) {\n\t\t\tif (current->leader && current->tty<0) {\n\t\t\t\tcurrent->tty = MINOR(inode->i_zone[0]);\n\t\t\t\ttty_table[current->tty].pgrp = current->pgrp;\n\t\t\t}\n\t\t} else if (MAJOR(inode->i_zone[0])==5)\n\t\t\tif (current->tty<0) {\n\t\t\t\tiput(inode);\n\t\t\t\tcurrent->filp[fd]=NULL;\n\t\t\t\tf->f_count=0;\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t}\n/* Likewise with block-devices: check for floppy_change */\n\tif (S_ISBLK(inode->i_mode))\n\t\tcheck_disk_change(inode->i_zone[0]);\n\tf->f_mode = inode->i_mode;\n\tf->f_flags = flag;\n\tf->f_count = 1;\n\tf->f_inode = inode;\n\tf->f_pos = 0;\n\treturn (fd);\n}\n\nint sys_creat(const char * pathname, int mode)\n{\n\treturn sys_open(pathname, O_CREAT | O_TRUNC, mode);\n}\n\nint sys_close(unsigned int fd)\n{\t\n\tstruct file * filp;\n\n\tif (fd >= NR_OPEN)\n\t\treturn -EINVAL;\n\tcurrent->close_on_exec &= ~(1<<fd);\n\tif (!(filp = current->filp[fd]))\n\t\treturn -EINVAL;\n\tcurrent->filp[fd] = NULL;\n\tif (filp->f_count == 0)\n\t\tpanic(\"Close: file count is 0\");\n\tif (--filp->f_count)\n\t\treturn (0);\n\tiput(filp->f_inode);\n\treturn (0);\n}",
        "/*\n *  linux/fs/char_dev.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <errno.h>\n#include <sys/types.h>\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#include <asm/segment.h>\n#include <asm/io.h>\n\nextern int tty_read(unsigned minor,char * buf,int count);\nextern int tty_write(unsigned minor,char * buf,int count);\n\ntypedef int (*crw_ptr)(int rw,unsigned minor,char * buf,int count,off_t * pos);\n\nstatic int rw_ttyx(int rw,unsigned minor,char * buf,int count,off_t * pos)\n{\n\treturn ((rw==READ)?tty_read(minor,buf,count):\n\t\ttty_write(minor,buf,count));\n}\n\nstatic int rw_tty(int rw,unsigned minor,char * buf,int count, off_t * pos)\n{\n\tif (current->tty<0)\n\t\treturn -EPERM;\n\treturn rw_ttyx(rw,current->tty,buf,count,pos);\n}\n\nstatic int rw_ram(int rw,char * buf, int count, off_t *pos)\n{\n\treturn -EIO;\n}\n\nstatic int rw_mem(int rw,char * buf, int count, off_t * pos)\n{\n\treturn -EIO;\n}\n\nstatic int rw_kmem(int rw,char * buf, int count, off_t * pos)\n{\n\treturn -EIO;\n}\n\nstatic int rw_port(int rw,char * buf, int count, off_t * pos)\n{\n\tint i=*pos;\n\n\twhile (count-->0 && i<65536) {\n\t\tif (rw==READ)\n\t\t\tput_fs_byte(inb(i),buf++);\n\t\telse\n\t\t\toutb(get_fs_byte(buf++),i);\n\t\ti++;\n\t}\n\ti -= *pos;\n\t*pos += i;\n\treturn i;\n}\n\nstatic int rw_memory(int rw, unsigned minor, char * buf, int count, off_t * pos)\n{\n\tswitch(minor) {\n\t\tcase 0:\n\t\t\treturn rw_ram(rw,buf,count,pos);\n\t\tcase 1:\n\t\t\treturn rw_mem(rw,buf,count,pos);\n\t\tcase 2:\n\t\t\treturn rw_kmem(rw,buf,count,pos);\n\t\tcase 3:\n\t\t\treturn (rw==READ)?0:count;\t/* rw_null */\n\t\tcase 4:\n\t\t\treturn rw_port(rw,buf,count,pos);\n\t\tdefault:\n\t\t\treturn -EIO;\n\t}\n}\n\n#define NRDEVS ((sizeof (crw_table))/(sizeof (crw_ptr)))\n\nstatic crw_ptr crw_table[]={\n\tNULL,\t\t/* nodev */\n\trw_memory,\t/* /dev/mem etc */\n\tNULL,\t\t/* /dev/fd */\n\tNULL,\t\t/* /dev/hd */\n\trw_ttyx,\t/* /dev/ttyx */\n\trw_tty,\t\t/* /dev/tty */\n\tNULL,\t\t/* /dev/lp */\n\tNULL};\t\t/* unnamed pipes */\n\nint rw_char(int rw,int dev, char * buf, int count, off_t * pos)\n{\n\tcrw_ptr call_addr;\n\n\tif (MAJOR(dev)>=NRDEVS)\n\t\treturn -ENODEV;\n\tif (!(call_addr=crw_table[MAJOR(dev)]))\n\t\treturn -ENODEV;\n\treturn call_addr(rw,MINOR(dev),buf,count,pos);\n}",
        "/*\n *  linux/kernel/sched.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * 'sched.c' is the main kernel file. It contains scheduling primitives\n * (sleep_on, wakeup, schedule etc) as well as a number of simple system\n * call functions (type getpid(), which just extracts a field from\n * current-task\n */\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/sys.h>\n#include <linux/fdreg.h>\n#include <asm/system.h>\n#include <asm/io.h>\n#include <asm/segment.h>\n\n#include <signal.h>\n\n#define _S(nr) (1<<((nr)-1))\n#define _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))\n\nvoid show_task(int nr,struct task_struct * p)\n{\n\tint i,j = 4096-sizeof(struct task_struct);\n\n\tprintk(\"%d: pid=%d, state=%d, \",nr,p->pid,p->state);\n\ti=0;\n\twhile (i<j && !((char *)(p+1))[i])\n\t\ti++;\n\tprintk(\"%d (of %d) chars free in kernel stack\\n\\r\",i,j);\n}\n\nvoid show_stat(void)\n{\n\tint i;\n\n\tfor (i=0;i<NR_TASKS;i++)\n\t\tif (task[i])\n\t\t\tshow_task(i,task[i]);\n}\n\n#define LATCH (1193180/HZ)\n\nextern void mem_use(void);\n\nextern int timer_interrupt(void);\nextern int system_call(void);\n\nunion task_union {\n\tstruct task_struct task;\n\tchar stack[PAGE_SIZE];\n};\n\nstatic union task_union init_task = {INIT_TASK,};\n\nlong volatile jiffies=0;\nlong startup_time=0;\nstruct task_struct *current = &(init_task.task);\nstruct task_struct *last_task_used_math = NULL;\n\nstruct task_struct * task[NR_TASKS] = {&(init_task.task), };\n\nlong user_stack [ PAGE_SIZE>>2 ] ;\n\nstruct {\n\tlong * a;\n\tshort b;\n\t} stack_start = { & user_stack [PAGE_SIZE>>2] , 0x10 };\n/*\n *  'math_state_restore()' saves the current math information in the\n * old math state array, and gets the new ones from the current task\n */\nvoid math_state_restore()\n{\n\tif (last_task_used_math == current)\n\t\treturn;\n\t__asm__(\"fwait\");\n\tif (last_task_used_math) {\n\t\t__asm__(\"fnsave %0\"::\"m\" (last_task_used_math->tss.i387));\n\t}\n\tlast_task_used_math=current;\n\tif (current->used_math) {\n\t\t__asm__(\"frstor %0\"::\"m\" (current->tss.i387));\n\t} else {\n\t\t__asm__(\"fninit\"::);\n\t\tcurrent->used_math=1;\n\t}\n}\n\n/*\n *  'schedule()' is the scheduler function. This is GOOD CODE! There\n * probably won't be any reason to change this, as it should work well\n * in all circumstances (ie gives IO-bound processes good response etc).\n * The one thing you might take a look at is the signal-handler code here.\n *\n *   NOTE!!  Task 0 is the 'idle' task, which gets called when no other\n * tasks can run. It can not be killed, and it cannot sleep. The 'state'\n * information in task[0] is never used.\n */\nvoid schedule(void)\n{\n\tint i,next,c;\n\tstruct task_struct ** p;\n\n/* check alarm, wake up any interruptible tasks that have got a signal */\n\n\tfor(p = &LAST_TASK ; p > &FIRST_TASK ; --p)\n\t\tif (*p) {\n\t\t\tif ((*p)->alarm && (*p)->alarm < jiffies) {\n\t\t\t\t\t(*p)->signal |= (1<<(SIGALRM-1));\n\t\t\t\t\t(*p)->alarm = 0;\n\t\t\t\t}\n\t\t\tif (((*p)->signal & (_BLOCKABLE & ~(*p)->blocked)) &&\n\t\t\t(*p)->state==TASK_INTERRUPTIBLE)\n\t\t\t\t(*p)->state=TASK_RUNNING;\n\t\t}\n\n/* this is the scheduler proper: */\n\n\twhile (1) {\n\t\tc = -1;\n\t\tnext = 0;\n\t\ti = NR_TASKS;\n\t\tp = &task[NR_TASKS];\n\t\twhile (--i) {\n\t\t\tif (!*--p)\n\t\t\t\tcontinue;\n\t\t\tif ((*p)->state == TASK_RUNNING && (*p)->counter > c)\n\t\t\t\tc = (*p)->counter, next = i;\n\t\t}\n\t\tif (c) break;\n\t\tfor(p = &LAST_TASK ; p > &FIRST_TASK ; --p)\n\t\t\tif (*p)\n\t\t\t\t(*p)->counter = ((*p)->counter >> 1) +\n\t\t\t\t\t\t(*p)->priority;\n\t}\n\tswitch_to(next);\n}\n\nint sys_pause(void)\n{\n\tcurrent->state = TASK_INTERRUPTIBLE;\n\tschedule();\n\treturn 0;\n}\n\nvoid sleep_on(struct task_struct **p)\n{\n\tstruct task_struct *tmp;\n\n\tif (!p)\n\t\treturn;\n\tif (current == &(init_task.task))\n\t\tpanic(\"task[0] trying to sleep\");\n\ttmp = *p;\n\t*p = current;\n\tcurrent->state = TASK_UNINTERRUPTIBLE;\n\tschedule();\n\t*p = tmp;\n\tif (tmp)\n\t\ttmp->state=TASK_RUNNING;\n}\n\nvoid interruptible_sleep_on(struct task_struct **p)\n{\n\tstruct task_struct *tmp;\n\n\tif (!p)\n\t\treturn;\n\tif (current == &(init_task.task))\n\t\tpanic(\"task[0] trying to sleep\");\n\ttmp=*p;\n\t*p=current;\nrepeat:\tcurrent->state = TASK_INTERRUPTIBLE;\n\tschedule();\n\tif (*p && *p != current) {\n\t\t(*p)->state = TASK_RUNNING;\n\t\tgoto repeat;\n\t}\n\t*p = tmp;\n\tif (tmp)\n\t\ttmp->state = TASK_RUNNING;\n}\n\nvoid wake_up(struct task_struct **p)\n{\n\tif (p && *p) {\n\t\t(*p)->state = TASK_RUNNING;\n\t\t*p = NULL;\n\t}\n}\n\n/*\n * OK, here are some floppy things that shouldn't be in the kernel\n * proper. They are here because the floppy needs a timer, and this\n * was the easiest way of doing it.\n */\nstatic struct task_struct * wait_motor[4] = {NULL,NULL,NULL,NULL};\nstatic int  mon_timer[4]={0,0,0,0};\nstatic int moff_timer[4]={0,0,0,0};\nunsigned char current_DOR = 0x0C;\n\nint ticks_to_floppy_on(unsigned int nr)\n{\n\textern unsigned char selected;\n\tunsigned char mask = 0x10 << nr;\n\n\tif (nr>3)\n\t\tpanic(\"floppy_on: nr>3\");\n\tmoff_timer[nr]=10000;\t\t/* 100 s = very big :-) */\n\tcli();\t\t\t\t/* use floppy_off to turn it off */\n\tmask |= current_DOR;\n\tif (!selected) {\n\t\tmask &= 0xFC;\n\t\tmask |= nr;\n\t}\n\tif (mask != current_DOR) {\n\t\toutb(mask,FD_DOR);\n\t\tif ((mask ^ current_DOR) & 0xf0)\n\t\t\tmon_timer[nr] = HZ/2;\n\t\telse if (mon_timer[nr] < 2)\n\t\t\tmon_timer[nr] = 2;\n\t\tcurrent_DOR = mask;\n\t}\n\tsti();\n\treturn mon_timer[nr];\n}\n\nvoid floppy_on(unsigned int nr)\n{\n\tcli();\n\twhile (ticks_to_floppy_on(nr))\n\t\tsleep_on(nr+wait_motor);\n\tsti();\n}\n\nvoid floppy_off(unsigned int nr)\n{\n\tmoff_timer[nr]=3*HZ;\n}\n\nvoid do_floppy_timer(void)\n{\n\tint i;\n\tunsigned char mask = 0x10;\n\n\tfor (i=0 ; i<4 ; i++,mask <<= 1) {\n\t\tif (!(mask & current_DOR))\n\t\t\tcontinue;\n\t\tif (mon_timer[i]) {\n\t\t\tif (!--mon_timer[i])\n\t\t\t\twake_up(i+wait_motor);\n\t\t} else if (!moff_timer[i]) {\n\t\t\tcurrent_DOR &= ~mask;\n\t\t\toutb(current_DOR,FD_DOR);\n\t\t} else\n\t\t\tmoff_timer[i]--;\n\t}\n}\n\n#define TIME_REQUESTS 64\n\nstatic struct timer_list {\n\tlong jiffies;\n\tvoid (*fn)();\n\tstruct timer_list * next;\n} timer_list[TIME_REQUESTS], * next_timer = NULL;\n\nvoid add_timer(long jiffies, void (*fn)(void))\n{\n\tstruct timer_list * p;\n\n\tif (!fn)\n\t\treturn;\n\tcli();\n\tif (jiffies <= 0)\n\t\t(fn)();\n\telse {\n\t\tfor (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)\n\t\t\tif (!p->fn)\n\t\t\t\tbreak;\n\t\tif (p >= timer_list + TIME_REQUESTS)\n\t\t\tpanic(\"No more time requests free\");\n\t\tp->fn = fn;\n\t\tp->jiffies = jiffies;\n\t\tp->next = next_timer;\n\t\tnext_timer = p;\n\t\twhile (p->next && p->next->jiffies < p->jiffies) {\n\t\t\tp->jiffies -= p->next->jiffies;\n\t\t\tfn = p->fn;\n\t\t\tp->fn = p->next->fn;\n\t\t\tp->next->fn = fn;\n\t\t\tjiffies = p->jiffies;\n\t\t\tp->jiffies = p->next->jiffies;\n\t\t\tp->next->jiffies = jiffies;\n\t\t\tp = p->next;\n\t\t}\n\t}\n\tsti();\n}\n\nvoid do_timer(long cpl)\n{\n\textern int beepcount;\n\textern void sysbeepstop(void);\n\n\tif (beepcount)\n\t\tif (!--beepcount)\n\t\t\tsysbeepstop();\n\n\tif (cpl)\n\t\tcurrent->utime++;\n\telse\n\t\tcurrent->stime++;\n\n\tif (next_timer) {\n\t\tnext_timer->jiffies--;\n\t\twhile (next_timer && next_timer->jiffies <= 0) {\n\t\t\tvoid (*fn)(void);\n\t\t\t\n\t\t\tfn = next_timer->fn;\n\t\t\tnext_timer->fn = NULL;\n\t\t\tnext_timer = next_timer->next;\n\t\t\t(fn)();\n\t\t}\n\t}\n\tif (current_DOR & 0xf0)\n\t\tdo_floppy_timer();\n\tif ((--current->counter)>0) return;\n\tcurrent->counter=0;\n\tif (!cpl) return;\n\tschedule();\n}\n\nint sys_alarm(long seconds)\n{\n\tint old = current->alarm;\n\n\tif (old)\n\t\told = (old - jiffies) / HZ;\n\tcurrent->alarm = (seconds>0)?(jiffies+HZ*seconds):0;\n\treturn (old);\n}\n\nint sys_getpid(void)\n{\n\treturn current->pid;\n}\n\nint sys_getppid(void)\n{\n\treturn current->father;\n}\n\nint sys_getuid(void)\n{\n\treturn current->uid;\n}\n\nint sys_geteuid(void)\n{\n\treturn current->euid;\n}\n\nint sys_getgid(void)\n{\n\treturn current->gid;\n}\n\nint sys_getegid(void)\n{\n\treturn current->egid;\n}\n\nint sys_nice(long increment)\n{\n\tif (current->priority-increment>0)\n\t\tcurrent->priority -= increment;\n\treturn 0;\n}\n\nvoid sched_init(void)\n{\n\tint i;\n\tstruct desc_struct * p;\n\n\tif (sizeof(struct sigaction) != 16)\n\t\tpanic(\"Struct sigaction MUST be 16 bytes\");\n\tset_tss_desc(gdt+FIRST_TSS_ENTRY,&(init_task.task.tss));\n\tset_ldt_desc(gdt+FIRST_LDT_ENTRY,&(init_task.task.ldt));\n\tp = gdt+2+FIRST_TSS_ENTRY;\n\tfor(i=1;i<NR_TASKS;i++) {\n\t\ttask[i] = NULL;\n\t\tp->a=p->b=0;\n\t\tp++;\n\t\tp->a=p->b=0;\n\t\tp++;\n\t}\n/* Clear NT, so that we won't have troubles with that later on */\n\t__asm__(\"pushfl ; andl $0xffffbfff,(%esp) ; popfl\");\n\tltr(0);\n\tlldt(0);\n\toutb_p(0x36,0x43);\t\t/* binary, mode 3, LSB/MSB, ch 0 */\n\toutb_p(LATCH & 0xff , 0x40);\t/* LSB */\n\toutb(LATCH >> 8 , 0x40);\t/* MSB */\n\tset_intr_gate(0x20,&timer_interrupt);\n\toutb(inb_p(0x21)&~0x01,0x21);\n\tset_system_gate(0x80,&system_call);\n}",
        "/*\n *  linux/kernel/sys.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <errno.h>\n\n#include <linux/sched.h>\n#include <linux/tty.h>\n#include <linux/kernel.h>\n#include <asm/segment.h>\n#include <sys/times.h>\n#include <sys/utsname.h>\n\nint sys_ftime()\n{\n\treturn -ENOSYS;\n}\n\nint sys_break()\n{\n\treturn -ENOSYS;\n}\n\nint sys_ptrace()\n{\n\treturn -ENOSYS;\n}\n\nint sys_stty()\n{\n\treturn -ENOSYS;\n}\n\nint sys_gtty()\n{\n\treturn -ENOSYS;\n}\n\nint sys_rename()\n{\n\treturn -ENOSYS;\n}\n\nint sys_prof()\n{\n\treturn -ENOSYS;\n}\n\nint sys_setregid(int rgid, int egid)\n{\n\tif (rgid>0) {\n\t\tif ((current->gid == rgid) || \n\t\t    suser())\n\t\t\tcurrent->gid = rgid;\n\t\telse\n\t\t\treturn(-EPERM);\n\t}\n\tif (egid>0) {\n\t\tif ((current->gid == egid) ||\n\t\t    (current->egid == egid) ||\n\t\t    (current->sgid == egid) ||\n\t\t    suser())\n\t\t\tcurrent->egid = egid;\n\t\telse\n\t\t\treturn(-EPERM);\n\t}\n\treturn 0;\n}\n\nint sys_setgid(int gid)\n{\n\treturn(sys_setregid(gid, gid));\n}\n\nint sys_acct()\n{\n\treturn -ENOSYS;\n}\n\nint sys_phys()\n{\n\treturn -ENOSYS;\n}\n\nint sys_lock()\n{\n\treturn -ENOSYS;\n}\n\nint sys_mpx()\n{\n\treturn -ENOSYS;\n}\n\nint sys_ulimit()\n{\n\treturn -ENOSYS;\n}\n\nint sys_time(long * tloc)\n{\n\tint i;\n\n\ti = CURRENT_TIME;\n\tif (tloc) {\n\t\tverify_area(tloc,4);\n\t\tput_fs_long(i,(unsigned long *)tloc);\n\t}\n\treturn i;\n}\n\n/*\n * Unprivileged users may change the real user id to the effective uid\n * or vice versa.\n */\nint sys_setreuid(int ruid, int euid)\n{\n\tint old_ruid = current->uid;\n\t\n\tif (ruid>0) {\n\t\tif ((current->euid==ruid) ||\n                    (old_ruid == ruid) ||\n\t\t    suser())\n\t\t\tcurrent->uid = ruid;\n\t\telse\n\t\t\treturn(-EPERM);\n\t}\n\tif (euid>0) {\n\t\tif ((old_ruid == euid) ||\n                    (current->euid == euid) ||\n\t\t    suser())\n\t\t\tcurrent->euid = euid;\n\t\telse {\n\t\t\tcurrent->uid = old_ruid;\n\t\t\treturn(-EPERM);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint sys_setuid(int uid)\n{\n\treturn(sys_setreuid(uid, uid));\n}\n\nint sys_stime(long * tptr)\n{\n\tif (!suser())\n\t\treturn -EPERM;\n\tstartup_time = get_fs_long((unsigned long *)tptr) - jiffies/HZ;\n\treturn 0;\n}\n\nint sys_times(struct tms * tbuf)\n{\n\tif (tbuf) {\n\t\tverify_area(tbuf,sizeof *tbuf);\n\t\tput_fs_long(current->utime,(unsigned long *)&tbuf->tms_utime);\n\t\tput_fs_long(current->stime,(unsigned long *)&tbuf->tms_stime);\n\t\tput_fs_long(current->cutime,(unsigned long *)&tbuf->tms_cutime);\n\t\tput_fs_long(current->cstime,(unsigned long *)&tbuf->tms_cstime);\n\t}\n\treturn jiffies;\n}\n\nint sys_brk(unsigned long end_data_seg)\n{\n\tif (end_data_seg >= current->end_code &&\n\t    end_data_seg < current->start_stack - 16384)\n\t\tcurrent->brk = end_data_seg;\n\treturn current->brk;\n}\n\n/*\n * This needs some heave checking ...\n * I just haven't get the stomach for it. I also don't fully\n * understand sessions/pgrp etc. Let somebody who does explain it.\n */\nint sys_setpgid(int pid, int pgid)\n{\n\tint i;\n\n\tif (!pid)\n\t\tpid = current->pid;\n\tif (!pgid)\n\t\tpgid = current->pid;\n\tfor (i=0 ; i<NR_TASKS ; i++)\n\t\tif (task[i] && task[i]->pid==pid) {\n\t\t\tif (task[i]->leader)\n\t\t\t\treturn -EPERM;\n\t\t\tif (task[i]->session != current->session)\n\t\t\t\treturn -EPERM;\n\t\t\ttask[i]->pgrp = pgid;\n\t\t\treturn 0;\n\t\t}\n\treturn -ESRCH;\n}\n\nint sys_getpgrp(void)\n{\n\treturn current->pgrp;\n}\n\nint sys_setsid(void)\n{\n\tif (current->leader && !suser())\n\t\treturn -EPERM;\n\tcurrent->leader = 1;\n\tcurrent->session = current->pgrp = current->pid;\n\tcurrent->tty = -1;\n\treturn current->pgrp;\n}\n\nint sys_uname(struct utsname * name)\n{\n\tstatic struct utsname thisname = {\n\t\t\"linux .0\",\"nodename\",\"release \",\"version \",\"machine \"\n\t};\n\tint i;\n\n\tif (!name) return -ERROR;\n\tverify_area(name,sizeof *name);\n\tfor(i=0;i<sizeof *name;i++)\n\t\tput_fs_byte(((char *) &thisname)[i],i+(char *) name);\n\treturn 0;\n}\n\nint sys_umask(int mask)\n{\n\tint old = current->umask;\n\n\tcurrent->umask = mask & 0777;\n\treturn (old);\n}",
        "/*\n *  linux/kernel/mktime.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <time.h>\n\n/*\n * This isn't the library routine, it is only used in the kernel.\n * as such, we don't care about years<1970 etc, but assume everything\n * is ok. Similarly, TZ etc is happily ignored. We just do everything\n * as easily as possible. Let's find something public for the library\n * routines (although I think minix times is public).\n */\n/*\n * PS. I hate whoever though up the year 1970 - couldn't they have gotten\n * a leap-year instead? I also hate Gregorius, pope or no. I'm grumpy.\n */\n#define MINUTE 60\n#define HOUR (60*MINUTE)\n#define DAY (24*HOUR)\n#define YEAR (365*DAY)\n\n/* interestingly, we assume leap-years */\nstatic int month[12] = {\n\t0,\n\tDAY*(31),\n\tDAY*(31+29),\n\tDAY*(31+29+31),\n\tDAY*(31+29+31+30),\n\tDAY*(31+29+31+30+31),\n\tDAY*(31+29+31+30+31+30),\n\tDAY*(31+29+31+30+31+30+31),\n\tDAY*(31+29+31+30+31+30+31+31),\n\tDAY*(31+29+31+30+31+30+31+31+30),\n\tDAY*(31+29+31+30+31+30+31+31+30+31),\n\tDAY*(31+29+31+30+31+30+31+31+30+31+30)\n};\n\nlong kernel_mktime(struct tm * tm)\n{\n\tlong res;\n\tint year;\n\tif (tm->tm_year >= 70)\n\t  year = tm->tm_year - 70;\n\telse\n\t  year = tm->tm_year + 100 -70; /* Y2K bug fix by hellotigercn 20110803 */\n/* magic offsets (y+1) needed to get leapyears right.*/\n\tres = YEAR*year + DAY*((year+1)/4);\n\tres += month[tm->tm_mon];\n/* and (y+2) here. If it wasn't a leap-year, we have to adjust */\n\tif (tm->tm_mon>1 && ((year+2)%4))\n\t\tres -= DAY;\n\tres += DAY*(tm->tm_mday-1);\n\tres += HOUR*tm->tm_hour;\n\tres += MINUTE*tm->tm_min;\n\tres += tm->tm_sec;\n\treturn res;\n}",
        "/*\n *  linux/kernel/fork.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n *  'fork.c' contains the help-routines for the 'fork' system call\n * (see also system_call.s), and some misc functions ('verify_area').\n * Fork is rather simple, once you get the hang of it, but the memory\n * management can be a bitch. See 'mm/mm.c': 'copy_page_tables()'\n */\n#include <string.h>\n#include <errno.h>\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/segment.h>\n#include <asm/system.h>\n\nextern void write_verify(unsigned long address);\n\nlong last_pid=0;\n\nvoid verify_area(void * addr,int size)\n{\n\tunsigned long start;\n\n\tstart = (unsigned long) addr;\n\tsize += start & 0xfff;\n\tstart &= 0xfffff000;\n\tstart += get_base(current->ldt[2]);\n\twhile (size>0) {\n\t\tsize -= 4096;\n\t\twrite_verify(start);\n\t\tstart += 4096;\n\t}\n}\n\nint copy_mem(int nr,struct task_struct * p)\n{\n\tunsigned long old_data_base,new_data_base,data_limit;\n\tunsigned long old_code_base,new_code_base,code_limit;\n\n\tcode_limit=get_limit(0x0f);\n\tdata_limit=get_limit(0x17);\n\told_code_base = get_base(current->ldt[1]);\n\told_data_base = get_base(current->ldt[2]);\n\tif (old_data_base != old_code_base)\n\t\tpanic(\"We don't support separate I&D\");\n\tif (data_limit < code_limit)\n\t\tpanic(\"Bad data_limit\");\n\tnew_data_base = new_code_base = nr * 0x4000000;\n\tp->start_code = new_code_base;\n\tset_base(p->ldt[1],new_code_base);\n\tset_base(p->ldt[2],new_data_base);\n\tif (copy_page_tables(old_data_base,new_data_base,data_limit)) {\n\t\tprintk(\"free_page_tables: from copy_mem\\n\");\n\t\tfree_page_tables(new_data_base,data_limit);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n/*\n *  Ok, this is the main fork-routine. It copies the system process\n * information (task[nr]) and sets up the necessary registers. It\n * also copies the data segment in it's entirety.\n */\nint copy_process(int nr,long ebp,long edi,long esi,long gs,long none,\n\t\tlong ebx,long ecx,long edx,\n\t\tlong fs,long es,long ds,\n\t\tlong eip,long cs,long eflags,long esp,long ss)\n{\n\tstruct task_struct *p;\n\tint i;\n\tstruct file *f;\n\n\tp = (struct task_struct *) get_free_page();\n\tif (!p)\n\t\treturn -EAGAIN;\n\ttask[nr] = p;\n\t\n\t// NOTE!: the following statement now work with gcc 4.3.2 now, and you\n\t// must compile _THIS_ memcpy without no -O of gcc.#ifndef GCC4_3\n\t*p = *current;\t/* NOTE! this doesn't copy the supervisor stack */\n\tp->state = TASK_UNINTERRUPTIBLE;\n\tp->pid = last_pid;\n\tp->father = current->pid;\n\tp->counter = p->priority;\n\tp->signal = 0;\n\tp->alarm = 0;\n\tp->leader = 0;\t\t/* process leadership doesn't inherit */\n\tp->utime = p->stime = 0;\n\tp->cutime = p->cstime = 0;\n\tp->start_time = jiffies;\n\tp->tss.back_link = 0;\n\tp->tss.esp0 = PAGE_SIZE + (long) p;\n\tp->tss.ss0 = 0x10;\n\tp->tss.eip = eip;\n\tp->tss.eflags = eflags;\n\tp->tss.eax = 0;\n\tp->tss.ecx = ecx;\n\tp->tss.edx = edx;\n\tp->tss.ebx = ebx;\n\tp->tss.esp = esp;\n\tp->tss.ebp = ebp;\n\tp->tss.esi = esi;\n\tp->tss.edi = edi;\n\tp->tss.es = es & 0xffff;\n\tp->tss.cs = cs & 0xffff;\n\tp->tss.ss = ss & 0xffff;\n\tp->tss.ds = ds & 0xffff;\n\tp->tss.fs = fs & 0xffff;\n\tp->tss.gs = gs & 0xffff;\n\tp->tss.ldt = _LDT(nr);\n\tp->tss.trace_bitmap = 0x80000000;\n\tif (last_task_used_math == current)\n\t\t__asm__(\"clts ; fnsave %0\"::\"m\" (p->tss.i387));\n\tif (copy_mem(nr,p)) {\n\t\ttask[nr] = NULL;\n\t\tfree_page((long) p);\n\t\treturn -EAGAIN;\n\t}\n\tfor (i=0; i<NR_OPEN;i++)\n\t\tif ((f=p->filp[i]))\n\t\t\tf->f_count++;\n\tif (current->pwd)\n\t\tcurrent->pwd->i_count++;\n\tif (current->root)\n\t\tcurrent->root->i_count++;\n\tif (current->executable)\n\t\tcurrent->executable->i_count++;\n\tset_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));\n\tset_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));\n\tp->state = TASK_RUNNING;\t/* do this last, just in case */\n\treturn last_pid;\n}\n\nint find_empty_process(void)\n{\n\tint i;\n\n\trepeat:\n\t\tif ((++last_pid)<0) last_pid=1;\n\t\tfor(i=0 ; i<NR_TASKS ; i++)\n\t\t\tif (task[i] && task[i]->pid == last_pid) goto repeat;\n\tfor(i=1 ; i<NR_TASKS ; i++)\n\t\tif (!task[i])\n\t\t\treturn i;\n\treturn -EAGAIN;\n}",
        "/*\n *  linux/kernel/traps.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * 'Traps.c' handles hardware traps and faults after we have saved some\n * state in 'asm.s'. Currently mostly a debugging-aid, will be extended\n * to mainly kill the offending process (probably by giving it a signal,\n * but possibly by killing it outright if necessary).\n */\n#include <string.h> \n\n#include <linux/head.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/system.h>\n#include <asm/segment.h>\n#include <asm/io.h>\n\n#define get_seg_byte(seg,addr) ({ \\\nregister char __res; \\\n__asm__(\"push %%fs;mov %%ax,%%fs;movb %%fs:%2,%%al;pop %%fs\" \\\n\t:\"=a\" (__res):\"0\" (seg),\"m\" (*(addr))); \\\n__res;})\n\n#define get_seg_long(seg,addr) ({ \\\nregister unsigned long __res; \\\n__asm__(\"push %%fs;mov %%ax,%%fs;movl %%fs:%2,%%eax;pop %%fs\" \\\n\t:\"=a\" (__res):\"0\" (seg),\"m\" (*(addr))); \\\n__res;})\n\n#define _fs() ({ \\\nregister unsigned short __res; \\\n__asm__(\"mov %%fs,%%ax\":\"=a\" (__res):); \\\n__res;})\n\nint do_exit(long code);\n\nvoid page_exception(void);\n\nvoid divide_error(void);\nvoid debug(void);\nvoid nmi(void);\nvoid int3(void);\nvoid overflow(void);\nvoid bounds(void);\nvoid invalid_op(void);\nvoid device_not_available(void);\nvoid double_fault(void);\nvoid coprocessor_segment_overrun(void);\nvoid invalid_TSS(void);\nvoid segment_not_present(void);\nvoid stack_segment(void);\nvoid general_protection(void);\nvoid page_fault(void);\nvoid coprocessor_error(void);\nvoid reserved(void);\nvoid parallel_interrupt(void);\nvoid irq13(void);\n\nstatic void die(char * str,long esp_ptr,long nr)\n{\n\tlong * esp = (long *) esp_ptr;\n\tint i;\n\n\tprintk(\"%s: %04x\\n\\r\",str,nr&0xffff);\n\tprintk(\"EIP:\\t%04x:%p\\nEFLAGS:\\t%p\\nESP:\\t%04x:%p\\n\",\n\t\tesp[1],esp[0],esp[2],esp[4],esp[3]);\n\tprintk(\"fs: %04x\\n\",_fs());\n\tprintk(\"base: %p, limit: %p\\n\",get_base(current->ldt[1]),get_limit(0x17));\n\tif (esp[4] == 0x17) {\n\t\tprintk(\"Stack: \");\n\t\tfor (i=0;i<4;i++)\n\t\t\tprintk(\"%p \",get_seg_long(0x17,i+(long *)esp[3]));\n\t\tprintk(\"\\n\");\n\t}\n\tstr(i);\n\tprintk(\"Pid: %d, process nr: %d\\n\\r\",current->pid,0xffff & i);\n\tfor(i=0;i<10;i++)\n\t\tprintk(\"%02x \",0xff & get_seg_byte(esp[1],(i+(char *)esp[0])));\n\tprintk(\"\\n\\r\");\n\tdo_exit(11);\t\t/* play segment exception */\n}\n\nvoid do_double_fault(long esp, long error_code)\n{\n\tdie(\"double fault\",esp,error_code);\n}\n\nvoid do_general_protection(long esp, long error_code)\n{\n\tdie(\"general protection\",esp,error_code);\n}\n\nvoid do_divide_error(long esp, long error_code)\n{\n\tdie(\"divide error\",esp,error_code);\n}\n\nvoid do_int3(long * esp, long error_code,\n\t\tlong fs,long es,long ds,\n\t\tlong ebp,long esi,long edi,\n\t\tlong edx,long ecx,long ebx,long eax)\n{\n\tint tr;\n\n\t__asm__(\"str %%ax\":\"=a\" (tr):\"0\" (0));\n\tprintk(\"eax\\t\\tebx\\t\\tecx\\t\\tedx\\n\\r%8x\\t%8x\\t%8x\\t%8x\\n\\r\",\n\t\teax,ebx,ecx,edx);\n\tprintk(\"esi\\t\\tedi\\t\\tebp\\t\\tesp\\n\\r%8x\\t%8x\\t%8x\\t%8x\\n\\r\",\n\t\tesi,edi,ebp,(long) esp);\n\tprintk(\"\\n\\rds\\tes\\tfs\\ttr\\n\\r%4x\\t%4x\\t%4x\\t%4x\\n\\r\",\n\t\tds,es,fs,tr);\n\tprintk(\"EIP: %8x   CS: %4x  EFLAGS: %8x\\n\\r\",esp[0],esp[1],esp[2]);\n}\n\nvoid do_nmi(long esp, long error_code)\n{\n\tdie(\"nmi\",esp,error_code);\n}\n\nvoid do_debug(long esp, long error_code)\n{\n\tdie(\"debug\",esp,error_code);\n}\n\nvoid do_overflow(long esp, long error_code)\n{\n\tdie(\"overflow\",esp,error_code);\n}\n\nvoid do_bounds(long esp, long error_code)\n{\n\tdie(\"bounds\",esp,error_code);\n}\n\nvoid do_invalid_op(long esp, long error_code)\n{\n\tdie(\"invalid operand\",esp,error_code);\n}\n\nvoid do_device_not_available(long esp, long error_code)\n{\n\tdie(\"device not available\",esp,error_code);\n}\n\nvoid do_coprocessor_segment_overrun(long esp, long error_code)\n{\n\tdie(\"coprocessor segment overrun\",esp,error_code);\n}\n\nvoid do_invalid_TSS(long esp,long error_code)\n{\n\tdie(\"invalid TSS\",esp,error_code);\n}\n\nvoid do_segment_not_present(long esp,long error_code)\n{\n\tdie(\"segment not present\",esp,error_code);\n}\n\nvoid do_stack_segment(long esp,long error_code)\n{\n\tdie(\"stack segment\",esp,error_code);\n}\n\nvoid do_coprocessor_error(long esp, long error_code)\n{\n\tif (last_task_used_math != current)\n\t\treturn;\n\tdie(\"coprocessor error\",esp,error_code);\n}\n\nvoid do_reserved(long esp, long error_code)\n{\n\tdie(\"reserved (15,17-47) error\",esp,error_code);\n}\n\nvoid trap_init(void)\n{\n\tint i;\n\n\tset_trap_gate(0,&divide_error);\n\tset_trap_gate(1,&debug);\n\tset_trap_gate(2,&nmi);\n\tset_system_gate(3,&int3);\t/* int3-5 can be called from all */\n\tset_system_gate(4,&overflow);\n\tset_system_gate(5,&bounds);\n\tset_trap_gate(6,&invalid_op);\n\tset_trap_gate(7,&device_not_available);\n\tset_trap_gate(8,&double_fault);\n\tset_trap_gate(9,&coprocessor_segment_overrun);\n\tset_trap_gate(10,&invalid_TSS);\n\tset_trap_gate(11,&segment_not_present);\n\tset_trap_gate(12,&stack_segment);\n\tset_trap_gate(13,&general_protection);\n\tset_trap_gate(14,&page_fault);\n\tset_trap_gate(15,&reserved);\n\tset_trap_gate(16,&coprocessor_error);\n\tfor (i=17;i<48;i++)\n\t\tset_trap_gate(i,&reserved);\n\tset_trap_gate(45,&irq13);\n\toutb_p(inb_p(0x21)&0xfb,0x21);\n\toutb(inb_p(0xA1)&0xdf,0xA1);\n\tset_trap_gate(39,&parallel_interrupt);\n}",
        "/*\n *  linux/kernel/printk.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * When in kernel-mode, we cannot use printf, as fs is liable to\n * point to 'interesting' things. Make a printf with fs-saving, and\n * all is well.\n */\n#include <stdarg.h>\n#include <stddef.h>\n\n#include <linux/kernel.h>\n\nstatic char buf[1024];\n\nextern int vsprintf(char * buf, const char * fmt, va_list args);\n\nint printk(const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\ti=vsprintf(buf,fmt,args);\n\tva_end(args);\n\t__asm__(\"push %%fs\\n\\t\"\n\t\t\"push %%ds\\n\\t\"\n\t\t\"pop %%fs\\n\\t\"\n\t\t\"pushl %0\\n\\t\"\n\t\t\"pushl $buf\\n\\t\"\n\t\t\"pushl $0\\n\\t\"\n\t\t\"call tty_write\\n\\t\"\n\t\t\"addl $8,%%esp\\n\\t\"\n\t\t\"popl %0\\n\\t\"\n\t\t\"pop %%fs\"\n\t\t::\"r\" (i):\"ax\",\"cx\",\"dx\");\n\treturn i;\n}",
        "/*\n *  linux/kernel/exit.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <errno.h>\n#include <signal.h>\n#include <sys/wait.h>\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/tty.h>\n#include <asm/segment.h>\n\nint sys_pause(void);\nint sys_close(int fd);\n\nvoid release(struct task_struct * p)\n{\n\tint i;\n\n\tif (!p)\n\t\treturn;\n\tfor (i=1 ; i<NR_TASKS ; i++)\n\t\tif (task[i]==p) {\n\t\t\ttask[i]=NULL;\n\t\t\tfree_page((long)p);\n\t\t\tschedule();\n\t\t\treturn;\n\t\t}\n\tpanic(\"trying to release non-existent task\");\n}\n\nstatic inline int send_sig(long sig,struct task_struct * p,int priv)\n{\n\tif (!p || sig<1 || sig>32)\n\t\treturn -EINVAL;\n\tif (priv || (current->euid==p->euid) || suser())\n\t\tp->signal |= (1<<(sig-1));\n\telse\n\t\treturn -EPERM;\n\treturn 0;\n}\n\nstatic void kill_session(void)\n{\n\tstruct task_struct **p = NR_TASKS + task;\n\t\n\twhile (--p > &FIRST_TASK) {\n\t\tif (*p && (*p)->session == current->session)\n\t\t\t(*p)->signal |= 1<<(SIGHUP-1);\n\t}\n}\n\n/*\n * XXX need to check permissions needed to send signals to process\n * groups, etc. etc.  kill() permissions semantics are tricky!\n */\nint sys_kill(int pid,int sig)\n{\n\tstruct task_struct **p = NR_TASKS + task;\n\tint err, retval = 0;\n\n\tif (!pid) while (--p > &FIRST_TASK) {\n\t\tif (*p && (*p)->pgrp == current->pid) \n\t\t\tif ((err=send_sig(sig,*p,1)))\n\t\t\t\tretval = err;\n\t} else if (pid>0) while (--p > &FIRST_TASK) {\n\t\tif (*p && (*p)->pid == pid) \n\t\t\tif ((err=send_sig(sig,*p,0)))\n\t\t\t\tretval = err;\n\t} else if (pid == -1) while (--p > &FIRST_TASK) {\n\t\tif ((err = send_sig(sig,*p,0)))\n\t\t\tretval = err;\n\t} else while (--p > &FIRST_TASK)\n\t\tif (*p && (*p)->pgrp == -pid)\n\t\t\tif ((err = send_sig(sig,*p,0)))\n\t\t\t\tretval = err;\n\treturn retval;\n}\n\nstatic void tell_father(int pid)\n{\n\tint i;\n\n\tif (pid)\n\t\tfor (i=0;i<NR_TASKS;i++) {\n\t\t\tif (!task[i])\n\t\t\t\tcontinue;\n\t\t\tif (task[i]->pid != pid)\n\t\t\t\tcontinue;\n\t\t\ttask[i]->signal |= (1<<(SIGCHLD-1));\n\t\t\treturn;\n\t\t}\n/* if we don't find any fathers, we just release ourselves */\n/* This is not really OK. Must change it to make father 1 */\n\tprintk(\"BAD BAD - no father found\\n\\r\");\n\trelease(current);\n}\n\nint do_exit(long code)\n{\n\tint i;\n\tfree_page_tables(get_base(current->ldt[1]),get_limit(0x0f));\n\tfree_page_tables(get_base(current->ldt[2]),get_limit(0x17));\n\tfor (i=0 ; i<NR_TASKS ; i++)\n\t\tif (task[i] && task[i]->father == current->pid) {\n\t\t\ttask[i]->father = 1;\n\t\t\tif (task[i]->state == TASK_ZOMBIE)\n\t\t\t\t/* assumption task[1] is always init */\n\t\t\t\t(void) send_sig(SIGCHLD, task[1], 1);\n\t\t}\n\tfor (i=0 ; i<NR_OPEN ; i++)\n\t\tif (current->filp[i])\n\t\t\tsys_close(i);\n\tiput(current->pwd);\n\tcurrent->pwd=NULL;\n\tiput(current->root);\n\tcurrent->root=NULL;\n\tiput(current->executable);\n\tcurrent->executable=NULL;\n\tif (current->leader && current->tty >= 0)\n\t\ttty_table[current->tty].pgrp = 0;\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n\tif (current->leader)\n\t\tkill_session();\n\tcurrent->state = TASK_ZOMBIE;\n\tcurrent->exit_code = code;\n\ttell_father(current->father);\n\tschedule();\n\treturn (-1);\t/* just to suppress warnings */\n}\n\nint sys_exit(int error_code)\n{\n\treturn do_exit((error_code&0xff)<<8);\n}\n\nint sys_waitpid(pid_t pid,unsigned long * stat_addr, int options)\n{\n\tint flag, code;\n\tstruct task_struct ** p;\n\n\tverify_area(stat_addr,4);\nrepeat:\n\tflag=0;\n\tfor(p = &LAST_TASK ; p > &FIRST_TASK ; --p) {\n\t\tif (!*p || *p == current)\n\t\t\tcontinue;\n\t\tif ((*p)->father != current->pid)\n\t\t\tcontinue;\n\t\tif (pid>0) {\n\t\t\tif ((*p)->pid != pid)\n\t\t\t\tcontinue;\n\t\t} else if (!pid) {\n\t\t\tif ((*p)->pgrp != current->pgrp)\n\t\t\t\tcontinue;\n\t\t} else if (pid != -1) {\n\t\t\tif ((*p)->pgrp != -pid)\n\t\t\t\tcontinue;\n\t\t}\n\t\tswitch ((*p)->state) {\n\t\t\tcase TASK_STOPPED:\n\t\t\t\tif (!(options & WUNTRACED))\n\t\t\t\t\tcontinue;\n\t\t\t\tput_fs_long(0x7f,stat_addr);\n\t\t\t\treturn (*p)->pid;\n\t\t\tcase TASK_ZOMBIE:\n\t\t\t\tcurrent->cutime += (*p)->utime;\n\t\t\t\tcurrent->cstime += (*p)->stime;\n\t\t\t\tflag = (*p)->pid;\n\t\t\t\tcode = (*p)->exit_code;\n\t\t\t\trelease(*p);\n\t\t\t\tput_fs_long(code,stat_addr);\n\t\t\t\treturn flag;\n\t\t\tdefault:\n\t\t\t\tflag=1;\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\tif (flag) {\n\t\tif (options & WNOHANG)\n\t\t\treturn 0;\n\t\tcurrent->state=TASK_INTERRUPTIBLE;\n\t\tschedule();\n\t\tif (!(current->signal &= ~(1<<(SIGCHLD-1))))\n\t\t\tgoto repeat;\n\t\telse\n\t\t\treturn -EINTR;\n\t}\n\treturn -ECHILD;\n}\n\n",
        "/*\n *  linux/kernel/panic.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * This function is used through-out the kernel (includeinh mm and fs)\n * to indicate a major problem.\n */\n#define PANIC\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n\nvoid sys_sync(void);\t/* it's really int */\n\nvoid panic(const char * s)\n{\n\tprintk(\"Kernel panic: %s\\n\\r\",s);\n\tif (current == task[0])\n\t\tprintk(\"In swapper task - not syncing\\n\\r\");\n\telse\n\t\tsys_sync();\n\tfor(;;);\n}",
        "/*\n *  linux/kernel/vsprintf.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */\n/*\n * Wirzenius wrote this portably, Torvalds fucked it up :-)\n */\n\n#include <stdarg.h>\n#include <string.h> \n\n/* we use this so that we can do without the ctype library */\n#define is_digit(c)\t((c) >= '0' && (c) <= '9')\n\nstatic int skip_atoi(const char **s)\n{\n\tint i=0;\n\n\twhile (is_digit(**s))\n\t\ti = i*10 + *((*s)++) - '0';\n\treturn i;\n}\n\n#define ZEROPAD\t1\t\t/* pad with zero */\n#define SIGN\t2\t\t/* unsigned/signed long */\n#define PLUS\t4\t\t/* show plus */\n#define SPACE\t8\t\t/* space if plus */\n#define LEFT\t16\t\t/* left justified */\n#define SPECIAL\t32\t\t/* 0x */\n#define SMALL\t64\t\t/* use 'abcdef' instead of 'ABCDEF' */\n\n#define do_div(n,base) ({ \\\nint __res; \\\n__asm__(\"divl %4\":\"=a\" (n),\"=d\" (__res):\"0\" (n),\"1\" (0),\"r\" (base)); \\\n__res; })\n\nstatic char * number(char * str, int num, int base, int size, int precision\n\t,int type)\n{\n\tchar c,sign,tmp[36];\n\tconst char *digits=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\tint i;\n\n\tif (type&SMALL) digits=\"0123456789abcdefghijklmnopqrstuvwxyz\";\n\tif (type&LEFT) type &= ~ZEROPAD;\n\tif (base<2 || base>36)\n\t\treturn 0;\n\tc = (type & ZEROPAD) ? '0' : ' ' ;\n\tif (type&SIGN && num<0) {\n\t\tsign='-';\n\t\tnum = -num;\n\t} else\n\t\tsign=(type&PLUS) ? '+' : ((type&SPACE) ? ' ' : 0);\n\tif (sign) size--;\n\tif (type&SPECIAL) {\n\t\tif (base==16) size -= 2;\n\t\telse if (base==8) size--;\n\t}\n\ti=0;\n\tif (num==0)\n\t\ttmp[i++]='0';\n\telse while (num!=0)\n\t\ttmp[i++]=digits[do_div(num,base)];\n\tif (i>precision) precision=i;\n\tsize -= precision;\n\tif (!(type&(ZEROPAD+LEFT)))\n\t\twhile(size-->0)\n\t\t\t*str++ = ' ';\n\tif (sign)\n\t\t*str++ = sign;\n\tif (type&SPECIAL) {\n\t\tif (base==8)\n\t\t\t*str++ = '0';\n\t\telse if (base==16) {\n\t\t\t*str++ = '0';\n\t\t\t*str++ = digits[33];\n\t\t}\n\t}\n\tif (!(type&LEFT))\n\t\twhile(size-->0)\n\t\t\t*str++ = c;\n\twhile(i<precision--)\n\t\t*str++ = '0';\n\twhile(i-->0)\n\t\t*str++ = tmp[i];\n\twhile(size-->0)\n\t\t*str++ = ' ';\n\treturn str;\n}\n\nint vsprintf(char *buf, const char *fmt, va_list args)\n{\n\tint len;\n\tint i;\n\tchar * str;\n\tchar *s;\n\tint *ip;\n\n\tint flags;\t\t/* flags to number() */\n\n\tint field_width;\t/* width of output field */\n\tint precision;\t\t/* min. # of digits for integers; max\n\t\t\t\t   number of chars for from string */\n\tint qualifier;\t\t/* 'h', 'l', or 'L' for integer fields */\n\n\tfor (str=buf ; *fmt ; ++fmt) {\n\t\tif (*fmt != '%') {\n\t\t\t*str++ = *fmt;\n\t\t\tcontinue;\n\t\t}\n\t\t\t\n\t\t/* process flags */\n\t\tflags = 0;\n\t\trepeat:\n\t\t\t++fmt;\t\t/* this also skips first '%' */\n\t\t\tswitch (*fmt) {\n\t\t\t\tcase '-': flags |= LEFT; goto repeat;\n\t\t\t\tcase '+': flags |= PLUS; goto repeat;\n\t\t\t\tcase ' ': flags |= SPACE; goto repeat;\n\t\t\t\tcase '#': flags |= SPECIAL; goto repeat;\n\t\t\t\tcase '0': flags |= ZEROPAD; goto repeat;\n\t\t\t\t}\n\t\t\n\t\t/* get field width */\n\t\tfield_width = -1;\n\t\tif (is_digit(*fmt))\n\t\t\tfield_width = skip_atoi(&fmt);\n\t\telse if (*fmt == '*') {\n\t\t\t++fmt;\n\t\t\t/* it's the next argument */\n\t\t\tfield_width = va_arg(args, int);\n\t\t\tif (field_width < 0) {\n\t\t\t\tfield_width = -field_width;\n\t\t\t\tflags |= LEFT;\n\t\t\t}\n\t\t}\n\n\t\t/* get the precision */\n\t\tprecision = -1;\n\t\tif (*fmt == '.') {\n\t\t\t++fmt;\t\n\t\t\tif (is_digit(*fmt))\n\t\t\t\tprecision = skip_atoi(&fmt);\n\t\t\telse if (*fmt == '*') {\n\t\t\t\t++fmt;\n\t\t\t\t/* it's the next argument */\n\t\t\t\tprecision = va_arg(args, int);\n\t\t\t}\n\t\t\tif (precision < 0)\n\t\t\t\tprecision = 0;\n\t\t}\n\n\t\t/* get the conversion qualifier */\n\t\tqualifier = -1;\n\t\tif (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {\n\t\t\tqualifier = *fmt;\n\t\t\t++fmt;\n\t\t}\n\n\t\tswitch (*fmt) {\n\t\tcase 'c':\n\t\t\tif (!(flags & LEFT))\n\t\t\t\twhile (--field_width > 0)\n\t\t\t\t\t*str++ = ' ';\n\t\t\t*str++ = (unsigned char) va_arg(args, int);\n\t\t\twhile (--field_width > 0)\n\t\t\t\t*str++ = ' ';\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\ts = va_arg(args, char *);\n\t\t\tif (!s)\n\t\t\t\ts = \"<NULL>\";\n\t\t\tlen = strlen(s);\n\t\t\tif (precision < 0)\n\t\t\t\tprecision = len;\n\t\t\telse if (len > precision)\n\t\t\t\tlen = precision;\n\n\t\t\tif (!(flags & LEFT))\n\t\t\t\twhile (len < field_width--)\n\t\t\t\t\t*str++ = ' ';\n\t\t\tfor (i = 0; i < len; ++i)\n\t\t\t\t*str++ = *s++;\n\t\t\twhile (len < field_width--)\n\t\t\t\t*str++ = ' ';\n\t\t\tbreak;\n\n\t\tcase 'o':\n\t\t\tstr = number(str, va_arg(args, unsigned long), 8,\n\t\t\t\tfield_width, precision, flags);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif (field_width == -1) {\n\t\t\t\tfield_width = 8;\n\t\t\t\tflags |= ZEROPAD;\n\t\t\t}\n\t\t\tstr = number(str,\n\t\t\t\t(unsigned long) va_arg(args, void *), 16,\n\t\t\t\tfield_width, precision, flags);\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tflags |= SMALL;\n\t\tcase 'X':\n\t\t\tstr = number(str, va_arg(args, unsigned long), 16,\n\t\t\t\tfield_width, precision, flags);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tflags |= SIGN;\n\t\tcase 'u':\n\t\t\tstr = number(str, va_arg(args, unsigned long), 10,\n\t\t\t\tfield_width, precision, flags);\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tip = va_arg(args, int *);\n\t\t\t*ip = (str - buf);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (*fmt != '%')\n\t\t\t\t*str++ = '%';\n\t\t\tif (*fmt)\n\t\t\t\t*str++ = *fmt;\n\t\t\telse\n\t\t\t\t--fmt;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*str = '\\0';\n\treturn str-buf;\n}",
        "/*\n * linux/kernel/math/math_emulate.c\n *\n * (C) 1991 Linus Torvalds\n */\n\n/*\n * This directory should contain the math-emulation code.\n * Currently only results in a signal.\n */\n\n#include <signal.h>\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/segment.h>\n\nvoid math_emulate(long edi, long esi, long ebp, long sys_call_ret,\n\tlong eax,long ebx,long ecx,long edx,\n\tunsigned short fs,unsigned short es,unsigned short ds,\n\tunsigned long eip,unsigned short cs,unsigned long eflags,\n\tunsigned short ss, unsigned long esp)\n{\n\tunsigned char first, second;\n\n/* 0x0007 means user code space */\n\tif (cs != 0x000F) {\n\t\tprintk(\"math_emulate: %04x:%08x\\n\\r\",cs,eip);\n\t\tpanic(\"Math emulation needed in kernel\");\n\t}\n\tfirst = get_fs_byte((char *)((*&eip)++));\n\tsecond = get_fs_byte((char *)((*&eip)++));\n\tprintk(\"%04x:%08x %02x %02x\\n\\r\",cs,eip-2,first,second);\n\tcurrent->signal |= 1<<(SIGFPE-1);\n}\n\nvoid math_error(void)\n{\n\t__asm__(\"fnclex\");\n\tif (last_task_used_math)\n\t\tlast_task_used_math->signal |= 1<<(SIGFPE-1);\n}",
        "/*\n *  linux/kernel/serial.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n *\tserial.c\n *\n * This module implements the rs232 io functions\n *\tvoid rs_write(struct tty_struct * queue);\n *\tvoid rs_init(void);\n * and all interrupts pertaining to serial IO.\n */\n\n#include <linux/tty.h>\n#include <linux/sched.h>\n#include <asm/system.h>\n#include <asm/io.h>\n\n#define WAKEUP_CHARS (TTY_BUF_SIZE/4)\n\nextern void rs1_interrupt(void);\nextern void rs2_interrupt(void);\n\nstatic void init(int port)\n{\n\toutb_p(0x80,port+3);\t/* set DLAB of line control reg */\n\toutb_p(0x30,port);\t/* LS of divisor (48 -> 2400 bps */\n\toutb_p(0x00,port+1);\t/* MS of divisor */\n\toutb_p(0x03,port+3);\t/* reset DLAB */\n\toutb_p(0x0b,port+4);\t/* set DTR,RTS, OUT_2 */\n\toutb_p(0x0d,port+1);\t/* enable all intrs but writes */\n\t(void)inb(port);\t/* read data port to reset things (?) */\n}\n\nvoid rs_init(void)\n{\n\tset_intr_gate(0x24,rs1_interrupt);\n\tset_intr_gate(0x23,rs2_interrupt);\n\tinit(tty_table[1].read_q.data);\n\tinit(tty_table[2].read_q.data);\n\toutb(inb_p(0x21)&0xE7,0x21);\n}\n\n/*\n * This routine gets called when tty_write has put something into\n * the write_queue. It must check wheter the queue is empty, and\n * set the interrupt register accordingly\n *\n *\tvoid _rs_write(struct tty_struct * tty);\n */\nvoid rs_write(struct tty_struct * tty)\n{\n\tcli();\n\tif (!EMPTY(tty->write_q))\n\t\toutb(inb_p(tty->write_q.data+1)|0x02,tty->write_q.data+1);\n\tsti();\n}",
        "/*\n *  linux/kernel/chr_drv/tty_ioctl.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <errno.h>\n#include <termios.h>\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/tty.h>\n\n#include <asm/io.h>\n#include <asm/segment.h>\n#include <asm/system.h>\n\nstatic unsigned short quotient[] = {\n\t0, 2304, 1536, 1047, 857,\n\t768, 576, 384, 192, 96,\n\t64, 48, 24, 12, 6, 3\n};\n\nstatic void change_speed(struct tty_struct * tty)\n{\n\tunsigned short port,quot;\n\n\tif (!(port = tty->read_q.data))\n\t\treturn;\n\tquot = quotient[tty->termios.c_cflag & CBAUD];\n\tcli();\n\toutb_p(0x80,port+3);\t\t/* set DLAB */\n\toutb_p(quot & 0xff,port);\t/* LS of divisor */\n\toutb_p(quot >> 8,port+1);\t/* MS of divisor */\n\toutb(0x03,port+3);\t\t/* reset DLAB */\n\tsti();\n}\n\nstatic void flush(struct tty_queue * queue)\n{\n\tcli();\n\tqueue->head = queue->tail;\n\tsti();\n}\n\nstatic void wait_until_sent(struct tty_struct * tty)\n{\n\t/* do nothing - not implemented */\n}\n\nstatic void send_break(struct tty_struct * tty)\n{\n\t/* do nothing - not implemented */\n}\n\nstatic int get_termios(struct tty_struct * tty, struct termios * termios)\n{\n\tint i;\n\n\tverify_area(termios, sizeof (*termios));\n\tfor (i=0 ; i< (sizeof (*termios)) ; i++)\n\t\tput_fs_byte( ((char *)&tty->termios)[i] , i+(char *)termios );\n\treturn 0;\n}\n\nstatic int set_termios(struct tty_struct * tty, struct termios * termios)\n{\n\tint i;\n\n\tfor (i=0 ; i< (sizeof (*termios)) ; i++)\n\t\t((char *)&tty->termios)[i]=get_fs_byte(i+(char *)termios);\n\tchange_speed(tty);\n\treturn 0;\n}\n\nstatic int get_termio(struct tty_struct * tty, struct termio * termio)\n{\n\tint i;\n\tstruct termio tmp_termio;\n\n\tverify_area(termio, sizeof (*termio));\n\ttmp_termio.c_iflag = tty->termios.c_iflag;\n\ttmp_termio.c_oflag = tty->termios.c_oflag;\n\ttmp_termio.c_cflag = tty->termios.c_cflag;\n\ttmp_termio.c_lflag = tty->termios.c_lflag;\n\ttmp_termio.c_line = tty->termios.c_line;\n\tfor(i=0 ; i < NCC ; i++)\n\t\ttmp_termio.c_cc[i] = tty->termios.c_cc[i];\n\tfor (i=0 ; i< (sizeof (*termio)) ; i++)\n\t\tput_fs_byte( ((char *)&tmp_termio)[i] , i+(char *)termio );\n\treturn 0;\n}\n\n/*\n * This only works as the 386 is low-byt-first\n */\nstatic int set_termio(struct tty_struct * tty, struct termio * termio)\n{\n\tint i;\n\tstruct termio tmp_termio;\n\n\tfor (i=0 ; i< (sizeof (*termio)) ; i++)\n\t\t((char *)&tmp_termio)[i]=get_fs_byte(i+(char *)termio);\n\t*(unsigned short *)&tty->termios.c_iflag = tmp_termio.c_iflag;\n\t*(unsigned short *)&tty->termios.c_oflag = tmp_termio.c_oflag;\n\t*(unsigned short *)&tty->termios.c_cflag = tmp_termio.c_cflag;\n\t*(unsigned short *)&tty->termios.c_lflag = tmp_termio.c_lflag;\n\ttty->termios.c_line = tmp_termio.c_line;\n\tfor(i=0 ; i < NCC ; i++)\n\t\ttty->termios.c_cc[i] = tmp_termio.c_cc[i];\n\tchange_speed(tty);\n\treturn 0;\n}\n\nint tty_ioctl(int dev, int cmd, int arg)\n{\n\tstruct tty_struct * tty;\n\tif (MAJOR(dev) == 5) {\n\t\tdev=current->tty;\n\t\tif (dev<0)\n\t\t\tpanic(\"tty_ioctl: dev<0\");\n\t} else\n\t\tdev=MINOR(dev);\n\ttty = dev + tty_table;\n\tswitch (cmd) {\n\t\tcase TCGETS:\n\t\t\treturn get_termios(tty,(struct termios *) arg);\n\t\tcase TCSETSF:\n\t\t\tflush(&tty->read_q); /* fallthrough */\n\t\tcase TCSETSW:\n\t\t\twait_until_sent(tty); /* fallthrough */\n\t\tcase TCSETS:\n\t\t\treturn set_termios(tty,(struct termios *) arg);\n\t\tcase TCGETA:\n\t\t\treturn get_termio(tty,(struct termio *) arg);\n\t\tcase TCSETAF:\n\t\t\tflush(&tty->read_q); /* fallthrough */\n\t\tcase TCSETAW:\n\t\t\twait_until_sent(tty); /* fallthrough */\n\t\tcase TCSETA:\n\t\t\treturn set_termio(tty,(struct termio *) arg);\n\t\tcase TCSBRK:\n\t\t\tif (!arg) {\n\t\t\t\twait_until_sent(tty);\n\t\t\t\tsend_break(tty);\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase TCXONC:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TCFLSH:\n\t\t\tif (arg==0)\n\t\t\t\tflush(&tty->read_q);\n\t\t\telse if (arg==1)\n\t\t\t\tflush(&tty->write_q);\n\t\t\telse if (arg==2) {\n\t\t\t\tflush(&tty->read_q);\n\t\t\t\tflush(&tty->write_q);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\treturn 0;\n\t\tcase TIOCEXCL:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TIOCNXCL:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TIOCSCTTY:\n\t\t\treturn -EINVAL; /* set controlling term NI */\n\t\tcase TIOCGPGRP:\n\t\t\tverify_area((void *) arg,4);\n\t\t\tput_fs_long(tty->pgrp,(unsigned long *) arg);\n\t\t\treturn 0;\n\t\tcase TIOCSPGRP:\n\t\t\ttty->pgrp=get_fs_long((unsigned long *) arg);\n\t\t\treturn 0;\n\t\tcase TIOCOUTQ:\n\t\t\tverify_area((void *) arg,4);\n\t\t\tput_fs_long(CHARS(tty->write_q),(unsigned long *) arg);\n\t\t\treturn 0;\n\t\tcase TIOCINQ:\n\t\t\tverify_area((void *) arg,4);\n\t\t\tput_fs_long(CHARS(tty->secondary),\n\t\t\t\t(unsigned long *) arg);\n\t\t\treturn 0;\n\t\tcase TIOCSTI:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TIOCGWINSZ:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TIOCSWINSZ:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TIOCMGET:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TIOCMBIS:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TIOCMBIC:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TIOCMSET:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TIOCGSOFTCAR:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tcase TIOCSSOFTCAR:\n\t\t\treturn -EINVAL; /* not implemented */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}",
        "/*\n *  linux/kernel/console.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n *\tconsole.c\n *\n * This module implements the console io functions\n *\t'void con_init(void)'\n *\t'void con_write(struct tty_queue * queue)'\n * Hopefully this will be a rather complete VT102 implementation.\n *\n * Beeping thanks to John T Kohl.\n */\n\n/*\n *  NOTE!!! We sometimes disable and enable interrupts for a short while\n * (to put a word in video IO), but this will work even for keyboard\n * interrupts. We know interrupts aren't enabled when getting a keyboard\n * interrupt, as we use trap-gates. Hopefully all is well.\n */\n\n/*\n * Code to check for different video-cards mostly by Galen Hunt,\n * <g-hunt@ee.utah.edu>\n */\n\n#include <linux/sched.h>\n#include <linux/tty.h>\n#include <asm/io.h>\n#include <asm/system.h>\n\n/*\n * These are set up by the setup-routine at boot-time:\n */\n\n#define ORIG_X\t\t\t(*(unsigned char *)0x90000)\n#define ORIG_Y\t\t\t(*(unsigned char *)0x90001)\n#define ORIG_VIDEO_PAGE\t\t(*(unsigned short *)0x90004)\n#define ORIG_VIDEO_MODE\t\t((*(unsigned short *)0x90006) & 0xff)\n#define ORIG_VIDEO_COLS \t(((*(unsigned short *)0x90006) & 0xff00) >> 8)\n#define ORIG_VIDEO_LINES\t(25)\n#define ORIG_VIDEO_EGA_AX\t(*(unsigned short *)0x90008)\n#define ORIG_VIDEO_EGA_BX\t(*(unsigned short *)0x9000a)\n#define ORIG_VIDEO_EGA_CX\t(*(unsigned short *)0x9000c)\n\n#define VIDEO_TYPE_MDA\t\t0x10\t/* Monochrome Text Display\t*/\n#define VIDEO_TYPE_CGA\t\t0x11\t/* CGA Display \t\t\t*/\n#define VIDEO_TYPE_EGAM\t\t0x20\t/* EGA/VGA in Monochrome Mode\t*/\n#define VIDEO_TYPE_EGAC\t\t0x21\t/* EGA/VGA in Color Mode\t*/\n\n#define NPAR 16\n\nextern void keyboard_interrupt(void);\n\nstatic unsigned char\tvideo_type;\t\t/* Type of display being used\t*/\nstatic unsigned long\tvideo_num_columns;\t/* Number of text columns\t*/\nstatic unsigned long\tvideo_size_row;\t\t/* Bytes per row\t\t*/\nstatic unsigned long\tvideo_num_lines;\t/* Number of test lines\t\t*/\nstatic unsigned char\tvideo_page;\t\t/* Initial video page\t\t*/\nstatic unsigned long\tvideo_mem_start;\t/* Start of video RAM\t\t*/\nstatic unsigned long\tvideo_mem_end;\t\t/* End of video RAM (sort of)\t*/\nstatic unsigned short\tvideo_port_reg;\t\t/* Video register select port\t*/\nstatic unsigned short\tvideo_port_val;\t\t/* Video register value port\t*/\nstatic unsigned short\tvideo_erase_char;\t/* Char+Attrib to erase with\t*/\n\nstatic unsigned long\torigin;\t\t/* Used for EGA/VGA fast scroll\t*/\nstatic unsigned long\tscr_end;\t/* Used for EGA/VGA fast scroll\t*/\nstatic unsigned long\tpos;\nstatic unsigned long\tx,y;\nstatic unsigned long\ttop,bottom;\nstatic unsigned long\tstate=0;\nstatic unsigned long\tnpar,par[NPAR];\nstatic unsigned long\tques=0;\nstatic unsigned char\tattr=0x07;\n\nstatic void sysbeep(void);\n\n/*\n * this is what the terminal answers to a ESC-Z or csi0c\n * query (= vt100 response).\n */\n#define RESPONSE \"\\033[?1;2c\"\n\n/* NOTE! gotoxy thinks x==video_num_columns is ok */\nstatic inline void gotoxy(unsigned int new_x,unsigned int new_y)\n{\n\tif (new_x > video_num_columns || new_y >= video_num_lines)\n\t\treturn;\n\tx=new_x;\n\ty=new_y;\n\tpos=origin + y*video_size_row + (x<<1);\n}\n\nstatic inline void set_origin(void)\n{\n\tcli();\n\toutb_p(12, video_port_reg);\n\toutb_p(0xff&((origin-video_mem_start)>>9), video_port_val);\n\toutb_p(13, video_port_reg);\n\toutb_p(0xff&((origin-video_mem_start)>>1), video_port_val);\n\tsti();\n}\n\nstatic void scrup(void)\n{\n\tif (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)\n\t{\n\t\tif (!top && bottom == video_num_lines) {\n\t\t\torigin += video_size_row;\n\t\t\tpos += video_size_row;\n\t\t\tscr_end += video_size_row;\n\t\t\tif (scr_end > video_mem_end) {\n\t\t\t\t__asm__(\"cld\\n\\t\"\n\t\t\t\t\t\"rep\\n\\t\"\n\t\t\t\t\t\"movsl\\n\\t\"\n\t\t\t\t\t\"movl video_num_columns,%1\\n\\t\"\n\t\t\t\t\t\"rep\\n\\t\"\n\t\t\t\t\t\"stosw\"\n\t\t\t\t\t::\"a\" (video_erase_char),\n\t\t\t\t\t\"c\" ((video_num_lines-1)*video_num_columns>>1),\n\t\t\t\t\t\"D\" (video_mem_start),\n\t\t\t\t\t\"S\" (origin)\n\t\t\t\t\t);\n\t\t\t\tscr_end -= origin-video_mem_start;\n\t\t\t\tpos -= origin-video_mem_start;\n\t\t\t\torigin = video_mem_start;\n\t\t\t} else {\n\t\t\t\t__asm__(\"cld\\n\\t\"\n\t\t\t\t\t\"rep\\n\\t\"\n\t\t\t\t\t\"stosw\"\n\t\t\t\t\t::\"a\" (video_erase_char),\n\t\t\t\t\t\"c\" (video_num_columns),\n\t\t\t\t\t\"D\" (scr_end-video_size_row)\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tset_origin();\n\t\t} else {\n\t\t\t__asm__(\"cld\\n\\t\"\n\t\t\t\t\"rep\\n\\t\"\n\t\t\t\t\"movsl\\n\\t\"\n\t\t\t\t\"movl video_num_columns,%%ecx\\n\\t\"\n\t\t\t\t\"rep\\n\\t\"\n\t\t\t\t\"stosw\"\n\t\t\t\t::\"a\" (video_erase_char),\n\t\t\t\t\"c\" ((bottom-top-1)*video_num_columns>>1),\n\t\t\t\t\"D\" (origin+video_size_row*top),\n\t\t\t\t\"S\" (origin+video_size_row*(top+1))\n\t\t\t\t);\n\t\t}\n\t}\n\telse\t\t/* Not EGA/VGA */\n\t{\n\t\t__asm__(\"cld\\n\\t\"\n\t\t\t\"rep\\n\\t\"\n\t\t\t\"movsl\\n\\t\"\n\t\t\t\"movl video_num_columns,%%ecx\\n\\t\"\n\t\t\t\"rep\\n\\t\"\n\t\t\t\"stosw\"\n\t\t\t::\"a\" (video_erase_char),\n\t\t\t\"c\" ((bottom-top-1)*video_num_columns>>1),\n\t\t\t\"D\" (origin+video_size_row*top),\n\t\t\t\"S\" (origin+video_size_row*(top+1))\n\t\t\t);\n\t}\n}\n\nstatic void scrdown(void)\n{\n\tif (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)\n\t{\n\t\t__asm__(\"std\\n\\t\"\n\t\t\t\"rep\\n\\t\"\n\t\t\t\"movsl\\n\\t\"\n\t\t\t\"addl $2,%%edi\\n\\t\"\t/* %edi has been decremented by 4 */\n\t\t\t\"movl video_num_columns,%%ecx\\n\\t\"\n\t\t\t\"rep\\n\\t\"\n\t\t\t\"stosw\"\n\t\t\t::\"a\" (video_erase_char),\n\t\t\t\"c\" ((bottom-top-1)*video_num_columns>>1),\n\t\t\t\"D\" (origin+video_size_row*bottom-4),\n\t\t\t\"S\" (origin+video_size_row*(bottom-1)-4)\n\t\t\t);\n\t}\n\telse\t\t/* Not EGA/VGA */\n\t{\n\t\t__asm__(\"std\\n\\t\"\n\t\t\t\"rep\\n\\t\"\n\t\t\t\"movsl\\n\\t\"\n\t\t\t\"addl $2,%%edi\\n\\t\"\t/* %edi has been decremented by 4 */\n\t\t\t\"movl video_num_columns,%%ecx\\n\\t\"\n\t\t\t\"rep\\n\\t\"\n\t\t\t\"stosw\"\n\t\t\t::\"a\" (video_erase_char),\n\t\t\t\"c\" ((bottom-top-1)*video_num_columns>>1),\n\t\t\t\"D\" (origin+video_size_row*bottom-4),\n\t\t\t\"S\" (origin+video_size_row*(bottom-1)-4)\n\t\t\t);\n\t}\n}\n\nstatic void lf(void)\n{\n\tif (y+1<bottom) {\n\t\ty++;\n\t\tpos += video_size_row;\n\t\treturn;\n\t}\n\tscrup();\n}\n\nstatic void ri(void)\n{\n\tif (y>top) {\n\t\ty--;\n\t\tpos -= video_size_row;\n\t\treturn;\n\t}\n\tscrdown();\n}\n\nstatic void cr(void)\n{\n\tpos -= x<<1;\n\tx=0;\n}\n\nstatic void del(void)\n{\n\tif (x) {\n\t\tpos -= 2;\n\t\tx--;\n\t\t*(unsigned short *)pos = video_erase_char;\n\t}\n}\n\nstatic void csi_J(int par)\n{\n\tlong count;\n\tlong start;\n\n\tswitch (par) {\n\t\tcase 0:\t/* erase from cursor to end of display */\n\t\t\tcount = (scr_end-pos)>>1;\n\t\t\tstart = pos;\n\t\t\tbreak;\n\t\tcase 1:\t/* erase from start to cursor */\n\t\t\tcount = (pos-origin)>>1;\n\t\t\tstart = origin;\n\t\t\tbreak;\n\t\tcase 2: /* erase whole display */\n\t\t\tcount = video_num_columns * video_num_lines;\n\t\t\tstart = origin;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\t__asm__(\"cld\\n\\t\"\n\t\t\"rep\\n\\t\"\n\t\t\"stosw\\n\\t\"\n\t\t::\"c\" (count),\n\t\t\"D\" (start),\"a\" (video_erase_char)\n\t\t);\n}\n\nstatic void csi_K(int par)\n{\n\tlong count;\n\tlong start;\n\n\tswitch (par) {\n\t\tcase 0:\t/* erase from cursor to end of line */\n\t\t\tif (x>=video_num_columns)\n\t\t\t\treturn;\n\t\t\tcount = video_num_columns-x;\n\t\t\tstart = pos;\n\t\t\tbreak;\n\t\tcase 1:\t/* erase from start of line to cursor */\n\t\t\tstart = pos - (x<<1);\n\t\t\tcount = (x<video_num_columns)?x:video_num_columns;\n\t\t\tbreak;\n\t\tcase 2: /* erase whole line */\n\t\t\tstart = pos - (x<<1);\n\t\t\tcount = video_num_columns;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\t__asm__(\"cld\\n\\t\"\n\t\t\"rep\\n\\t\"\n\t\t\"stosw\\n\\t\"\n\t\t::\"c\" (count),\n\t\t\"D\" (start),\"a\" (video_erase_char)\n\t\t);\n}\n\nvoid csi_m(void)\n{\n\tint i;\n\n\tfor (i=0;i<=npar;i++)\n\t\tswitch (par[i]) {\n\t\t\tcase 0:attr=0x07;break;\n\t\t\tcase 1:attr=0x0f;break;\n\t\t\tcase 4:attr=0x0f;break;\n\t\t\tcase 7:attr=0x70;break;\n\t\t\tcase 27:attr=0x07;break;\n\t\t}\n}\n\nstatic inline void set_cursor(void)\n{\n\tcli();\n\toutb_p(14, video_port_reg);\n\toutb_p(0xff&((pos-video_mem_start)>>9), video_port_val);\n\toutb_p(15, video_port_reg);\n\toutb_p(0xff&((pos-video_mem_start)>>1), video_port_val);\n\tsti();\n}\n\nstatic void respond(struct tty_struct * tty)\n{\n\tchar * p = RESPONSE;\n\n\tcli();\n\twhile (*p) {\n\t\tPUTCH(*p,tty->read_q);\n\t\tp++;\n\t}\n\tsti();\n\tcopy_to_cooked(tty);\n}\n\nstatic void insert_char(void)\n{\n\tint i=x;\n\tunsigned short tmp, old = video_erase_char;\n\tunsigned short * p = (unsigned short *) pos;\n\n\twhile (i++<video_num_columns) {\n\t\ttmp=*p;\n\t\t*p=old;\n\t\told=tmp;\n\t\tp++;\n\t}\n}\n\nstatic void insert_line(void)\n{\n\tint oldtop,oldbottom;\n\n\toldtop=top;\n\toldbottom=bottom;\n\ttop=y;\n\tbottom = video_num_lines;\n\tscrdown();\n\ttop=oldtop;\n\tbottom=oldbottom;\n}\n\nstatic void delete_char(void)\n{\n\tint i;\n\tunsigned short * p = (unsigned short *) pos;\n\n\tif (x>=video_num_columns)\n\t\treturn;\n\ti = x;\n\twhile (++i < video_num_columns) {\n\t\t*p = *(p+1);\n\t\tp++;\n\t}\n\t*p = video_erase_char;\n}\n\nstatic void delete_line(void)\n{\n\tint oldtop,oldbottom;\n\n\toldtop=top;\n\toldbottom=bottom;\n\ttop=y;\n\tbottom = video_num_lines;\n\tscrup();\n\ttop=oldtop;\n\tbottom=oldbottom;\n}\n\nstatic void csi_at(unsigned int nr)\n{\n\tif (nr > video_num_columns)\n\t\tnr = video_num_columns;\n\telse if (!nr)\n\t\tnr = 1;\n\twhile (nr--)\n\t\tinsert_char();\n}\n\nstatic void csi_L(unsigned int nr)\n{\n\tif (nr > video_num_lines)\n\t\tnr = video_num_lines;\n\telse if (!nr)\n\t\tnr = 1;\n\twhile (nr--)\n\t\tinsert_line();\n}\n\nstatic void csi_P(unsigned int nr)\n{\n\tif (nr > video_num_columns)\n\t\tnr = video_num_columns;\n\telse if (!nr)\n\t\tnr = 1;\n\twhile (nr--)\n\t\tdelete_char();\n}\n\nstatic void csi_M(unsigned int nr)\n{\n\tif (nr > video_num_lines)\n\t\tnr = video_num_lines;\n\telse if (!nr)\n\t\tnr=1;\n\twhile (nr--)\n\t\tdelete_line();\n}\n\nstatic int saved_x=0;\nstatic int saved_y=0;\n\nstatic void save_cur(void)\n{\n\tsaved_x=x;\n\tsaved_y=y;\n}\n\nstatic void restore_cur(void)\n{\n\tgotoxy(saved_x, saved_y);\n}\n\nvoid con_write(struct tty_struct * tty)\n{\n\tint nr;\n\tchar c;\n\n\tnr = CHARS(tty->write_q);\n\twhile (nr--) {\n\t\tGETCH(tty->write_q,c);\n\t\tswitch(state) {\n\t\t\tcase 0:\n\t\t\t\tif (c>31 && c<127) {\n\t\t\t\t\tif (x>=video_num_columns) {\n\t\t\t\t\t\tx -= video_num_columns;\n\t\t\t\t\t\tpos -= video_size_row;\n\t\t\t\t\t\tlf();\n\t\t\t\t\t}\n\t\t\t\t\t__asm__(\"movb attr,%%ah\\n\\t\"\n\t\t\t\t\t\t\"movw %%ax,%1\\n\\t\"\n\t\t\t\t\t\t::\"a\" (c),\"m\" (*(short *)pos)\n\t\t\t\t\t\t);\n\t\t\t\t\tpos += 2;\n\t\t\t\t\tx++;\n\t\t\t\t} else if (c==27)\n\t\t\t\t\tstate=1;\n\t\t\t\telse if (c==10 || c==11 || c==12)\n\t\t\t\t\tlf();\n\t\t\t\telse if (c==13)\n\t\t\t\t\tcr();\n\t\t\t\telse if (c==ERASE_CHAR(tty))\n\t\t\t\t\tdel();\n\t\t\t\telse if (c==8) {\n\t\t\t\t\tif (x) {\n\t\t\t\t\t\tx--;\n\t\t\t\t\t\tpos -= 2;\n\t\t\t\t\t}\n\t\t\t\t} else if (c==9) {\n\t\t\t\t\tc=8-(x&7);\n\t\t\t\t\tx += c;\n\t\t\t\t\tpos += c<<1;\n\t\t\t\t\tif (x>video_num_columns) {\n\t\t\t\t\t\tx -= video_num_columns;\n\t\t\t\t\t\tpos -= video_size_row;\n\t\t\t\t\t\tlf();\n\t\t\t\t\t}\n\t\t\t\t\tc=9;\n\t\t\t\t} else if (c==7)\n\t\t\t\t\tsysbeep();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tstate=0;\n\t\t\t\tif (c=='[')\n\t\t\t\t\tstate=2;\n\t\t\t\telse if (c=='E')\n\t\t\t\t\tgotoxy(0,y+1);\n\t\t\t\telse if (c=='M')\n\t\t\t\t\tri();\n\t\t\t\telse if (c=='D')\n\t\t\t\t\tlf();\n\t\t\t\telse if (c=='Z')\n\t\t\t\t\trespond(tty);\n\t\t\t\telse if (x=='7')\n\t\t\t\t\tsave_cur();\n\t\t\t\telse if (x=='8')\n\t\t\t\t\trestore_cur();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tfor(npar=0;npar<NPAR;npar++)\n\t\t\t\t\tpar[npar]=0;\n\t\t\t\tnpar=0;\n\t\t\t\tstate=3;\n\t\t\t\tif ((ques=(c=='?')))\n\t\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (c==';' && npar<NPAR-1) {\n\t\t\t\t\tnpar++;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (c>='0' && c<='9') {\n\t\t\t\t\tpar[npar]=10*par[npar]+c-'0';\n\t\t\t\t\tbreak;\n\t\t\t\t} else state=4;\n\t\t\tcase 4:\n\t\t\t\tstate=0;\n\t\t\t\tswitch(c) {\n\t\t\t\t\tcase 'G': case '`':\n\t\t\t\t\t\tif (par[0]) par[0]--;\n\t\t\t\t\t\tgotoxy(par[0],y);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tif (!par[0]) par[0]++;\n\t\t\t\t\t\tgotoxy(x,y-par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B': case 'e':\n\t\t\t\t\t\tif (!par[0]) par[0]++;\n\t\t\t\t\t\tgotoxy(x,y+par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C': case 'a':\n\t\t\t\t\t\tif (!par[0]) par[0]++;\n\t\t\t\t\t\tgotoxy(x+par[0],y);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\t\tif (!par[0]) par[0]++;\n\t\t\t\t\t\tgotoxy(x-par[0],y);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\tif (!par[0]) par[0]++;\n\t\t\t\t\t\tgotoxy(0,y+par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (!par[0]) par[0]++;\n\t\t\t\t\t\tgotoxy(0,y-par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tif (par[0]) par[0]--;\n\t\t\t\t\t\tgotoxy(x,par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'H': case 'f':\n\t\t\t\t\t\tif (par[0]) par[0]--;\n\t\t\t\t\t\tif (par[1]) par[1]--;\n\t\t\t\t\t\tgotoxy(par[1],par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tcsi_J(par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'K':\n\t\t\t\t\t\tcsi_K(par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tcsi_L(par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tcsi_M(par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'P':\n\t\t\t\t\t\tcsi_P(par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tcsi_at(par[0]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tcsi_m();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\tif (par[0]) par[0]--;\n\t\t\t\t\t\tif (!par[1]) par[1] = video_num_lines;\n\t\t\t\t\t\tif (par[0] < par[1] &&\n\t\t\t\t\t\t    par[1] <= video_num_lines) {\n\t\t\t\t\t\t\ttop=par[0];\n\t\t\t\t\t\t\tbottom=par[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tsave_cur();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\trestore_cur();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\tset_cursor();\n}\n\n/*\n *  void con_init(void);\n *\n * This routine initalizes console interrupts, and does nothing\n * else. If you want the screen to clear, call tty_write with\n * the appropriate escape-sequece.\n *\n * Reads the information preserved by setup.s to determine the current display\n * type and sets everything accordingly.\n */\nvoid con_init(void)\n{\n\tregister unsigned char a;\n\tchar *display_desc = \"????\";\n\tchar *display_ptr;\n\n\tvideo_num_columns = ORIG_VIDEO_COLS;\n\tvideo_size_row = video_num_columns * 2;\n\tvideo_num_lines = ORIG_VIDEO_LINES;\n\tvideo_page = ORIG_VIDEO_PAGE;\n\tvideo_erase_char = 0x0720;\n\t\n\tif (ORIG_VIDEO_MODE == 7)\t\t\t/* Is this a monochrome display? */\n\t{\n\t\tvideo_mem_start = 0xb0000;\n\t\tvideo_port_reg = 0x3b4;\n\t\tvideo_port_val = 0x3b5;\n\t\tif ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)\n\t\t{\n\t\t\tvideo_type = VIDEO_TYPE_EGAM;\n\t\t\tvideo_mem_end = 0xb8000;\n\t\t\tdisplay_desc = \"EGAm\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvideo_type = VIDEO_TYPE_MDA;\n\t\t\tvideo_mem_end\t= 0xb2000;\n\t\t\tdisplay_desc = \"*MDA\";\n\t\t}\n\t}\n\telse\t\t\t\t\t\t\t\t/* If not, it is color. */\n\t{\n\t\tvideo_mem_start = 0xb8000;\n\t\tvideo_port_reg\t= 0x3d4;\n\t\tvideo_port_val\t= 0x3d5;\n\t\tif ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)\n\t\t{\n\t\t\tvideo_type = VIDEO_TYPE_EGAC;\n\t\t\tvideo_mem_end = 0xbc000;\n\t\t\tdisplay_desc = \"EGAc\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvideo_type = VIDEO_TYPE_CGA;\n\t\t\tvideo_mem_end = 0xba000;\n\t\t\tdisplay_desc = \"*CGA\";\n\t\t}\n\t}\n\n\t/* Let the user known what kind of display driver we are using */\n\t\n\tdisplay_ptr = ((char *)video_mem_start) + video_size_row - 8;\n\twhile (*display_desc)\n\t{\n\t\t*display_ptr++ = *display_desc++;\n\t\tdisplay_ptr++;\n\t}\n\t\n\t/* Initialize the variables used for scrolling (mostly EGA/VGA)\t*/\n\t\n\torigin\t= video_mem_start;\n\tscr_end\t= video_mem_start + video_num_lines * video_size_row;\n\ttop\t= 0;\n\tbottom\t= video_num_lines;\n\n\tgotoxy(ORIG_X,ORIG_Y);\n\tset_trap_gate(0x21,&keyboard_interrupt);\n\toutb_p(inb_p(0x21)&0xfd,0x21);\n\ta=inb_p(0x61);\n\toutb_p(a|0x80,0x61);\n\toutb(a,0x61);\n}\n/* from bsd-net-2: */\n\nvoid sysbeepstop(void)\n{\n\t/* disable counter 2 */\n\toutb(inb_p(0x61)&0xFC, 0x61);\n}\n\nint beepcount = 0;\n\nstatic void sysbeep(void)\n{\n\t/* enable counter 2 */\n\toutb_p(inb_p(0x61)|3, 0x61);\n\t/* set command for counter 2, 2 byte write */\n\toutb_p(0xB6, 0x43);\n\t/* send 0x637 for 750 HZ */\n\toutb_p(0x37, 0x42);\n\toutb(0x06, 0x42);\n\t/* 1/8 second */\n\tbeepcount = HZ/8;\t\n}",
        "/*\n *  linux/kernel/tty_io.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * 'tty_io.c' gives an orthogonal feeling to tty's, be they consoles\n * or rs-channels. It also implements echoing, cooked mode etc.\n *\n * Kill-line thanks to John T Kohl.\n */\n#include <ctype.h>\n#include <errno.h>\n#include <signal.h>\n\n#define ALRMMASK (1<<(SIGALRM-1))\n#define KILLMASK (1<<(SIGKILL-1))\n#define INTMASK (1<<(SIGINT-1))\n#define QUITMASK (1<<(SIGQUIT-1))\n#define TSTPMASK (1<<(SIGTSTP-1))\n\n#include <linux/sched.h>\n#include <linux/tty.h>\n#include <asm/segment.h>\n#include <asm/system.h>\n\n#define _L_FLAG(tty,f)\t((tty)->termios.c_lflag & f)\n#define _I_FLAG(tty,f)\t((tty)->termios.c_iflag & f)\n#define _O_FLAG(tty,f)\t((tty)->termios.c_oflag & f)\n\n#define L_CANON(tty)\t_L_FLAG((tty),ICANON)\n#define L_ISIG(tty)\t_L_FLAG((tty),ISIG)\n#define L_ECHO(tty)\t_L_FLAG((tty),ECHO)\n#define L_ECHOE(tty)\t_L_FLAG((tty),ECHOE)\n#define L_ECHOK(tty)\t_L_FLAG((tty),ECHOK)\n#define L_ECHOCTL(tty)\t_L_FLAG((tty),ECHOCTL)\n#define L_ECHOKE(tty)\t_L_FLAG((tty),ECHOKE)\n\n#define I_UCLC(tty)\t_I_FLAG((tty),IUCLC)\n#define I_NLCR(tty)\t_I_FLAG((tty),INLCR)\n#define I_CRNL(tty)\t_I_FLAG((tty),ICRNL)\n#define I_NOCR(tty)\t_I_FLAG((tty),IGNCR)\n\n#define O_POST(tty)\t_O_FLAG((tty),OPOST)\n#define O_NLCR(tty)\t_O_FLAG((tty),ONLCR)\n#define O_CRNL(tty)\t_O_FLAG((tty),OCRNL)\n#define O_NLRET(tty)\t_O_FLAG((tty),ONLRET)\n#define O_LCUC(tty)\t_O_FLAG((tty),OLCUC)\n\nstruct tty_struct tty_table[] = {\n\t{\n\t\t{ICRNL,\t\t/* change incoming CR to NL */\n\t\tOPOST|ONLCR,\t/* change outgoing NL to CRNL */\n\t\t0,\n\t\tISIG | ICANON | ECHO | ECHOCTL | ECHOKE,\n\t\t0,\t\t/* console termio */\n\t\tINIT_C_CC},\n\t\t0,\t\t\t/* initial pgrp */\n\t\t0,\t\t\t/* initial stopped */\n\t\tcon_write,\n\t\t{0,0,0,0,\"\"},\t\t/* console read-queue */\n\t\t{0,0,0,0,\"\"},\t\t/* console write-queue */\n\t\t{0,0,0,0,\"\"}\t\t/* console secondary queue */\n\t},{\n\t\t{0, /* no translation */\n\t\t0,  /* no translation */\n\t\tB2400 | CS8,\n\t\t0,\n\t\t0,\n\t\tINIT_C_CC},\n\t\t0,\n\t\t0,\n\t\trs_write,\n\t\t{0x3f8,0,0,0,\"\"},\t\t/* rs 1 */\n\t\t{0x3f8,0,0,0,\"\"},\n\t\t{0,0,0,0,\"\"}\n\t},{\n\t\t{0, /* no translation */\n\t\t0,  /* no translation */\n\t\tB2400 | CS8,\n\t\t0,\n\t\t0,\n\t\tINIT_C_CC},\n\t\t0,\n\t\t0,\n\t\trs_write,\n\t\t{0x2f8,0,0,0,\"\"},\t\t/* rs 2 */\n\t\t{0x2f8,0,0,0,\"\"},\n\t\t{0,0,0,0,\"\"}\n\t}\n};\n\n/*\n * these are the tables used by the machine code handlers.\n * you can implement pseudo-tty's or something by changing\n * them. Currently not done.\n */\nstruct tty_queue * table_list[]={\n\t&tty_table[0].read_q, &tty_table[0].write_q,\n\t&tty_table[1].read_q, &tty_table[1].write_q,\n\t&tty_table[2].read_q, &tty_table[2].write_q\n\t};\n\nvoid tty_init(void)\n{\n\trs_init();\n\tcon_init();\n}\n\nvoid tty_intr(struct tty_struct * tty, int mask)\n{\n\tint i;\n\n\tif (tty->pgrp <= 0)\n\t\treturn;\n\tfor (i=0;i<NR_TASKS;i++)\n\t\tif (task[i] && task[i]->pgrp==tty->pgrp)\n\t\t\ttask[i]->signal |= mask;\n}\n\nstatic void sleep_if_empty(struct tty_queue * queue)\n{\n\tcli();\n\twhile (!current->signal && EMPTY(*queue))\n\t\tinterruptible_sleep_on(&queue->proc_list);\n\tsti();\n}\n\nstatic void sleep_if_full(struct tty_queue * queue)\n{\n\tif (!FULL(*queue))\n\t\treturn;\n\tcli();\n\twhile (!current->signal && LEFT(*queue)<128)\n\t\tinterruptible_sleep_on(&queue->proc_list);\n\tsti();\n}\n\nvoid wait_for_keypress(void)\n{\n\tsleep_if_empty(&tty_table[0].secondary);\n}\n\nvoid copy_to_cooked(struct tty_struct * tty)\n{\n\tsigned char c;\n\n\twhile (!EMPTY(tty->read_q) && !FULL(tty->secondary)) {\n\t\tGETCH(tty->read_q,c);\n\t\tif (c==13)\n\t\t\tif (I_CRNL(tty))\n\t\t\t\tc=10;\n\t\t\telse if (I_NOCR(tty))\n\t\t\t\tcontinue;\n\t\t\telse ;\n\t\telse if (c==10 && I_NLCR(tty))\n\t\t\tc=13;\n\t\tif (I_UCLC(tty))\n\t\t\tc=tolower(c);\n\t\tif (L_CANON(tty)) {\n\t\t\tif (c==KILL_CHAR(tty)) {\n\t\t\t\t/* deal with killing the input line */\n\t\t\t\twhile(!(EMPTY(tty->secondary) ||\n\t\t\t\t        (c=LAST(tty->secondary))==10 ||\n\t\t\t\t        c==EOF_CHAR(tty))) {\n\t\t\t\t\tif (L_ECHO(tty)) {\n\t\t\t\t\t\tif (c<32)\n\t\t\t\t\t\t\tPUTCH(127,tty->write_q);\n\t\t\t\t\t\tPUTCH(127,tty->write_q);\n\t\t\t\t\t\ttty->write(tty);\n\t\t\t\t\t}\n\t\t\t\t\tDEC(tty->secondary.head);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c==ERASE_CHAR(tty)) {\n\t\t\t\tif (EMPTY(tty->secondary) ||\n\t\t\t\t   (c=LAST(tty->secondary))==10 ||\n\t\t\t\t   c==EOF_CHAR(tty))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (L_ECHO(tty)) {\n\t\t\t\t\tif (c<32)\n\t\t\t\t\t\tPUTCH(127,tty->write_q);\n\t\t\t\t\tPUTCH(127,tty->write_q);\n\t\t\t\t\ttty->write(tty);\n\t\t\t\t}\n\t\t\t\tDEC(tty->secondary.head);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c==STOP_CHAR(tty)) {\n\t\t\t\ttty->stopped=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c==START_CHAR(tty)) {\n\t\t\t\ttty->stopped=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (L_ISIG(tty)) {\n\t\t\tif (c==INTR_CHAR(tty)) {\n\t\t\t\ttty_intr(tty,INTMASK);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c==QUIT_CHAR(tty)) {\n\t\t\t\ttty_intr(tty,QUITMASK);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (c==10 || c==EOF_CHAR(tty))\n\t\t\ttty->secondary.data++;\n\t\tif (L_ECHO(tty)) {\n\t\t\tif (c==10) {\n\t\t\t\tPUTCH(10,tty->write_q);\n\t\t\t\tPUTCH(13,tty->write_q);\n\t\t\t} else if (c<32) {\n\t\t\t\tif (L_ECHOCTL(tty)) {\n\t\t\t\t\tPUTCH('^',tty->write_q);\n\t\t\t\t\tPUTCH(c+64,tty->write_q);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tPUTCH(c,tty->write_q);\n\t\t\ttty->write(tty);\n\t\t}\n\t\tPUTCH(c,tty->secondary);\n\t}\n\twake_up(&tty->secondary.proc_list);\n}\n\nint tty_read(unsigned channel, char * buf, int nr)\n{\n\tstruct tty_struct * tty;\n\tchar c, * b=buf;\n\tint minimum,time,flag=0;\n\tlong oldalarm;\n\n\tif (channel>2 || nr<0) return -1;\n\ttty = &tty_table[channel];\n\toldalarm = current->alarm;\n\ttime = 10L*tty->termios.c_cc[VTIME];\n\tminimum = tty->termios.c_cc[VMIN];\n\tif (time && !minimum) {\n\t\tminimum=1;\n\t\tif ((flag=(!oldalarm || time+jiffies<oldalarm)))\n\t\t\tcurrent->alarm = time+jiffies;\n\t}\n\tif (minimum>nr)\n\t\tminimum=nr;\n\twhile (nr>0) {\n\t\tif (flag && (current->signal & ALRMMASK)) {\n\t\t\tcurrent->signal &= ~ALRMMASK;\n\t\t\tbreak;\n\t\t}\n\t\tif (current->signal)\n\t\t\tbreak;\n\t\tif (EMPTY(tty->secondary) || (L_CANON(tty) &&\n\t\t!tty->secondary.data && LEFT(tty->secondary)>20)) {\n\t\t\tsleep_if_empty(&tty->secondary);\n\t\t\tcontinue;\n\t\t}\n\t\tdo {\n\t\t\tGETCH(tty->secondary,c);\n\t\t\tif (c==EOF_CHAR(tty) || c==10)\n\t\t\t\ttty->secondary.data--;\n\t\t\tif (c==EOF_CHAR(tty) && L_CANON(tty))\n\t\t\t\treturn (b-buf);\n\t\t\telse {\n\t\t\t\tput_fs_byte(c,b++);\n\t\t\t\tif (!--nr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (nr>0 && !EMPTY(tty->secondary));\n\t\tif (time && !L_CANON(tty)) {\n\t\t\tif ((flag=(!oldalarm || time+jiffies<oldalarm)))\n\t\t\t\tcurrent->alarm = time+jiffies;\n\t\t\telse\n\t\t\t\tcurrent->alarm = oldalarm;\n\t\t}\n\t\tif (L_CANON(tty)) {\n\t\t\tif (b-buf)\n\t\t\t\tbreak;\n\t\t} else if (b-buf >= minimum)\n\t\t\tbreak;\n\t}\n\tcurrent->alarm = oldalarm;\n\tif (current->signal && !(b-buf))\n\t\treturn -EINTR;\n\treturn (b-buf);\n}\n\nint tty_write(unsigned channel, char * buf, int nr)\n{\n\tstatic int cr_flag=0;\n\tstruct tty_struct * tty;\n\tchar c, *b=buf;\n\n\tif (channel>2 || nr<0) return -1;\n\ttty = channel + tty_table;\n\twhile (nr>0) {\n\t\tsleep_if_full(&tty->write_q);\n\t\tif (current->signal)\n\t\t\tbreak;\n\t\twhile (nr>0 && !FULL(tty->write_q)) {\n\t\t\tc=get_fs_byte(b);\n\t\t\tif (O_POST(tty)) {\n\t\t\t\tif (c=='\\r' && O_CRNL(tty))\n\t\t\t\t\tc='\\n';\n\t\t\t\telse if (c=='\\n' && O_NLRET(tty))\n\t\t\t\t\tc='\\r';\n\t\t\t\tif (c=='\\n' && !cr_flag && O_NLCR(tty)) {\n\t\t\t\t\tcr_flag = 1;\n\t\t\t\t\tPUTCH(13,tty->write_q);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (O_LCUC(tty))\n\t\t\t\t\tc=toupper(c);\n\t\t\t}\n\t\t\tb++; nr--;\n\t\t\tcr_flag = 0;\n\t\t\tPUTCH(c,tty->write_q);\n\t\t}\n\t\ttty->write(tty);\n\t\tif (nr>0)\n\t\t\tschedule();\n\t}\n\treturn (b-buf);\n}\n\n/*\n * Jeh, sometimes I really like the 386.\n * This routine is called from an interrupt,\n * and there should be absolutely no problem\n * with sleeping even in an interrupt (I hope).\n * Of course, if somebody proves me wrong, I'll\n * hate intel for all time :-). We'll have to\n * be careful and see to reinstating the interrupt\n * chips before calling this, though.\n *\n * I don't think we sleep here under normal circumstances\n * anyway, which is good, as the task sleeping might be\n * totally innocent.\n */\nvoid do_tty_interrupt(int tty)\n{\n\tcopy_to_cooked(tty_table+tty);\n}\n\nvoid chr_dev_init(void)\n{\n}",
        "/*\n *  linux/kernel/blk_drv/ramdisk.c\n *\n *  Written by Theodore Ts'o, 12/2/91\n */\n\n#include <string.h>\n\n#include <linux/config.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <asm/system.h>\n#include <asm/segment.h>\n#include <asm/memory.h>\n\n#define MAJOR_NR 1\n#include \"blk.h\"\n\nchar\t*rd_start;\nint\trd_length = 0;\n\nvoid do_rd_request(void)\n{\n\tint\tlen;\n\tchar\t*addr;\n\n\tINIT_REQUEST;\n\taddr = rd_start + (CURRENT->sector << 9);\n\tlen = CURRENT->nr_sectors << 9;\n\tif ((MINOR(CURRENT->dev) != 1) || (addr+len > rd_start+rd_length)) {\n\t\tend_request(0);\n\t\tgoto repeat;\n\t}\n\tif (CURRENT-> cmd == WRITE) {\n\t\t(void) memcpy(addr,\n\t\t\t      CURRENT->buffer,\n\t\t\t      len);\n\t} else if (CURRENT->cmd == READ) {\n\t\t(void) memcpy(CURRENT->buffer, \n\t\t\t      addr,\n\t\t\t      len);\n\t} else\n\t\tpanic(\"unknown ramdisk-command\");\n\tend_request(1);\n\tgoto repeat;\n}\n\n/*\n * Returns amount of memory which needs to be reserved.\n */\nlong rd_init(long mem_start, int length)\n{\n\tint\ti;\n\tchar\t*cp;\n\n\tblk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;\n\trd_start = (char *) mem_start;\n\trd_length = length;\n\tcp = rd_start;\n\tfor (i=0; i < length; i++)\n\t\t*cp++ = '\\0';\n\treturn(length);\n}\n\n#ifdef RAMDISK_START\n#define ramdisk_start RAMDISK_START\n#else\n#define ramdisk_start 256 /* Start at block 256 by default */\n#endif\n\n/*\n * If the root device is the ram disk, try to load it.\n * In order to do this, the root device is originally set to the\n * floppy, and we later change it to be ram disk.\n */\nvoid rd_load(void)\n{\n\tstruct buffer_head *bh;\n\tstruct super_block\ts;\n\tint\t\tblock = ramdisk_start;\n\tint\t\ti = 1;\n\tint\t\tnblocks;\n\tchar\t\t*cp;\t\t/* Move pointer */\n\t\n\tif (!rd_length)\n\t\treturn;\n\tprintk(\"Ram disk: %d bytes, starting at 0x%x\\n\", rd_length,\n\t\t(int) rd_start);\n\tif (MAJOR(ROOT_DEV) != 2)\n\t\treturn;\n\tbh = breada(ROOT_DEV,block+1,block,block+2,-1);\n\tif (!bh) {\n\t\tprintk(\"Disk error while looking for ramdisk!\\n\");\n\t\treturn;\n\t}\n\t*((struct d_super_block *) &s) = *((struct d_super_block *) bh->b_data);\n\tbrelse(bh);\n\tif (s.s_magic != SUPER_MAGIC)\n\t\t/* No ram disk image present, assume normal floppy boot */\n\t\treturn;\n\tnblocks = s.s_nzones << s.s_log_zone_size;\n\tif (nblocks > (rd_length >> BLOCK_SIZE_BITS)) {\n\t\tprintk(\"Ram disk image too big!  (%d blocks, %d avail)\\n\", \n\t\t\tnblocks, rd_length >> BLOCK_SIZE_BITS);\n\t\treturn;\n\t}\n\tprintk(\"Loading %d bytes into ram disk... 0000k\", \n\t\tnblocks << BLOCK_SIZE_BITS);\n\tcp = rd_start;\n\twhile (nblocks) {\n\t\tif (nblocks > 2) \n\t\t\tbh = breada(ROOT_DEV, block, block+1, block+2, -1);\n\t\telse\n\t\t\tbh = bread(ROOT_DEV, block);\n\t\tif (!bh) {\n\t\t\tprintk(\"I/O error on block %d, aborting load\\n\", \n\t\t\t\tblock);\n\t\t\treturn;\n\t\t}\n\t\t(void) memcpy(cp, bh->b_data, BLOCK_SIZE);\n\t\tbrelse(bh);\n\t\tprintk(\"\\010\\010\\010\\010\\010%4dk\",i);\n\t\tcp += BLOCK_SIZE;\n\t\tblock++;\n\t\tnblocks--;\n\t\ti++;\n\t}\n\tprintk(\"\\010\\010\\010\\010\\010done \\n\");\n\tROOT_DEV=0x0101;\n}",
        "/*\n *  linux/kernel/blk_dev/ll_rw.c\n *\n * (C) 1991 Linus Torvalds\n */\n\n/*\n * This handles all read/write requests to block devices\n */\n#include <errno.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/system.h>\n\n#include \"blk.h\"\n\n/*\n * The request-struct contains all necessary data\n * to load a nr of sectors into memory\n */\nstruct request request[NR_REQUEST];\n\n/*\n * used to wait on when there are no free requests\n */\nstruct task_struct * wait_for_request = NULL;\n\n/* blk_dev_struct is:\n *\tdo_request-address\n *\tnext-request\n */\nstruct blk_dev_struct blk_dev[NR_BLK_DEV] = {\n\t{ NULL, NULL },\t\t/* no_dev */\n\t{ NULL, NULL },\t\t/* dev mem */\n\t{ NULL, NULL },\t\t/* dev fd */\n\t{ NULL, NULL },\t\t/* dev hd */\n\t{ NULL, NULL },\t\t/* dev ttyx */\n\t{ NULL, NULL },\t\t/* dev tty */\n\t{ NULL, NULL }\t\t/* dev lp */\n};\n\nstatic inline void lock_buffer(struct buffer_head * bh)\n{\n\tcli();\n\twhile (bh->b_lock)\n\t\tsleep_on(&bh->b_wait);\n\tbh->b_lock=1;\n\tsti();\n}\n\nstatic inline void unlock_buffer(struct buffer_head * bh)\n{\n\tif (!bh->b_lock)\n\t\tprintk(\"ll_rw_block.c: buffer not locked\\n\\r\");\n\tbh->b_lock = 0;\n\twake_up(&bh->b_wait);\n}\n\n/*\n * add-request adds a request to the linked list.\n * It disables interrupts so that it can muck with the\n * request-lists in peace.\n */\nstatic void add_request(struct blk_dev_struct * dev, struct request * req)\n{\n\tstruct request * tmp;\n\n\treq->next = NULL;\n\tcli();\n\tif (req->bh)\n\t\treq->bh->b_dirt = 0;\n\tif (!(tmp = dev->current_request)) {\n\t\tdev->current_request = req;\n\t\tsti();\n\t\t(dev->request_fn)();\n\t\treturn;\n\t}\n\tfor ( ; tmp->next ; tmp=tmp->next)\n\t\tif ((IN_ORDER(tmp,req) || \n\t\t    !IN_ORDER(tmp,tmp->next)) &&\n\t\t    IN_ORDER(req,tmp->next))\n\t\t\tbreak;\n\treq->next=tmp->next;\n\ttmp->next=req;\n\tsti();\n}\n\nstatic void make_request(int major,int rw, struct buffer_head * bh)\n{\n\tstruct request * req;\n\tint rw_ahead;\n\n/* WRITEA/READA is special case - it is not really needed, so if the */\n/* buffer is locked, we just forget about it, else it's a normal read */\n\tif ((rw_ahead = (rw == READA || rw == WRITEA))) {\n\t\tif (bh->b_lock)\n\t\t\treturn;\n\t\tif (rw == READA)\n\t\t\trw = READ;\n\t\telse\n\t\t\trw = WRITE;\n\t}\n\tif (rw!=READ && rw!=WRITE)\n\t\tpanic(\"Bad block dev command, must be R/W/RA/WA\");\n\tlock_buffer(bh);\n\tif ((rw == WRITE && !bh->b_dirt) || (rw == READ && bh->b_uptodate)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\nrepeat:\n/* we don't allow the write-requests to fill up the queue completely:\n * we want some room for reads: they take precedence. The last third\n * of the requests are only for reads.\n */\n\tif (rw == READ)\n\t\treq = request+NR_REQUEST;\n\telse\n\t\treq = request+((NR_REQUEST*2)/3);\n/* find an empty request */\n\twhile (--req >= request)\n\t\tif (req->dev<0)\n\t\t\tbreak;\n/* if none found, sleep on new requests: check for rw_ahead */\n\tif (req < request) {\n\t\tif (rw_ahead) {\n\t\t\tunlock_buffer(bh);\n\t\t\treturn;\n\t\t}\n\t\tsleep_on(&wait_for_request);\n\t\tgoto repeat;\n\t}\n/* fill up the request-info, and add it to the queue */\n\treq->dev = bh->b_dev;\n\treq->cmd = rw;\n\treq->errors=0;\n\treq->sector = bh->b_blocknr<<1;\n\treq->nr_sectors = 2;\n\treq->buffer = bh->b_data;\n\treq->waiting = NULL;\n\treq->bh = bh;\n\treq->next = NULL;\n\tadd_request(major+blk_dev,req);\n}\n\nvoid ll_rw_block(int rw, struct buffer_head * bh)\n{\n\tunsigned int major;\n\n\tif ((major=MAJOR(bh->b_dev)) >= NR_BLK_DEV ||\n\t!(blk_dev[major].request_fn)) {\n\t\tprintk(\"Trying to read nonexistent block-device\\n\\r\");\n\t\treturn;\n\t}\n\tmake_request(major,rw,bh);\n}\n\nvoid blk_dev_init(void)\n{\n\tint i;\n\n\tfor (i=0 ; i<NR_REQUEST ; i++) {\n\t\trequest[i].dev = -1;\n\t\trequest[i].next = NULL;\n\t}\n}",
        "/*\n *  linux/kernel/floppy.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * 02.12.91 - Changed to static variables to indicate need for reset\n * and recalibrate. This makes some things easier (output_byte reset\n * checking etc), and means less interrupt jumping in case of errors,\n * so the code is hopefully easier to understand.\n */\n\n/*\n * This file is certainly a mess. I've tried my best to get it working,\n * but I don't like programming floppies, and I have only one anyway.\n * Urgel. I should check for more errors, and do more graceful error\n * recovery. Seems there are problems with several drives. I've tried to\n * correct them. No promises. \n */\n\n/*\n * As with hd.c, all routines within this file can (and will) be called\n * by interrupts, so extreme caution is needed. A hardware interrupt\n * handler may not sleep, or a kernel panic will happen. Thus I cannot\n * call \"floppy-on\" directly, but have to set a special timer interrupt\n * etc.\n *\n * Also, I'm not certain this works on more than 1 floppy. Bugs may\n * abund.\n */\n\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/fdreg.h>\n#include <asm/system.h>\n#include <asm/io.h>\n#include <asm/segment.h>\n\n#define MAJOR_NR 2\n#include \"blk.h\"\n\nstatic int recalibrate = 0;\nstatic int reset = 0;\nstatic int seek = 0;\n\nextern unsigned char current_DOR;\n\n#define immoutb_p(val,port) \\\n__asm__(\"outb %0,%1\\n\\tjmp 1f\\n1:\\tjmp 1f\\n1:\"::\"a\" ((char) (val)),\"i\" (port))\n\n#define TYPE(x) ((x)>>2)\n#define DRIVE(x) ((x)&0x03)\n/*\n * Note that MAX_ERRORS=8 doesn't imply that we retry every bad read\n * max 8 times - some types of errors increase the errorcount by 2,\n * so we might actually retry only 5-6 times before giving up.\n */\n#define MAX_ERRORS 8\n\n/*\n * globals used by 'result()'\n */\n#define MAX_REPLIES 7\nstatic unsigned char reply_buffer[MAX_REPLIES];\n#define ST0 (reply_buffer[0])\n#define ST1 (reply_buffer[1])\n#define ST2 (reply_buffer[2])\n#define ST3 (reply_buffer[3])\n\n/*\n * This struct defines the different floppy types. Unlike minix\n * linux doesn't have a \"search for right type\"-type, as the code\n * for that is convoluted and weird. I've got enough problems with\n * this driver as it is.\n *\n * The 'stretch' tells if the tracks need to be boubled for some\n * types (ie 360kB diskette in 1.2MB drive etc). Others should\n * be self-explanatory.\n */\nstatic struct floppy_struct {\n\tunsigned int size, sect, head, track, stretch;\n\tunsigned char gap,rate,spec1;\n} floppy_type[] = {\n\t{    0, 0,0, 0,0,0x00,0x00,0x00 },\t/* no testing */\n\t{  720, 9,2,40,0,0x2A,0x02,0xDF },\t/* 360kB PC diskettes */\n\t{ 2400,15,2,80,0,0x1B,0x00,0xDF },\t/* 1.2 MB AT-diskettes */\n\t{  720, 9,2,40,1,0x2A,0x02,0xDF },\t/* 360kB in 720kB drive */\n\t{ 1440, 9,2,80,0,0x2A,0x02,0xDF },\t/* 3.5\" 720kB diskette */\n\t{  720, 9,2,40,1,0x23,0x01,0xDF },\t/* 360kB in 1.2MB drive */\n\t{ 1440, 9,2,80,0,0x23,0x01,0xDF },\t/* 720kB in 1.2MB drive */\n\t{ 2880,18,2,80,0,0x1B,0x00,0xCF },\t/* 1.44MB diskette */\n};\n/*\n * Rate is 0 for 500kb/s, 2 for 300kbps, 1 for 250kbps\n * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),\n * H is head unload time (1=16ms, 2=32ms, etc)\n *\n * Spec2 is (HLD<<1 | ND), where HLD is head load time (1=2ms, 2=4 ms etc)\n * and ND is set means no DMA. Hardcoded to 6 (HLD=6ms, use DMA).\n */\n\nextern void floppy_interrupt(void);\nextern char tmp_floppy_area[1024];\n\n/*\n * These are global variables, as that's the easiest way to give\n * information to interrupts. They are the data used for the current\n * request.\n */\nstatic int cur_spec1 = -1;\nstatic int cur_rate = -1;\nstatic struct floppy_struct * floppy = floppy_type;\nstatic unsigned char current_drive = 0;\nstatic unsigned char sector = 0;\nstatic unsigned char head = 0;\nstatic unsigned char track = 0;\nstatic unsigned char seek_track = 0;\nstatic unsigned char current_track = 255;\nstatic unsigned char command = 0;\nunsigned char selected = 0;\nstruct task_struct * wait_on_floppy_select = NULL;\n\nvoid floppy_deselect(unsigned int nr)\n{\n\tif (nr != (current_DOR & 3))\n\t\tprintk(\"floppy_deselect: drive not selected\\n\\r\");\n\tselected = 0;\n\twake_up(&wait_on_floppy_select);\n}\n\n/*\n * floppy-change is never called from an interrupt, so we can relax a bit\n * here, sleep etc. Note that floppy-on tries to set current_DOR to point\n * to the desired drive, but it will probably not survive the sleep if\n * several floppies are used at the same time: thus the loop.\n */\nint floppy_change(unsigned int nr)\n{\nrepeat:\n\tfloppy_on(nr);\n\twhile ((current_DOR & 3) != nr && selected)\n\t\tinterruptible_sleep_on(&wait_on_floppy_select);\n\tif ((current_DOR & 3) != nr)\n\t\tgoto repeat;\n\tif (inb(FD_DIR) & 0x80) {\n\t\tfloppy_off(nr);\n\t\treturn 1;\n\t}\n\tfloppy_off(nr);\n\treturn 0;\n}\n\n#define copy_buffer(from,to) \\\n__asm__(\"cld ; rep ; movsl\" \\\n\t::\"c\" (BLOCK_SIZE/4),\"S\" ((long)(from)),\"D\" ((long)(to)) \\\n\t)\n\nstatic void setup_DMA(void)\n{\n\tlong addr = (long) CURRENT->buffer;\n\n\tcli();\n\tif (addr >= 0x100000) {\n\t\taddr = (long) tmp_floppy_area;\n\t\tif (command == FD_WRITE)\n\t\t\tcopy_buffer(CURRENT->buffer,tmp_floppy_area);\n\t}\n/* mask DMA 2 */\n\timmoutb_p(4|2,10);\n/* output command byte. I don't know why, but everyone (minix, */\n/* sanches & canton) output this twice, first to 12 then to 11 */\n \t__asm__(\"outb %%al,$12\\n\\tjmp 1f\\n1:\\tjmp 1f\\n1:\\t\"\n\t\"outb %%al,$11\\n\\tjmp 1f\\n1:\\tjmp 1f\\n1:\"::\n\t\"a\" ((char) ((command == FD_READ)?DMA_READ:DMA_WRITE)));\n/* 8 low bits of addr */\n\timmoutb_p(addr,4);\n\taddr >>= 8;\n/* bits 8-15 of addr */\n\timmoutb_p(addr,4);\n\taddr >>= 8;\n/* bits 16-19 of addr */\n\timmoutb_p(addr,0x81);\n/* low 8 bits of count-1 (1024-1=0x3ff) */\n\timmoutb_p(0xff,5);\n/* high 8 bits of count-1 */\n\timmoutb_p(3,5);\n/* activate DMA 2 */\n\timmoutb_p(0|2,10);\n\tsti();\n}\n\nstatic void output_byte(char byte)\n{\n\tint counter;\n\tunsigned char status;\n\n\tif (reset)\n\t\treturn;\n\tfor(counter = 0 ; counter < 10000 ; counter++) {\n\t\tstatus = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);\n\t\tif (status == STATUS_READY) {\n\t\t\toutb(byte,FD_DATA);\n\t\t\treturn;\n\t\t}\n\t}\n\treset = 1;\n\tprintk(\"Unable to send byte to FDC\\n\\r\");\n}\n\nstatic int result(void)\n{\n\tint i = 0, counter, status;\n\n\tif (reset)\n\t\treturn -1;\n\tfor (counter = 0 ; counter < 10000 ; counter++) {\n\t\tstatus = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);\n\t\tif (status == STATUS_READY)\n\t\t\treturn i;\n\t\tif (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {\n\t\t\tif (i >= MAX_REPLIES)\n\t\t\t\tbreak;\n\t\t\treply_buffer[i++] = inb_p(FD_DATA);\n\t\t}\n\t}\n\treset = 1;\n\tprintk(\"Getstatus times out\\n\\r\");\n\treturn -1;\n}\n\nstatic void bad_flp_intr(void)\n{\n\tCURRENT->errors++;\n\tif (CURRENT->errors > MAX_ERRORS) {\n\t\tfloppy_deselect(current_drive);\n\t\tend_request(0);\n\t}\n\tif (CURRENT->errors > MAX_ERRORS/2)\n\t\treset = 1;\n\telse\n\t\trecalibrate = 1;\n}\t\n\n/*\n * Ok, this interrupt is called after a DMA read/write has succeeded,\n * so we check the results, and copy any buffers.\n */\nstatic void rw_interrupt(void)\n{\n\tif (result() != 7 || (ST0 & 0xf8) || (ST1 & 0xbf) || (ST2 & 0x73)) {\n\t\tif (ST1 & 0x02) {\n\t\t\tprintk(\"Drive %d is write protected\\n\\r\",current_drive);\n\t\t\tfloppy_deselect(current_drive);\n\t\t\tend_request(0);\n\t\t} else\n\t\t\tbad_flp_intr();\n\t\tdo_fd_request();\n\t\treturn;\n\t}\n\tif (command == FD_READ && (unsigned long)(CURRENT->buffer) >= 0x100000)\n\t\tcopy_buffer(tmp_floppy_area,CURRENT->buffer);\n\tfloppy_deselect(current_drive);\n\tend_request(1);\n\tdo_fd_request();\n}\n\nstatic inline void setup_rw_floppy(void)\n{\n\tsetup_DMA();\n\tdo_floppy = rw_interrupt;\n\toutput_byte(command);\n\toutput_byte(head<<2 | current_drive);\n\toutput_byte(track);\n\toutput_byte(head);\n\toutput_byte(sector);\n\toutput_byte(2);\t\t/* sector size = 512 */\n\toutput_byte(floppy->sect);\n\toutput_byte(floppy->gap);\n\toutput_byte(0xFF);\t/* sector size (0xff when n!=0 ?) */\n\tif (reset)\n\t\tdo_fd_request();\n}\n\n/*\n * This is the routine called after every seek (or recalibrate) interrupt\n * from the floppy controller. Note that the \"unexpected interrupt\" routine\n * also does a recalibrate, but doesn't come here.\n */\nstatic void seek_interrupt(void)\n{\n/* sense drive status */\n\toutput_byte(FD_SENSEI);\n\tif (result() != 2 || (ST0 & 0xF8) != 0x20 || ST1 != seek_track) {\n\t\tbad_flp_intr();\n\t\tdo_fd_request();\n\t\treturn;\n\t}\n\tcurrent_track = ST1;\n\tsetup_rw_floppy();\n}\n\n/*\n * This routine is called when everything should be correctly set up\n * for the transfer (ie floppy motor is on and the correct floppy is\n * selected).\n */\nstatic void transfer(void)\n{\n\tif (cur_spec1 != floppy->spec1) {\n\t\tcur_spec1 = floppy->spec1;\n\t\toutput_byte(FD_SPECIFY);\n\t\toutput_byte(cur_spec1);\t\t/* hut etc */\n\t\toutput_byte(6);\t\t\t/* Head load time =6ms, DMA */\n\t}\n\tif (cur_rate != floppy->rate)\n\t\toutb_p(cur_rate = floppy->rate,FD_DCR);\n\tif (reset) {\n\t\tdo_fd_request();\n\t\treturn;\n\t}\n\tif (!seek) {\n\t\tsetup_rw_floppy();\n\t\treturn;\n\t}\n\tdo_floppy = seek_interrupt;\n\tif (seek_track) {\n\t\toutput_byte(FD_SEEK);\n\t\toutput_byte(head<<2 | current_drive);\n\t\toutput_byte(seek_track);\n\t} else {\n\t\toutput_byte(FD_RECALIBRATE);\n\t\toutput_byte(head<<2 | current_drive);\n\t}\n\tif (reset)\n\t\tdo_fd_request();\n}\n\n/*\n * Special case - used after a unexpected interrupt (or reset)\n */\nstatic void recal_interrupt(void)\n{\n\toutput_byte(FD_SENSEI);\n\tif (result()!=2 || (ST0 & 0xE0) == 0x60)\n\t\treset = 1;\n\telse\n\t\trecalibrate = 0;\n\tdo_fd_request();\n}\n\nvoid unexpected_floppy_interrupt(void)\n{\n\toutput_byte(FD_SENSEI);\n\tif (result()!=2 || (ST0 & 0xE0) == 0x60)\n\t\treset = 1;\n\telse\n\t\trecalibrate = 1;\n}\n\nstatic void recalibrate_floppy(void)\n{\n\trecalibrate = 0;\n\tcurrent_track = 0;\n\tdo_floppy = recal_interrupt;\n\toutput_byte(FD_RECALIBRATE);\n\tcurrent_drive = CURRENT_DEV;\n\toutput_byte(head<<2 | current_drive);\n\tif (reset)\n\t\tdo_fd_request();\n}\n\nstatic void reset_interrupt(void)\n{\n\toutput_byte(FD_SENSEI);\n\t(void) result();\n\toutput_byte(FD_SPECIFY);\n\toutput_byte(cur_spec1);\t\t/* hut etc */\n\toutput_byte(6);\t\t\t/* Head load time =6ms, DMA */\n\tdo_fd_request();\n}\n\n/*\n * reset is done by pulling bit 2 of DOR low for a while.\n */\nstatic void reset_floppy(void)\n{\n\tint i;\n\n\treset = 0;\n\tcur_spec1 = -1;\n\tcur_rate = -1;\n\trecalibrate = 1;\n\tprintk(\"Reset-floppy called\\n\\r\");\n\tcli();\n\tdo_floppy = reset_interrupt;\n\toutb_p(current_DOR & ~0x04,FD_DOR);\n\tfor (i=0 ; i<100 ; i++)\n\t\t__asm__(\"nop\");\n\toutb(current_DOR,FD_DOR);\n\tsti();\n}\n\nstatic void floppy_on_interrupt(void)\n{\n/* We cannot do a floppy-select, as that might sleep. We just force it */\n\tselected = 1;\n\tif (current_drive != (current_DOR & 3)) {\n\t\tcurrent_DOR &= 0xFC;\n\t\tcurrent_DOR |= current_drive;\n\t\toutb(current_DOR,FD_DOR);\n\t\tadd_timer(2,&transfer);\n\t} else\n\t\ttransfer();\n}\n\nvoid do_fd_request(void)\n{\n\tunsigned int block;\n\n\tseek = 0;\n\tif (reset) {\n\t\treset_floppy();\n\t\treturn;\n\t}\n\tif (recalibrate) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t}\n\tINIT_REQUEST;\n\tfloppy = (MINOR(CURRENT->dev)>>2) + floppy_type;\n\tif (current_drive != CURRENT_DEV)\n\t\tseek = 1;\n\tcurrent_drive = CURRENT_DEV;\n\tblock = CURRENT->sector;\n\tif (block+2 > floppy->size) {\n\t\tend_request(0);\n\t\tgoto repeat;\n\t}\n\tsector = block % floppy->sect;\n\tblock /= floppy->sect;\n\thead = block % floppy->head;\n\ttrack = block / floppy->head;\n\tseek_track = track << floppy->stretch;\n\tif (seek_track != current_track)\n\t\tseek = 1;\n\tsector++;\n\tif (CURRENT->cmd == READ)\n\t\tcommand = FD_READ;\n\telse if (CURRENT->cmd == WRITE)\n\t\tcommand = FD_WRITE;\n\telse\n\t\tpanic(\"do_fd_request: unknown command\");\n\tadd_timer(ticks_to_floppy_on(current_drive),&floppy_on_interrupt);\n}\n\nvoid floppy_init(void)\n{\n\tblk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;\n\tset_trap_gate(0x26,&floppy_interrupt);\n\toutb(inb_p(0x21)&~0x40,0x21);\n}",
        "/*\n *  linux/kernel/hd.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n/*\n * This is the low-level hd interrupt support. It traverses the\n * request-list, using interrupts to jump between functions. As\n * all the functions are called within interrupts, we may not\n * sleep. Special care is recommended.\n * \n *  modified by Drew Eckhardt to check nr of hd's from the CMOS.\n */\n\n#include <linux/config.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/hdreg.h>\n#include <asm/system.h>\n#include <asm/io.h>\n#include <asm/segment.h>\n\n#define MAJOR_NR 3\n#include \"blk.h\"\n\n#define CMOS_READ(addr) ({ \\\noutb_p(0x80|addr,0x70); \\\ninb_p(0x71); \\\n})\n\n/* Max read/write errors/sector */\n#define MAX_ERRORS\t7\n#define MAX_HD\t\t2\n\nstatic void recal_intr(void);\n\nstatic int recalibrate = 0;\nstatic int reset = 0;\n\n/*\n *  This struct defines the HD's and their types.\n */\nstruct hd_i_struct {\n\tint head,sect,cyl,wpcom,lzone,ctl;\n\t};\n#ifdef HD_TYPE\nstruct hd_i_struct hd_info[] = { HD_TYPE };\n#define NR_HD ((sizeof (hd_info))/(sizeof (struct hd_i_struct)))\n#else\nstruct hd_i_struct hd_info[] = { {0,0,0,0,0,0},{0,0,0,0,0,0} };\nstatic int NR_HD = 0;\n#endif\n\nstatic struct hd_struct {\n\tlong start_sect;\n\tlong nr_sects;\n} hd[5*MAX_HD]={{0,0},};\n\n#define port_read(port,buf,nr) \\\n__asm__(\"cld;rep;insw\"::\"d\" (port),\"D\" (buf),\"c\" (nr))\n\n#define port_write(port,buf,nr) \\\n__asm__(\"cld;rep;outsw\"::\"d\" (port),\"S\" (buf),\"c\" (nr))\n\nextern void hd_interrupt(void);\nextern void rd_load(void);\n\n/* This may be used only once, enforced by 'static int callable' */\nint sys_setup(void * BIOS)\n{\n\tstatic int callable = 1;\n\tint i,drive;\n\tunsigned char cmos_disks;\n\tstruct partition *p;\n\tstruct buffer_head * bh;\n\n\tif (!callable)\n\t\treturn -1;\n\tcallable = 0;\n#ifndef HD_TYPE\n\tfor (drive=0 ; drive<2 ; drive++) {\n\t\thd_info[drive].cyl = *(unsigned short *) BIOS;\n\t\thd_info[drive].head = *(unsigned char *) (2+BIOS);\n\t\thd_info[drive].wpcom = *(unsigned short *) (5+BIOS);\n\t\thd_info[drive].ctl = *(unsigned char *) (8+BIOS);\n\t\thd_info[drive].lzone = *(unsigned short *) (12+BIOS);\n\t\thd_info[drive].sect = *(unsigned char *) (14+BIOS);\n\t\tBIOS += 16;\n\t}\n\tif (hd_info[1].cyl)\n\t\tNR_HD=2;\n\telse\n\t\tNR_HD=1;\n#endif\n\tfor (i=0 ; i<NR_HD ; i++) {\n\t\thd[i*5].start_sect = 0;\n\t\thd[i*5].nr_sects = hd_info[i].head*\n\t\t\t\thd_info[i].sect*hd_info[i].cyl;\n\t}\n\n\t/*\n\t\tWe querry CMOS about hard disks : it could be that \n\t\twe have a SCSI/ESDI/etc controller that is BIOS\n\t\tcompatable with ST-506, and thus showing up in our\n\t\tBIOS table, but not register compatable, and therefore\n\t\tnot present in CMOS.\n\n\t\tFurthurmore, we will assume that our ST-506 drives\n\t\t<if any> are the primary drives in the system, and \n\t\tthe ones reflected as drive 1 or 2.\n\n\t\tThe first drive is stored in the high nibble of CMOS\n\t\tbyte 0x12, the second in the low nibble.  This will be\n\t\teither a 4 bit drive type or 0xf indicating use byte 0x19 \n\t\tfor an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.\n\n\t\tNeedless to say, a non-zero value means we have \n\t\tan AT controller hard disk for that drive.\n\n\t\t\n\t*/\n\n\tif ((cmos_disks = CMOS_READ(0x12)) & 0xf0)\n\t\tif (cmos_disks & 0x0f)\n\t\t\tNR_HD = 2;\n\t\telse\n\t\t\tNR_HD = 1;\n\telse\n\t\tNR_HD = 0;\n\tfor (i = NR_HD ; i < 2 ; i++) {\n\t\thd[i*5].start_sect = 0;\n\t\thd[i*5].nr_sects = 0;\n\t}\n\tfor (drive=0 ; drive<NR_HD ; drive++) {\n\t\tif (!(bh = bread(0x300 + drive*5,0))) {\n\t\t\tprintk(\"Unable to read partition table of drive %d\\n\\r\",\n\t\t\t\tdrive);\n\t\t\tpanic(\"\");\n\t\t}\n\t\tif (bh->b_data[510] != 0x55 || (unsigned char)\n\t\t    bh->b_data[511] != 0xAA) {\n\t\t\tprintk(\"Bad partition table on drive %d\\n\\r\",drive);\n\t\t\tpanic(\"\");\n\t\t}\n\t\tp = 0x1BE + (void *)bh->b_data;\n\t\tfor (i=1;i<5;i++,p++) {\n\t\t\thd[i+5*drive].start_sect = p->start_sect;\n\t\t\thd[i+5*drive].nr_sects = p->nr_sects;\n\t\t}\n\t\tbrelse(bh);\n\t}\n\tif (NR_HD)\n\t\tprintk(\"Partition table%s ok.\\n\\r\",(NR_HD>1)?\"s\":\"\");\n\trd_load();\n\tmount_root();\n\treturn (0);\n}\n\nstatic int controller_ready(void)\n{\n\tint retries=100000;\n\n\twhile (--retries && (inb_p(HD_STATUS)&0x80));\n\treturn (retries);\n}\n\nstatic int win_result(void)\n{\n\tint i=inb_p(HD_STATUS);\n\n\tif ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))\n\t\t== (READY_STAT | SEEK_STAT))\n\t\treturn(0); /* ok */\n\tif (i&1) i=inb(HD_ERROR);\n\treturn (1);\n}\n\nstatic void hd_out(unsigned int drive,unsigned int nsect,unsigned int sect,\n\t\tunsigned int head,unsigned int cyl,unsigned int cmd,\n\t\tvoid (*intr_addr)(void))\n{\n\tregister int port asm(\"dx\");\n\n\tif (drive>1 || head>15)\n\t\tpanic(\"Trying to write bad sector\");\n\tif (!controller_ready())\n\t\tpanic(\"HD controller not ready\");\n\tdo_hd = intr_addr;\n\toutb_p(hd_info[drive].ctl,HD_CMD);\n\tport=HD_DATA;\n\toutb_p(hd_info[drive].wpcom>>2,++port);\n\toutb_p(nsect,++port);\n\toutb_p(sect,++port);\n\toutb_p(cyl,++port);\n\toutb_p(cyl>>8,++port);\n\toutb_p(0xA0|(drive<<4)|head,++port);\n\toutb(cmd,++port);\n}\n\nstatic int drive_busy(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < 10000; i++)\n\t\tif (READY_STAT == (inb_p(HD_STATUS) & (BUSY_STAT|READY_STAT)))\n\t\t\tbreak;\n\ti = inb(HD_STATUS);\n\ti &= BUSY_STAT | READY_STAT | SEEK_STAT;\n\tif (i == (READY_STAT | SEEK_STAT))\n\t\treturn(0);\n\tprintk(\"HD controller times out\\n\\r\");\n\treturn(1);\n}\n\nstatic void reset_controller(void)\n{\n\tint\ti;\n\n\toutb(4,HD_CMD);\n\tfor(i = 0; i < 100; i++) nop();\n\toutb(hd_info[0].ctl & 0x0f ,HD_CMD);\n\tif (drive_busy())\n\t\tprintk(\"HD-controller still busy\\n\\r\");\n\tif ((i = inb(HD_ERROR)) != 1)\n\t\tprintk(\"HD-controller reset failed: %02x\\n\\r\",i);\n}\n\nstatic void reset_hd(int nr)\n{\n\treset_controller();\n\thd_out(nr,hd_info[nr].sect,hd_info[nr].sect,hd_info[nr].head-1,\n\t\thd_info[nr].cyl,WIN_SPECIFY,&recal_intr);\n}\n\nvoid unexpected_hd_interrupt(void)\n{\n\tprintk(\"Unexpected HD interrupt\\n\\r\");\n}\n\nstatic void bad_rw_intr(void)\n{\n\tif (++CURRENT->errors >= MAX_ERRORS)\n\t\tend_request(0);\n\tif (CURRENT->errors > MAX_ERRORS/2)\n\t\treset = 1;\n}\n\nstatic void read_intr(void)\n{\n\tif (win_result()) {\n\t\tbad_rw_intr();\n\t\tdo_hd_request();\n\t\treturn;\n\t}\n\tport_read(HD_DATA,CURRENT->buffer,256);\n\tCURRENT->errors = 0;\n\tCURRENT->buffer += 512;\n\tCURRENT->sector++;\n\tif (--CURRENT->nr_sectors) {\n\t\tdo_hd = &read_intr;\n\t\treturn;\n\t}\n\tend_request(1);\n\tdo_hd_request();\n}\n\nstatic void write_intr(void)\n{\n\tif (win_result()) {\n\t\tbad_rw_intr();\n\t\tdo_hd_request();\n\t\treturn;\n\t}\n\tif (--CURRENT->nr_sectors) {\n\t\tCURRENT->sector++;\n\t\tCURRENT->buffer += 512;\n\t\tdo_hd = &write_intr;\n\t\tport_write(HD_DATA,CURRENT->buffer,256);\n\t\treturn;\n\t}\n\tend_request(1);\n\tdo_hd_request();\n}\n\nstatic void recal_intr(void)\n{\n\tif (win_result())\n\t\tbad_rw_intr();\n\tdo_hd_request();\n}\n\nvoid do_hd_request(void)\n{\n\tint i,r = 0;\n\tunsigned int block,dev;\n\tunsigned int sec,head,cyl;\n\tunsigned int nsect;\n\n\tINIT_REQUEST;\n\tdev = MINOR(CURRENT->dev);\n\tblock = CURRENT->sector;\n\tif (dev >= 5*NR_HD || (block+2) > (hd[dev].start_sect + hd[dev].nr_sects - 1)) {\n\t\tend_request(0);\n\t\tgoto repeat;\n\t}\n\tblock += hd[dev].start_sect;\n\tdev /= 5;\n\t__asm__(\"divl %4\":\"=a\" (block),\"=d\" (sec):\"0\" (block),\"1\" (0),\n\t\t\"r\" (hd_info[dev].sect));\n\t__asm__(\"divl %4\":\"=a\" (cyl),\"=d\" (head):\"0\" (block),\"1\" (0),\n\t\t\"r\" (hd_info[dev].head));\n\tsec++;\n\tnsect = CURRENT->nr_sectors;\n\tif (reset) {\n\t\treset = 0;\n\t\trecalibrate = 1;\n\t\treset_hd(CURRENT_DEV);\n\t\treturn;\n\t}\n\tif (recalibrate) {\n\t\trecalibrate = 0;\n\t\thd_out(dev,hd_info[CURRENT_DEV].sect,0,0,0,\n\t\t\tWIN_RESTORE,&recal_intr);\n\t\treturn;\n\t}\t\n\tif (CURRENT->cmd == WRITE) {\n\t\thd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&write_intr);\n\t\tfor(i=0 ; i<3000 && !(r=inb_p(HD_STATUS)&DRQ_STAT) ; i++)\n\t\t\t/* nothing */ ;\n\t\tif (!r) {\n\t\t\tbad_rw_intr();\n\t\t\tgoto repeat;\n\t\t}\n\t\tport_write(HD_DATA,CURRENT->buffer,256);\n\t} else if (CURRENT->cmd == READ) {\n\t\thd_out(dev,nsect,sec,head,cyl,WIN_READ,&read_intr);\n\t} else\n\t\tpanic(\"unknown hd-command\");\n}\n\nvoid hd_init(void)\n{\n\tblk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;\n\tset_intr_gate(0x2E,&hd_interrupt);\n\toutb_p(inb_p(0x21)&0xfb,0x21);\n\toutb(inb_p(0xA1)&0xbf,0xA1);\n}",
        "/*\n *  linux/kernel/signal.c\n *\n *  (C) 1991  Linus Torvalds\n */\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <asm/segment.h>\n\n#include <signal.h>\n\nvoid do_exit(int error_code);\n\nint sys_sgetmask()\n{\n\treturn current->blocked;\n}\n\nint sys_ssetmask(int newmask)\n{\n\tint old=current->blocked;\n\n\tcurrent->blocked = newmask & ~(1<<(SIGKILL-1));\n\treturn old;\n}\n\nstatic inline void save_old(char * from,char * to)\n{\n\tint i;\n\n\tverify_area(to, sizeof(struct sigaction));\n\tfor (i=0 ; i< sizeof(struct sigaction) ; i++) {\n\t\tput_fs_byte(*from,to);\n\t\tfrom++;\n\t\tto++;\n\t}\n}\n\nstatic inline void get_new(char * from,char * to)\n{\n\tint i;\n\n\tfor (i=0 ; i< sizeof(struct sigaction) ; i++)\n\t\t*(to++) = get_fs_byte(from++);\n}\n\nint sys_signal(int signum, long handler, long restorer)\n{\n\tstruct sigaction tmp;\n\n\tif (signum<1 || signum>32 || signum==SIGKILL)\n\t\treturn -1;\n\ttmp.sa_handler = (void (*)(int)) handler;\n\ttmp.sa_mask = 0;\n\ttmp.sa_flags = SA_ONESHOT | SA_NOMASK;\n\ttmp.sa_restorer = (void (*)(void)) restorer;\n\thandler = (long) current->sigaction[signum-1].sa_handler;\n\tcurrent->sigaction[signum-1] = tmp;\n\treturn handler;\n}\n\nint sys_sigaction(int signum, const struct sigaction * action,\n\tstruct sigaction * oldaction)\n{\n\tstruct sigaction tmp;\n\n\tif (signum<1 || signum>32 || signum==SIGKILL)\n\t\treturn -1;\n\ttmp = current->sigaction[signum-1];\n\tget_new((char *) action,\n\t\t(char *) (signum-1+current->sigaction));\n\tif (oldaction)\n\t\tsave_old((char *) &tmp,(char *) oldaction);\n\tif (current->sigaction[signum-1].sa_flags & SA_NOMASK)\n\t\tcurrent->sigaction[signum-1].sa_mask = 0;\n\telse\n\t\tcurrent->sigaction[signum-1].sa_mask |= (1<<(signum-1));\n\treturn 0;\n}\n\nvoid do_signal(long signr,long eax, long ebx, long ecx, long edx,\n\tlong fs, long es, long ds,\n\tlong eip, long cs, long eflags,\n\tunsigned long * esp, long ss)\n{\n\tunsigned long sa_handler;\n\tlong old_eip=eip;\n\tstruct sigaction * sa = current->sigaction + signr - 1;\n\tint longs;\n\tunsigned long * tmp_esp;\n\n\tsa_handler = (unsigned long) sa->sa_handler;\n\tif (sa_handler==1)\n\t\treturn;\n\tif (!sa_handler) {\n\t\tif (signr==SIGCHLD)\n\t\t\treturn;\n\t\telse\n\t\t\tdo_exit(1<<(signr-1));\n\t}\n\tif (sa->sa_flags & SA_ONESHOT)\n\t\tsa->sa_handler = NULL;\n\t*(&eip) = sa_handler;\n\tlongs = (sa->sa_flags & SA_NOMASK)?7:8;\n\t*(&esp) -= longs;\n\tverify_area(esp,longs*4);\n\ttmp_esp=esp;\n\tput_fs_long((long) sa->sa_restorer,tmp_esp++);\n\tput_fs_long(signr,tmp_esp++);\n\tif (!(sa->sa_flags & SA_NOMASK))\n\t\tput_fs_long(current->blocked,tmp_esp++);\n\tput_fs_long(eax,tmp_esp++);\n\tput_fs_long(ecx,tmp_esp++);\n\tput_fs_long(edx,tmp_esp++);\n\tput_fs_long(eflags,tmp_esp++);\n\tput_fs_long(old_eip,tmp_esp++);\n\tcurrent->blocked |= sa->sa_mask;\n}",
        "#ifndef _TIME_H\n#define _TIME_H\n\n#ifndef _TIME_T\n#define _TIME_T\ntypedef long time_t;\n#endif\n\n#ifndef _SIZE_T\n#define _SIZE_T\ntypedef unsigned int size_t;\n#endif\n\n#define CLOCKS_PER_SEC 100\n\ntypedef long clock_t;\n\nstruct tm {\n\tint tm_sec;\n\tint tm_min;\n\tint tm_hour;\n\tint tm_mday;\n\tint tm_mon;\n\tint tm_year;\n\tint tm_wday;\n\tint tm_yday;\n\tint tm_isdst;\n};\n\nclock_t clock(void);\ntime_t time(time_t * tp);\ndouble difftime(time_t time2, time_t time1);\ntime_t mktime(struct tm * tp);\n\nchar * asctime(const struct tm * tp);\nchar * ctime(const time_t * tp);\nstruct tm * gmtime(const time_t *tp);\nstruct tm *localtime(const time_t * tp);\nsize_t strftime(char * s, size_t smax, const char * fmt, const struct tm * tp);\nvoid tzset(void);\n\n#endif",
        "#ifndef _UTIME_H\n#define _UTIME_H\n\n#include <sys/types.h>\t/* I know - shouldn't do this, but .. */\n\nstruct utimbuf {\n\ttime_t actime;\n\ttime_t modtime;\n};\n\nextern int utime(const char *filename, struct utimbuf *times);\n\n#endif",
        "extern inline unsigned char get_fs_byte(const char * addr)\n{\n\tunsigned register char _v;\n\n\t__asm__ (\"movb %%fs:%1,%0\":\"=r\" (_v):\"m\" (*addr));\n\treturn _v;\n}\n\nextern inline unsigned short get_fs_word(const unsigned short *addr)\n{\n\tunsigned short _v;\n\n\t__asm__ (\"movw %%fs:%1,%0\":\"=r\" (_v):\"m\" (*addr));\n\treturn _v;\n}\n\nextern inline unsigned long get_fs_long(const unsigned long *addr)\n{\n\tunsigned long _v;\n\n\t__asm__ (\"movl %%fs:%1,%0\":\"=r\" (_v):\"m\" (*addr)); \\\n\treturn _v;\n}\n\nextern inline void put_fs_byte(char val,char *addr)\n{\n__asm__ (\"movb %0,%%fs:%1\"::\"r\" (val),\"m\" (*addr));\n}\n\nextern inline void put_fs_word(short val,short * addr)\n{\n__asm__ (\"movw %0,%%fs:%1\"::\"r\" (val),\"m\" (*addr));\n}\n\nextern inline void put_fs_long(unsigned long val,unsigned long * addr)\n{\n__asm__ (\"movl %0,%%fs:%1\"::\"r\" (val),\"m\" (*addr));\n}\n\n/*\n * Someone who knows GNU asm better than I should double check the followig.\n * It seems to work, but I don't know if I'm doing something subtly wrong.\n * --- TYT, 11/24/91\n * [ nothing wrong here, Linus ]\n */\n\nextern inline unsigned long get_fs() \n{\n\tunsigned short _v;\n\t__asm__(\"mov %%fs,%%ax\":\"=a\" (_v):);\n\treturn _v;\n}\n\nextern inline unsigned long get_ds() \n{\n\tunsigned short _v;\n\t__asm__(\"mov %%ds,%%ax\":\"=a\" (_v):);\n\treturn _v;\n}\n\nextern inline void set_fs(unsigned long val)\n{\n\t__asm__(\"mov %0,%%fs\"::\"a\" ((unsigned short) val));\n}\n",
        "#define outb(value,port) \\\n__asm__ (\"outb %%al,%%dx\"::\"a\" (value),\"d\" (port))\n\n\n#define inb(port) ({ \\\nunsigned char _v; \\\n__asm__ volatile (\"inb %%dx,%%al\":\"=a\" (_v):\"d\" (port)); \\\n_v; \\\n})\n\n#define outb_p(value,port) \\\n__asm__ (\"outb %%al,%%dx\\n\" \\\n\t\t\"\\tjmp 1f\\n\" \\\n\t\t\"1:\\tjmp 1f\\n\" \\\n\t\t\"1:\"::\"a\" (value),\"d\" (port))\n\n#define inb_p(port) ({ \\\nunsigned char _v; \\\n__asm__ volatile (\"inb %%dx,%%al\\n\" \\\n\t\"\\tjmp 1f\\n\" \\\n\t\"1:\\tjmp 1f\\n\" \\\n\t\"1:\":\"=a\" (_v):\"d\" (port)); \\\n_v; \\\n})",
        "/*\n *  NOTE!!! memcpy(dest,src,n) assumes ds=es=normal data segment. This\n *  goes for all kernel functions (ds=es=kernel space, fs=local data,\n *  gs=null), as well as for all well-behaving user programs (ds=es=\n *  user data space). This is NOT a bug, as any user program that changes\n *  es deserves to die if it isn't careful.\n */\n#define memcpy(dest,src,n) ({ \\\nvoid * _res = dest; \\\n__asm__ (\"cld;rep;movsb\" \\\n\t::\"D\" ((long)(_res)),\"S\" ((long)(src)),\"c\" ((long) (n)) \\\n\t:\"di\",\"si\",\"cx\"); \\\n_res; \\\n})",
        "#define move_to_user_mode() \\\n__asm__ (\"movl %%esp,%%eax\\n\\t\" \\\n\t\"pushl $0x17\\n\\t\" \\\n\t\"pushl %%eax\\n\\t\" \\\n\t\"pushfl\\n\\t\" \\\n\t\"pushl $0x0f\\n\\t\" \\\n\t\"pushl $1f\\n\\t\" \\\n\t\"iret\\n\" \\\n\t\"1:\\tmovl $0x17,%%eax\\n\\t\" \\\n\t\"movw %%ax,%%ds\\n\\t\" \\\n\t\"movw %%ax,%%es\\n\\t\" \\\n\t\"movw %%ax,%%fs\\n\\t\" \\\n\t\"movw %%ax,%%gs\" \\\n\t:::\"ax\")\n\n#define sti() __asm__ (\"sti\"::)\n#define cli() __asm__ (\"cli\"::)\n#define nop() __asm__ (\"nop\"::)\n\n#define iret() __asm__ (\"iret\"::)\n\n#define _set_gate(gate_addr,type,dpl,addr) \\\n__asm__ (\"movw %%dx,%%ax\\n\\t\" \\\n\t\"movw %0,%%dx\\n\\t\" \\\n\t\"movl %%eax,%1\\n\\t\" \\\n\t\"movl %%edx,%2\" \\\n\t: \\\n\t: \"i\" ((short) (0x8000+(dpl<<13)+(type<<8))), \\\n\t\"o\" (*((char *) (gate_addr))), \\\n\t\"o\" (*(4+(char *) (gate_addr))), \\\n\t\"d\" ((char *) (addr)),\"a\" (0x00080000))\n\n#define set_intr_gate(n,addr) \\\n\t_set_gate(&idt[n],14,0,addr)\n\n#define set_trap_gate(n,addr) \\\n\t_set_gate(&idt[n],15,0,addr)\n\n#define set_system_gate(n,addr) \\\n\t_set_gate(&idt[n],15,3,addr)\n\n#define _set_seg_desc(gate_addr,type,dpl,base,limit) {\\\n\t*(gate_addr) = ((base) & 0xff000000) | \\\n\t\t(((base) & 0x00ff0000)>>16) | \\\n\t\t((limit) & 0xf0000) | \\\n\t\t((dpl)<<13) | \\\n\t\t(0x00408000) | \\\n\t\t((type)<<8); \\\n\t*((gate_addr)+1) = (((base) & 0x0000ffff)<<16) | \\\n\t\t((limit) & 0x0ffff); }\n\n#define _set_tssldt_desc(n,addr,type) \\\n__asm__ (\"movw $104,%1\\n\\t\" \\\n\t\"movw %%ax,%2\\n\\t\" \\\n\t\"rorl $16,%%eax\\n\\t\" \\\n\t\"movb %%al,%3\\n\\t\" \\\n\t\"movb $\" type \",%4\\n\\t\" \\\n\t\"movb $0x00,%5\\n\\t\" \\\n\t\"movb %%ah,%6\\n\\t\" \\\n\t\"rorl $16,%%eax\" \\\n\t::\"a\" (addr), \"m\" (*(n)), \"m\" (*(n+2)), \"m\" (*(n+4)), \\\n\t \"m\" (*(n+5)), \"m\" (*(n+6)), \"m\" (*(n+7)) \\\n\t)\n\n#define set_tss_desc(n,addr) _set_tssldt_desc(((char *) (n)),addr,\"0x89\")\n#define set_ldt_desc(n,addr) _set_tssldt_desc(((char *) (n)),addr,\"0x82\")",
        "#ifndef _UNISTD_H\n#define _UNISTD_H\n\n/* ok, this may be a joke, but I'm working on it */\n#define _POSIX_VERSION 198808L\n\n#define _POSIX_CHOWN_RESTRICTED\t/* only root can do a chown (I think..) */\n#define _POSIX_NO_TRUNC\t\t/* no pathname truncation (but see in kernel) */\n#define _POSIX_VDISABLE '\\0'\t/* character to disable things like ^C */\n/*#define _POSIX_SAVED_IDS */\t/* we'll get to this yet */\n/*#define _POSIX_JOB_CONTROL */\t/* we aren't there quite yet. Soon hopefully */\n\n#define STDIN_FILENO\t0\n#define STDOUT_FILENO\t1\n#define STDERR_FILENO\t2\n\n#ifndef NULL\n#define NULL    ((void *)0)\n#endif\n\n/* access */\n#define F_OK\t0\n#define X_OK\t1\n#define W_OK\t2\n#define R_OK\t4\n\n/* lseek */\n#define SEEK_SET\t0\n#define SEEK_CUR\t1\n#define SEEK_END\t2\n\n/* _SC stands for System Configuration. We don't use them much */\n#define _SC_ARG_MAX\t\t1\n#define _SC_CHILD_MAX\t\t2\n#define _SC_CLOCKS_PER_SEC\t3\n#define _SC_NGROUPS_MAX\t\t4\n#define _SC_OPEN_MAX\t\t5\n#define _SC_JOB_CONTROL\t\t6\n#define _SC_SAVED_IDS\t\t7\n#define _SC_VERSION\t\t8\n\n/* more (possibly) configurable things - now pathnames */\n#define _PC_LINK_MAX\t\t1\n#define _PC_MAX_CANON\t\t2\n#define _PC_MAX_INPUT\t\t3\n#define _PC_NAME_MAX\t\t4\n#define _PC_PATH_MAX\t\t5\n#define _PC_PIPE_BUF\t\t6\n#define _PC_NO_TRUNC\t\t7\n#define _PC_VDISABLE\t\t8\n#define _PC_CHOWN_RESTRICTED\t9\n\n#include <sys/stat.h>\n#include <sys/times.h>\n#include <sys/utsname.h>\n#include <utime.h>\n\n#ifdef __LIBRARY__\n\n#define __NR_setup\t0\t/* used only by init, to get system going */\n#define __NR_exit\t1\n#define __NR_fork\t2\n#define __NR_read\t3\n#define __NR_write\t4\n#define __NR_open\t5\n#define __NR_close\t6\n#define __NR_waitpid\t7\n#define __NR_creat\t8\n#define __NR_link\t9\n#define __NR_unlink\t10\n#define __NR_execve\t11\n#define __NR_chdir\t12\n#define __NR_time\t13\n#define __NR_mknod\t14\n#define __NR_chmod\t15\n#define __NR_chown\t16\n#define __NR_break\t17\n#define __NR_stat\t18\n#define __NR_lseek\t19\n#define __NR_getpid\t20\n#define __NR_mount\t21\n#define __NR_umount\t22\n#define __NR_setuid\t23\n#define __NR_getuid\t24\n#define __NR_stime\t25\n#define __NR_ptrace\t26\n#define __NR_alarm\t27\n#define __NR_fstat\t28\n#define __NR_pause\t29\n#define __NR_utime\t30\n#define __NR_stty\t31\n#define __NR_gtty\t32\n#define __NR_access\t33\n#define __NR_nice\t34\n#define __NR_ftime\t35\n#define __NR_sync\t36\n#define __NR_kill\t37\n#define __NR_rename\t38\n#define __NR_mkdir\t39\n#define __NR_rmdir\t40\n#define __NR_dup\t41\n#define __NR_pipe\t42\n#define __NR_times\t43\n#define __NR_prof\t44\n#define __NR_brk\t45\n#define __NR_setgid\t46\n#define __NR_getgid\t47\n#define __NR_signal\t48\n#define __NR_geteuid\t49\n#define __NR_getegid\t50\n#define __NR_acct\t51\n#define __NR_phys\t52\n#define __NR_lock\t53\n#define __NR_ioctl\t54\n#define __NR_fcntl\t55\n#define __NR_mpx\t56\n#define __NR_setpgid\t57\n#define __NR_ulimit\t58\n#define __NR_uname\t59\n#define __NR_umask\t60\n#define __NR_chroot\t61\n#define __NR_ustat\t62\n#define __NR_dup2\t63\n#define __NR_getppid\t64\n#define __NR_getpgrp\t65\n#define __NR_setsid\t66\n#define __NR_sigaction\t67\n#define __NR_sgetmask\t68\n#define __NR_ssetmask\t69\n#define __NR_setreuid\t70\n#define __NR_setregid\t71\n#define __NR_sigsuspend\t72\n#define __NR_sigpending\t73\n#define __NR_sethostname 74\n#define __NR_setrlimit\t75\n#define __NR_getrlimit\t76\n#define __NR_getrusage\t77\n#define __NR_gettimeofday\t78\n#define __NR_settimeofday\t79\n#define __NR_getgroups\t80\n#define __NR_setgroups  81\n#define __NR_select\t82\n#define __NR_symlink\t83\n#define __NR_lstat\t84\n#define __NR_readlink\t85\n#define __NR_uselib\t86\n#define _syscall0(type,name) \\\ntype name(void) \\\n{ \\\nlong __res; \\\n__asm__ volatile (\"int $0x80\" \\\n\t: \"=a\" (__res) \\\n\t: \"0\" (__NR_##name)); \\\nif (__res >= 0) \\\n\treturn (type) __res; \\\nerrno = -__res; \\\nreturn -1; \\\n}\n\n#define _syscall1(type,name,atype,a) \\\ntype name(atype a) \\\n{ \\\nlong __res; \\\n__asm__ volatile (\"int $0x80\" \\\n\t: \"=a\" (__res) \\\n\t: \"0\" (__NR_##name),\"b\" ((long)(a))); \\\nif (__res >= 0) \\\n\treturn (type) __res; \\\nerrno = -__res; \\\nreturn -1; \\\n}\n\n#define _syscall2(type,name,atype,a,btype,b) \\\ntype name(atype a,btype b) \\\n{ \\\nlong __res; \\\n__asm__ volatile (\"int $0x80\" \\\n\t: \"=a\" (__res) \\\n\t: \"0\" (__NR_##name),\"b\" ((long)(a)),\"c\" ((long)(b))); \\\nif (__res >= 0) \\\n\treturn (type) __res; \\\nerrno = -__res; \\\nreturn -1; \\\n}\n\n#define _syscall3(type,name,atype,a,btype,b,ctype,c) \\\ntype name(atype a,btype b,ctype c) \\\n{ \\\nlong __res; \\\n__asm__ volatile (\"int $0x80\" \\\n\t: \"=a\" (__res) \\\n\t: \"0\" (__NR_##name),\"b\" ((long)(a)),\"c\" ((long)(b)),\"d\" ((long)(c))); \\\nif (__res>=0) \\\n\treturn (type) __res; \\\nerrno=-__res; \\\nreturn -1; \\\n}\n\n#endif /* __LIBRARY__ */\n\nextern int errno;\n\nint access(const char * filename, mode_t mode);\nint acct(const char * filename);\nint alarm(int sec);\nint brk(void * end_data_segment);\nvoid * sbrk(ptrdiff_t increment);\nint chdir(const char * filename);\nint chmod(const char * filename, mode_t mode);\nint chown(const char * filename, uid_t owner, gid_t group);\nint chroot(const char * filename);\nint close(int fildes);\nint creat(const char * filename, mode_t mode);\nint dup(int fildes);\nint execve(const char * filename, char ** argv, char ** envp);\nint execv(const char * pathname, char ** argv);\nint execvp(const char * file, char ** argv);\nint execl(const char * pathname, char * arg0, ...);\nint execlp(const char * file, char * arg0, ...);\nint execle(const char * pathname, char * arg0, ...);\nvolatile void exit(int status);\nvolatile void _exit(int status);\nint fcntl(int fildes, int cmd, ...);\nint fork(void);\nint getpid(void);\nint getuid(void);\nint geteuid(void);\nint getgid(void);\nint getegid(void);\nint ioctl(int fildes, int cmd, ...);\nint kill(pid_t pid, int signal);\nint link(const char * filename1, const char * filename2);\nint lseek(int fildes, off_t offset, int origin);\nint mknod(const char * filename, mode_t mode, dev_t dev);\nint mount(const char * specialfile, const char * dir, int rwflag);\nint nice(int val);\nint open(const char * filename, int flag, ...);\nint pause(void);\nint pipe(int * fildes);\nint read(int fildes, char * buf, off_t count);\nint setpgrp(void);\nint setpgid(pid_t pid,pid_t pgid);\nint setuid(uid_t uid);\nint setgid(gid_t gid);\nvoid (*signal(int sig, void (*fn)(int)))(int);\nint stat(const char * filename, struct stat * stat_buf);\nint fstat(int fildes, struct stat * stat_buf);\nint stime(time_t * tptr);\nint sync(void);\ntime_t time(time_t * tloc);\ntime_t times(struct tms * tbuf);\nint ulimit(int cmd, long limit);\nmode_t umask(mode_t mask);\nint umount(const char * specialfile);\nint uname(struct utsname * name);\nint unlink(const char * filename);\nint ustat(dev_t dev, struct ustat * ubuf);\nint utime(const char * filename, struct utimbuf * times);\npid_t waitpid(pid_t pid,int * wait_stat,int options);\npid_t wait(int * wait_stat);\nint write(int fildes, const char * buf, off_t count);\nint dup2(int oldfd, int newfd);\nint getppid(void);\npid_t getpgrp(void);\npid_t setsid(void);\n\n#endif",
        "#ifndef _STDDEF_H\n#define _STDDEF_H\n\n#ifndef _PTRDIFF_T\n#define _PTRDIFF_T\ntypedef long ptrdiff_t;\n#endif\n\n#ifndef _SIZE_T\n#define _SIZE_T\ntypedef unsigned long size_t;\n#endif\n\n#undef NULL\n#define NULL ((void *)0)\n\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n\n#endif",
        "#ifndef _FCNTL_H\n#define _FCNTL_H\n\n#include <sys/types.h>\n\n/* open/fcntl - NOCTTY, NDELAY isn't implemented yet */\n#define O_ACCMODE\t00003\n#define O_RDONLY\t   00\n#define O_WRONLY\t   01\n#define O_RDWR\t\t   02\n#define O_CREAT\t\t00100\t/* not fcntl */\n#define O_EXCL\t\t00200\t/* not fcntl */\n#define O_NOCTTY\t00400\t/* not fcntl */\n#define O_TRUNC\t\t01000\t/* not fcntl */\n#define O_APPEND\t02000\n#define O_NONBLOCK\t04000\t/* not fcntl */\n#define O_NDELAY\tO_NONBLOCK\n\n/* Defines for fcntl-commands. Note that currently\n * locking isn't supported, and other things aren't really\n * tested.\n */\n#define F_DUPFD\t\t0\t/* dup */\n#define F_GETFD\t\t1\t/* get f_flags */\n#define F_SETFD\t\t2\t/* set f_flags */\n#define F_GETFL\t\t3\t/* more flags (cloexec) */\n#define F_SETFL\t\t4\n#define F_GETLK\t\t5\t/* not implemented */\n#define F_SETLK\t\t6\n#define F_SETLKW\t7\n\n/* for F_[GET|SET]FL */\n#define FD_CLOEXEC\t1\t/* actually anything with low bit set goes */\n\n/* Ok, these are locking features, and aren't implemented at any\n * level. POSIX wants them.\n */\n#define F_RDLCK\t\t0\n#define F_WRLCK\t\t1\n#define F_UNLCK\t\t2\n\n/* Once again - not implemented, but ... */\nstruct flock {\n\tshort l_type;\n\tshort l_whence;\n\toff_t l_start;\n\toff_t l_len;\n\tpid_t l_pid;\n};\n\nextern int creat(const char * filename,mode_t mode);\nextern int fcntl(int fildes,int cmd, ...);\nextern int open(const char * filename, int flags, ...);\n\n#endif",
        "#ifndef _SIGNAL_H\n#define _SIGNAL_H\n\n#include <sys/types.h>\n\ntypedef int sig_atomic_t;\ntypedef unsigned int sigset_t;\t\t/* 32 bits */\n\n#define _NSIG             32\n#define NSIG\t\t_NSIG\n\n#define SIGHUP\t\t 1\n#define SIGINT\t\t 2\n#define SIGQUIT\t\t 3\n#define SIGILL\t\t 4\n#define SIGTRAP\t\t 5\n#define SIGABRT\t\t 6\n#define SIGIOT\t\t 6\n#define SIGUNUSED\t 7\n#define SIGFPE\t\t 8\n#define SIGKILL\t\t 9\n#define SIGUSR1\t\t10\n#define SIGSEGV\t\t11\n#define SIGUSR2\t\t12\n#define SIGPIPE\t\t13\n#define SIGALRM\t\t14\n#define SIGTERM\t\t15\n#define SIGSTKFLT\t16\n#define SIGCHLD\t\t17\n#define SIGCONT\t\t18\n#define SIGSTOP\t\t19\n#define SIGTSTP\t\t20\n#define SIGTTIN\t\t21\n#define SIGTTOU\t\t22\n\n/* Ok, I haven't implemented sigactions, but trying to keep headers POSIX */\n#define SA_NOCLDSTOP\t1\n#define SA_NOMASK\t0x40000000\n#define SA_ONESHOT\t0x80000000\n\n#define SIG_BLOCK          0\t/* for blocking signals */\n#define SIG_UNBLOCK        1\t/* for unblocking signals */\n#define SIG_SETMASK        2\t/* for setting the signal mask */\n\n#define SIG_DFL\t\t((void (*)(int))0)\t/* default signal handling */\n#define SIG_IGN\t\t((void (*)(int))1)\t/* ignore signal */\n\nstruct sigaction {\n\tvoid (*sa_handler)(int);\n\tsigset_t sa_mask;\n\tint sa_flags;\n\tvoid (*sa_restorer)(void);\n};\n\nvoid (*signal(int _sig, void (*_func)(int)))(int);\nint raise(int sig);\nint kill(pid_t pid, int sig);\nint sigaddset(sigset_t *mask, int signo);\nint sigdelset(sigset_t *mask, int signo);\nint sigemptyset(sigset_t *mask);\nint sigfillset(sigset_t *mask);\nint sigismember(sigset_t *mask, int signo); /* 1 - is, 0 - not, -1 error */\nint sigpending(sigset_t *set);\nint sigprocmask(int how, sigset_t *set, sigset_t *oldset);\nint sigsuspend(sigset_t *sigmask);\nint sigaction(int sig, struct sigaction *act, struct sigaction *oldact);\n\n#endif /* _SIGNAL_H */",
        "#ifndef _SYS_TYPES_H\n#define _SYS_TYPES_H\n\n#ifndef _SIZE_T\n#define _SIZE_T\ntypedef unsigned int size_t;\n#endif\n\n#ifndef _TIME_T\n#define _TIME_T\ntypedef long time_t;\n#endif\n\n#ifndef _PTRDIFF_T\n#define _PTRDIFF_T\ntypedef long ptrdiff_t;\n#endif\n\n#ifndef NULL\n#define NULL ((void *) 0)\n#endif\n\ntypedef int pid_t;\ntypedef unsigned short uid_t;\ntypedef unsigned char gid_t;\ntypedef unsigned short dev_t;\ntypedef unsigned short ino_t;\ntypedef unsigned short mode_t;\ntypedef unsigned short umode_t;\ntypedef unsigned char nlink_t;\ntypedef int daddr_t;\ntypedef long off_t;\ntypedef unsigned char u_char;\ntypedef unsigned short ushort;\n\ntypedef struct { int quot,rem; } div_t;\ntypedef struct { long quot,rem; } ldiv_t;\n\nstruct ustat {\n\tdaddr_t f_tfree;\n\tino_t f_tinode;\n\tchar f_fname[6];\n\tchar f_fpack[6];\n};\n\n#endif",
        "#ifndef _TIMES_H\n#define _TIMES_H\n\n#include <sys/types.h>\n\nstruct tms {\n\ttime_t tms_utime;\n\ttime_t tms_stime;\n\ttime_t tms_cutime;\n\ttime_t tms_cstime;\n};\n\nextern time_t times(struct tms * tp);\n\n#endif",
        "#ifndef _SYS_WAIT_H\n#define _SYS_WAIT_H\n\n#include <sys/types.h>\n\n#define _LOW(v)\t\t( (v) & 0377)\n#define _HIGH(v)\t( ((v) >> 8) & 0377)\n\n/* options for waitpid, WUNTRACED not supported */\n#define WNOHANG\t\t1\n#define WUNTRACED\t2\n\n#define WIFEXITED(s)\t(!((s)&0xFF)\n#define WIFSTOPPED(s)\t(((s)&0xFF)==0x7F)\n#define WEXITSTATUS(s)\t(((s)>>8)&0xFF)\n#define WTERMSIG(s)\t((s)&0x7F)\n#define WSTOPSIG(s)\t(((s)>>8)&0xFF)\n#define WIFSIGNALED(s)\t(((unsigned int)(s)-1 & 0xFFFF) < 0xFF)\n\npid_t wait(int *stat_loc);\npid_t waitpid(pid_t pid, int *stat_loc, int options);\n\n#endif",
        "#ifndef _SYS_STAT_H\n#define _SYS_STAT_H\n\n#include <sys/types.h>\n\nstruct stat {\n\tdev_t\tst_dev;\n\tino_t\tst_ino;\n\tumode_t\tst_mode;\n\tnlink_t\tst_nlink;\n\tuid_t\tst_uid;\n\tgid_t\tst_gid;\n\tdev_t\tst_rdev;\n\toff_t\tst_size;\n\ttime_t\tst_atime;\n\ttime_t\tst_mtime;\n\ttime_t\tst_ctime;\n};\n\n#define S_IFMT  00170000\n#define S_IFLNK\t 0120000\n#define S_IFREG  0100000\n#define S_IFBLK  0060000\n#define S_IFDIR  0040000\n#define S_IFCHR  0020000\n#define S_IFIFO  0010000\n#define S_ISUID  0004000\n#define S_ISGID  0002000\n#define S_ISVTX  0001000\n\n#define S_ISLNK(m)\t(((m) & S_IFMT) == S_IFLNK)\n#define S_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\n#define S_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n#define S_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\n#define S_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\n#define S_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\n\n#define S_IRWXU 00700\n#define S_IRUSR 00400\n#define S_IWUSR 00200\n#define S_IXUSR 00100\n\n#define S_IRWXG 00070\n#define S_IRGRP 00040\n#define S_IWGRP 00020\n#define S_IXGRP 00010\n\n#define S_IRWXO 00007\n#define S_IROTH 00004\n#define S_IWOTH 00002\n#define S_IXOTH 00001\n\nextern int chmod(const char *_path, mode_t mode);\nextern int fstat(int fildes, struct stat *stat_buf);\nextern int mkdir(const char *_path, mode_t mode);\nextern int mkfifo(const char *_path, mode_t mode);\nextern int stat(const char *filename, struct stat *stat_buf);\nextern mode_t umask(mode_t mask);\n\n#endif",
        "#ifndef _SYS_UTSNAME_H\n#define _SYS_UTSNAME_H\n\n#include <sys/types.h>\n\nstruct utsname {\n\tchar sysname[9];\n\tchar nodename[9];\n\tchar release[9];\n\tchar version[9];\n\tchar machine[9];\n};\n\nextern int uname(struct utsname * utsbuf);\n\n#endif",
        "#ifndef _CTYPE_H\n#define _CTYPE_H\n\n#define _U\t0x01\t/* upper */\n#define _L\t0x02\t/* lower */\n#define _D\t0x04\t/* digit */\n#define _C\t0x08\t/* cntrl */\n#define _P\t0x10\t/* punct */\n#define _S\t0x20\t/* white space (space/lf/tab) */\n#define _X\t0x40\t/* hex digit */\n#define _SP\t0x80\t/* hard space (0x20) */\n\nextern unsigned char _ctype[];\nextern char _ctmp;\n\n#define isalnum(c) ((_ctype+1)[c]&(_U|_L|_D))\n#define isalpha(c) ((_ctype+1)[c]&(_U|_L))\n#define iscntrl(c) ((_ctype+1)[c]&(_C))\n#define isdigit(c) ((_ctype+1)[c]&(_D))\n#define isgraph(c) ((_ctype+1)[c]&(_P|_U|_L|_D))\n#define islower(c) ((_ctype+1)[c]&(_L))\n#define isprint(c) ((_ctype+1)[c]&(_P|_U|_L|_D|_SP))\n#define ispunct(c) ((_ctype+1)[c]&(_P))\n#define isspace(c) ((_ctype+1)[c]&(_S))\n#define isupper(c) ((_ctype+1)[c]&(_U))\n#define isxdigit(c) ((_ctype+1)[c]&(_D|_X))\n\n#define isascii(c) (((unsigned) c)<=0x7f)\n#define toascii(c) (((unsigned) c)&0x7f)\n\n#define tolower(c) (_ctmp=c,isupper(_ctmp)?_ctmp-('A'-'a'):_ctmp)\n#define toupper(c) (_ctmp=c,islower(_ctmp)?_ctmp-('a'-'A'):_ctmp)\n\n#endif",
        "#ifndef _HEAD_H\n#define _HEAD_H\n\ntypedef struct desc_struct {\n\tunsigned long a,b;\n} desc_table[256];\n\nextern unsigned long pg_dir[1024];\nextern desc_table idt,gdt;\n\n#define GDT_NUL 0\n#define GDT_CODE 1\n#define GDT_DATA 2\n#define GDT_TMP 3\n\n#define LDT_NUL 0\n#define LDT_CODE 1\n#define LDT_DATA 2\n\n#endif",
        "/*\n * 'tty.h' defines some structures used by tty_io.c and some defines.\n *\n * NOTE! Don't touch this without checking that nothing in rs_io.s or\n * con_io.s breaks. Some constants are hardwired into the system (mainly\n * offsets into 'tty_queue'\n */\n\n#ifndef _TTY_H\n#define _TTY_H\n\n#include <termios.h>\n\n#define TTY_BUF_SIZE 1024\n\nstruct tty_queue {\n\tunsigned long data;\n\tunsigned long head;\n\tunsigned long tail;\n\tstruct task_struct * proc_list;\n\tchar buf[TTY_BUF_SIZE];\n};\n\n#define INC(a) ((a) = ((a)+1) & (TTY_BUF_SIZE-1))\n#define DEC(a) ((a) = ((a)-1) & (TTY_BUF_SIZE-1))\n#define EMPTY(a) ((a).head == (a).tail)\n#define LEFT(a) (((a).tail-(a).head-1)&(TTY_BUF_SIZE-1))\n#define LAST(a) ((a).buf[(TTY_BUF_SIZE-1)&((a).head-1)])\n#define FULL(a) (!LEFT(a))\n#define CHARS(a) (((a).head-(a).tail)&(TTY_BUF_SIZE-1))\n#define GETCH(queue,c) \\\n(void)({c=(queue).buf[(queue).tail];INC((queue).tail);})\n#define PUTCH(c,queue) \\\n(void)({(queue).buf[(queue).head]=(c);INC((queue).head);})\n\n#define INTR_CHAR(tty) ((tty)->termios.c_cc[VINTR])\n#define QUIT_CHAR(tty) ((tty)->termios.c_cc[VQUIT])\n#define ERASE_CHAR(tty) ((tty)->termios.c_cc[VERASE])\n#define KILL_CHAR(tty) ((tty)->termios.c_cc[VKILL])\n#define EOF_CHAR(tty) ((tty)->termios.c_cc[VEOF])\n#define START_CHAR(tty) ((tty)->termios.c_cc[VSTART])\n#define STOP_CHAR(tty) ((tty)->termios.c_cc[VSTOP])\n#define SUSPEND_CHAR(tty) ((tty)->termios.c_cc[VSUSP])\n\nstruct tty_struct {\n\tstruct termios termios;\n\tint pgrp;\n\tint stopped;\n\tvoid (*write)(struct tty_struct * tty);\n\tstruct tty_queue read_q;\n\tstruct tty_queue write_q;\n\tstruct tty_queue secondary;\n\t};\n\nextern struct tty_struct tty_table[];\n\n/*\tintr=^C\t\tquit=^|\t\terase=del\tkill=^U\n\teof=^D\t\tvtime=\\0\tvmin=\\1\t\tsxtc=\\0\n\tstart=^Q\tstop=^S\t\tsusp=^Z\t\teol=\\0\n\treprint=^R\tdiscard=^U\twerase=^W\tlnext=^V\n\teol2=\\0\n*/\n#define INIT_C_CC \"\\003\\034\\177\\025\\004\\0\\1\\0\\021\\023\\032\\0\\022\\017\\027\\026\\0\"\n\nvoid rs_init(void);\nvoid con_init(void);\nvoid tty_init(void);\n\nint tty_read(unsigned c, char * buf, int n);\nint tty_write(unsigned c, char * buf, int n);\n\nvoid rs_write(struct tty_struct * tty);\nvoid con_write(struct tty_struct * tty);\n\nvoid copy_to_cooked(struct tty_struct * tty);\n\n#endif",
        "#ifndef _CONFIG_H\n#define _CONFIG_H\n\n/*\n * The root-device is no longer hard-coded. You can change the default\n * root-device by changing the line ROOT_DEV = XXX in boot/bootsect.s\n */\n\n/*\n * define your keyboard here -\n * KBD_FINNISH for Finnish keyboards\n * KBD_US for US-type\n * KBD_GR for German keyboards\n * KBD_FR for Frech keyboard\n */\n#define KBD_US \n/*#define KBD_GR */\n/*#define KBD_FR */\n/*#define KBD_FINNISH */\n\n/*\n * Normally, Linux can get the drive parameters from the BIOS at\n * startup, but if this for some unfathomable reason fails, you'd\n * be left stranded. For this case, you can define HD_TYPE, which\n * contains all necessary info on your harddisk.\n *\n * The HD_TYPE macro should look like this:\n *\n * #define HD_TYPE { head, sect, cyl, wpcom, lzone, ctl}\n *\n * In case of two harddisks, the info should be sepatated by\n * commas:\n *\n * #define HD_TYPE { h,s,c,wpcom,lz,ctl },{ h,s,c,wpcom,lz,ctl }\n */\n/*\n This is an example, two drives, first is type 2, second is type 3:\n\n#define HD_TYPE { 4,17,615,300,615,8 }, { 6,17,615,300,615,0 }\n\n NOTE: ctl is 0 for all drives with heads<=8, and ctl=8 for drives\n with more than 8 heads.\n\n If you want the BIOS to tell what kind of drive you have, just\n leave HD_TYPE undefined. This is the normal thing to do.\n*/\n\n#endif",
        "#ifndef _MM_H\n#define _MM_H\n\n#define PAGE_SIZE 4096\n\nextern unsigned long get_free_page(void);\nextern unsigned long put_page(unsigned long page,unsigned long address);\nextern void free_page(unsigned long addr);\n\n#endif",
        "/*\n * This file contains some defines for the AT-hd-controller.\n * Various sources. Check out some definitions (see comments with\n * a ques).\n */\n#ifndef _HDREG_H\n#define _HDREG_H\n\n/* Hd controller regs. Ref: IBM AT Bios-listing */\n#define HD_DATA\t\t0x1f0\t/* _CTL when writing */\n#define HD_ERROR\t0x1f1\t/* see err-bits */\n#define HD_NSECTOR\t0x1f2\t/* nr of sectors to read/write */\n#define HD_SECTOR\t0x1f3\t/* starting sector */\n#define HD_LCYL\t\t0x1f4\t/* starting cylinder */\n#define HD_HCYL\t\t0x1f5\t/* high byte of starting cyl */\n#define HD_CURRENT\t0x1f6\t/* 101dhhhh , d=drive, hhhh=head */\n#define HD_STATUS\t0x1f7\t/* see status-bits */\n#define HD_PRECOMP HD_ERROR\t/* same io address, read=error, write=precomp */\n#define HD_COMMAND HD_STATUS\t/* same io address, read=status, write=cmd */\n\n#define HD_CMD\t\t0x3f6\n\n/* Bits of HD_STATUS */\n#define ERR_STAT\t0x01\n#define INDEX_STAT\t0x02\n#define ECC_STAT\t0x04\t/* Corrected error */\n#define DRQ_STAT\t0x08\n#define SEEK_STAT\t0x10\n#define WRERR_STAT\t0x20\n#define READY_STAT\t0x40\n#define BUSY_STAT\t0x80\n\n/* Values for HD_COMMAND */\n#define WIN_RESTORE\t\t0x10\n#define WIN_READ\t\t0x20\n#define WIN_WRITE\t\t0x30\n#define WIN_VERIFY\t\t0x40\n#define WIN_FORMAT\t\t0x50\n#define WIN_INIT\t\t0x60\n#define WIN_SEEK \t\t0x70\n#define WIN_DIAGNOSE\t\t0x90\n#define WIN_SPECIFY\t\t0x91\n\n/* Bits for HD_ERROR */\n#define MARK_ERR\t0x01\t/* Bad address mark ? */\n#define TRK0_ERR\t0x02\t/* couldn't find track 0 */\n#define ABRT_ERR\t0x04\t/* ? */\n#define ID_ERR\t\t0x10\t/* ? */\n#define ECC_ERR\t\t0x40\t/* ? */\n#define\tBBD_ERR\t\t0x80\t/* ? */\n\nstruct partition {\n\tunsigned char boot_ind;\t\t/* 0x80 - active (unused) */\n\tunsigned char head;\t\t/* ? */\n\tunsigned char sector;\t\t/* ? */\n\tunsigned char cyl;\t\t/* ? */\n\tunsigned char sys_ind;\t\t/* ? */\n\tunsigned char end_head;\t\t/* ? */\n\tunsigned char end_sector;\t/* ? */\n\tunsigned char end_cyl;\t\t/* ? */\n\tunsigned int start_sect;\t/* starting sector counting from 0 */\n\tunsigned int nr_sects;\t\t/* nr of sectors in partition */\n};\n\n#endif",
        "/*\n * This file contains some defines for the floppy disk controller.\n * Various sources. Mostly \"IBM Microcomputers: A Programmers\n * Handbook\", Sanches and Canton.\n */\n#ifndef _FDREG_H\n#define _FDREG_H\n\nextern int ticks_to_floppy_on(unsigned int nr);\nextern void floppy_on(unsigned int nr);\nextern void floppy_off(unsigned int nr);\nextern void floppy_select(unsigned int nr);\nextern void floppy_deselect(unsigned int nr);\n\n/* Fd controller regs. S&C, about page 340 */\n#define FD_STATUS\t0x3f4\n#define FD_DATA\t\t0x3f5\n#define FD_DOR\t\t0x3f2\t\t/* Digital Output Register */\n#define FD_DIR\t\t0x3f7\t\t/* Digital Input Register (read) */\n#define FD_DCR\t\t0x3f7\t\t/* Diskette Control Register (write)*/\n\n/* Bits of main status register */\n#define STATUS_BUSYMASK\t0x0F\t\t/* drive busy mask */\n#define STATUS_BUSY\t0x10\t\t/* FDC busy */\n#define STATUS_DMA\t0x20\t\t/* 0- DMA mode */\n#define STATUS_DIR\t0x40\t\t/* 0- cpu->fdc */\n#define STATUS_READY\t0x80\t\t/* Data reg ready */\n\n/* Bits of FD_ST0 */\n#define ST0_DS\t\t0x03\t\t/* drive select mask */\n#define ST0_HA\t\t0x04\t\t/* Head (Address) */\n#define ST0_NR\t\t0x08\t\t/* Not Ready */\n#define ST0_ECE\t\t0x10\t\t/* Equipment chech error */\n#define ST0_SE\t\t0x20\t\t/* Seek end */\n#define ST0_INTR\t0xC0\t\t/* Interrupt code mask */\n\n/* Bits of FD_ST1 */\n#define ST1_MAM\t\t0x01\t\t/* Missing Address Mark */\n#define ST1_WP\t\t0x02\t\t/* Write Protect */\n#define ST1_ND\t\t0x04\t\t/* No Data - unreadable */\n#define ST1_OR\t\t0x10\t\t/* OverRun */\n#define ST1_CRC\t\t0x20\t\t/* CRC error in data or addr */\n#define ST1_EOC\t\t0x80\t\t/* End Of Cylinder */\n\n/* Bits of FD_ST2 */\n#define ST2_MAM\t\t0x01\t\t/* Missing Addess Mark (again) */\n#define ST2_BC\t\t0x02\t\t/* Bad Cylinder */\n#define ST2_SNS\t\t0x04\t\t/* Scan Not Satisfied */\n#define ST2_SEH\t\t0x08\t\t/* Scan Equal Hit */\n#define ST2_WC\t\t0x10\t\t/* Wrong Cylinder */\n#define ST2_CRC\t\t0x20\t\t/* CRC error in data field */\n#define ST2_CM\t\t0x40\t\t/* Control Mark = deleted */\n\n/* Bits of FD_ST3 */\n#define ST3_HA\t\t0x04\t\t/* Head (Address) */\n#define ST3_TZ\t\t0x10\t\t/* Track Zero signal (1=track 0) */\n#define ST3_WP\t\t0x40\t\t/* Write Protect */\n\n/* Values for FD_COMMAND */\n#define FD_RECALIBRATE\t0x07\t\t/* move to track 0 */\n#define FD_SEEK\t\t0x0F\t\t/* seek track */\n#define FD_READ\t\t0xE6\t\t/* read with MT, MFM, SKip deleted */\n#define FD_WRITE\t0xC5\t\t/* write with MT, MFM */\n#define FD_SENSEI\t0x08\t\t/* Sense Interrupt Status */\n#define FD_SPECIFY\t0x03\t\t/* specify HUT etc */\n\n/* DMA commands */\n#define DMA_READ\t0x46\n#define DMA_WRITE\t0x4A\n\n#endif",
        "/*\n * 'kernel.h' contains some often-used function prototypes etc\n */\nvoid verify_area(void * addr,int count);\nvolatile void panic(const char * str);\nint printf(const char * fmt, ...);\nint printk(const char * fmt, ...);\nint tty_write(unsigned ch,char * buf,int count);\nvoid * malloc(unsigned int size);\nvoid free_s(void * obj, int size);\n\n#define free(x) free_s((x), 0)\n\n/*\n * This is defined as a macro, but at some point this might become a\n * real subroutine that sets a flag if it returns true (to do\n * BSD-style accounting where the process is flagged if it uses root\n * privs).  The implication of this is that you should do normal\n * permissions checks first, and check suser() last.\n */\n#define suser() (current->euid == 0)\n",
        "/*\n * Why isn't this a .c file?  Enquiring minds....\n */\n\nextern int sys_setup();\nextern int sys_exit();\nextern int sys_fork();\nextern int sys_read();\nextern int sys_write();\nextern int sys_open();\nextern int sys_close();\nextern int sys_waitpid();\nextern int sys_creat();\nextern int sys_link();\nextern int sys_unlink();\nextern int sys_execve();\nextern int sys_chdir();\nextern int sys_time();\nextern int sys_mknod();\nextern int sys_chmod();\nextern int sys_chown();\nextern int sys_break();\nextern int sys_stat();\nextern int sys_lseek();\nextern int sys_getpid();\nextern int sys_mount();\nextern int sys_umount();\nextern int sys_setuid();\nextern int sys_getuid();\nextern int sys_stime();\nextern int sys_ptrace();\nextern int sys_alarm();\nextern int sys_fstat();\nextern int sys_pause();\nextern int sys_utime();\nextern int sys_stty();\nextern int sys_gtty();\nextern int sys_access();\nextern int sys_nice();\nextern int sys_ftime();\nextern int sys_sync();\nextern int sys_kill();\nextern int sys_rename();\nextern int sys_mkdir();\nextern int sys_rmdir();\nextern int sys_dup();\nextern int sys_pipe();\nextern int sys_times();\nextern int sys_prof();\nextern int sys_brk();\nextern int sys_setgid();\nextern int sys_getgid();\nextern int sys_signal();\nextern int sys_geteuid();\nextern int sys_getegid();\nextern int sys_acct();\nextern int sys_phys();\nextern int sys_lock();\nextern int sys_ioctl();\nextern int sys_fcntl();\nextern int sys_mpx();\nextern int sys_setpgid();\nextern int sys_ulimit();\nextern int sys_uname();\nextern int sys_umask();\nextern int sys_chroot();\nextern int sys_ustat();\nextern int sys_dup2();\nextern int sys_getppid();\nextern int sys_getpgrp();\nextern int sys_setsid();\nextern int sys_sigaction();\nextern int sys_sgetmask();\nextern int sys_ssetmask();\nextern int sys_setreuid();\nextern int sys_setregid();\nextern int sys_sigpending();\nextern int sys_sigsuspend();\nextern int sys_sethostname();\nextern int sys_setrlimit();\nextern int sys_getrlimit();\nextern int sys_getrusage();\nextern int sys_gettimeofday();\nextern int sys_settimeofday();\nextern int sys_getgroups();\nextern int sys_setgroups();\nextern int sys_select();\nextern int sys_symlink();\nextern int sys_lstat();\nextern int sys_readlink();\nextern int sys_uselib();\n\nfn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,\nsys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,\nsys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,\nsys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,\nsys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,\nsys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,\nsys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,\nsys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,\nsys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,\nsys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,\nsys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,\nsys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,\nsys_setreuid,sys_setregid, sys_sigsuspend, sys_sigpending, sys_sethostname,\nsys_setrlimit, sys_getrlimit, sys_getrusage, sys_gettimeofday, \nsys_settimeofday, sys_getgroups, sys_setgroups, sys_select, sys_symlink,\nsys_lstat, sys_readlink, sys_uselib };\n\n/* So we don't have to do any more manual updating.... */\nint NR_syscalls = sizeof(sys_call_table)/sizeof(fn_ptr);",
        "#ifndef _SCHED_H\n#define _SCHED_H\n\n#define NR_TASKS 64\n#define HZ 100\n\n#define FIRST_TASK task[0]\n#define LAST_TASK task[NR_TASKS-1]\n\n#include <linux/head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <signal.h>\n\n#if (NR_OPEN > 32)\n#error \"Currently the close-on-exec-flags are in one word, max 32 files/proc\"\n#endif\n\n#define TASK_RUNNING\t\t0\n#define TASK_INTERRUPTIBLE\t1\n#define TASK_UNINTERRUPTIBLE\t2\n#define TASK_ZOMBIE\t\t3\n#define TASK_STOPPED\t\t4\n\n#ifndef NULL\n#define NULL ((void *) 0)\n#endif\n\nextern int copy_page_tables(unsigned long from, unsigned long to, long size);\nextern int free_page_tables(unsigned long from, unsigned long size);\n\nextern void sched_init(void);\nextern void schedule(void);\nextern void trap_init(void);\nextern void panic(const char * str);\nextern int tty_write(unsigned minor,char * buf,int count);\n\ntypedef int (*fn_ptr)();\n\nstruct i387_struct {\n\tlong\tcwd;\n\tlong\tswd;\n\tlong\ttwd;\n\tlong\tfip;\n\tlong\tfcs;\n\tlong\tfoo;\n\tlong\tfos;\n\tlong\tst_space[20];\t/* 8*10 bytes for each FP-reg = 80 bytes */\n};\n\nstruct tss_struct {\n\tlong\tback_link;\t/* 16 high bits zero */\n\tlong\tesp0;\n\tlong\tss0;\t\t/* 16 high bits zero */\n\tlong\tesp1;\n\tlong\tss1;\t\t/* 16 high bits zero */\n\tlong\tesp2;\n\tlong\tss2;\t\t/* 16 high bits zero */\n\tlong\tcr3;\n\tlong\teip;\n\tlong\teflags;\n\tlong\teax,ecx,edx,ebx;\n\tlong\tesp;\n\tlong\tebp;\n\tlong\tesi;\n\tlong\tedi;\n\tlong\tes;\t\t/* 16 high bits zero */\n\tlong\tcs;\t\t/* 16 high bits zero */\n\tlong\tss;\t\t/* 16 high bits zero */\n\tlong\tds;\t\t/* 16 high bits zero */\n\tlong\tfs;\t\t/* 16 high bits zero */\n\tlong\tgs;\t\t/* 16 high bits zero */\n\tlong\tldt;\t\t/* 16 high bits zero */\n\tlong\ttrace_bitmap;\t/* bits: trace 0, bitmap 16-31 */\n\tstruct i387_struct i387;\n};\n\nstruct task_struct {\n/* these are hardcoded - don't touch */\n\tlong state;\t/* -1 unrunnable, 0 runnable, >0 stopped */\n\tlong counter;\n\tlong priority;\n\tlong signal;\n\tstruct sigaction sigaction[32];\n\tlong blocked;\t/* bitmap of masked signals */\n/* various fields */\n\tint exit_code;\n\tunsigned long start_code,end_code,end_data,brk,start_stack;\n\tlong pid,father,pgrp,session,leader;\n\tunsigned short uid,euid,suid;\n\tunsigned short gid,egid,sgid;\n\tlong alarm;\n\tlong utime,stime,cutime,cstime,start_time;\n\tunsigned short used_math;\n/* file system info */\n\tint tty;\t\t/* -1 if no tty, so it must be signed */\n\tunsigned short umask;\n\tstruct m_inode * pwd;\n\tstruct m_inode * root;\n\tstruct m_inode * executable;\n\tunsigned long close_on_exec;\n\tstruct file * filp[NR_OPEN];\n/* ldt for this task 0 - zero 1 - cs 2 - ds&ss */\n\tstruct desc_struct ldt[3];\n/* tss for this task */\n\tstruct tss_struct tss;\n};\n\n/*\n *  INIT_TASK is used to set up the first task table, touch at\n * your own risk!. Base=0, limit=0x9ffff (=640kB)\n */\n#define INIT_TASK \\\n/* state etc */\t{ 0,15,15, \\\n/* signals */\t0,{{},},0, \\\n/* ec,brk... */\t0,0,0,0,0,0, \\\n/* pid etc.. */\t0,-1,0,0,0, \\\n/* uid etc */\t0,0,0,0,0,0, \\\n/* alarm */\t0,0,0,0,0,0, \\\n/* math */\t0, \\\n/* fs info */\t-1,0022,NULL,NULL,NULL,0, \\\n/* filp */\t{NULL,}, \\\n\t{ \\\n\t\t{0,0}, \\\n/* ldt */\t{0x9f,0xc0fa00}, \\\n\t\t{0x9f,0xc0f200}, \\\n\t}, \\\n/*tss*/\t{0,PAGE_SIZE+(long)&init_task,0x10,0,0,0,0,(long)&pg_dir,\\\n\t 0,0,0,0,0,0,0,0, \\\n\t 0,0,0x17,0x17,0x17,0x17,0x17,0x17, \\\n\t _LDT(0),0x80000000, \\\n\t\t{} \\\n\t}, \\\n}\n\nextern struct task_struct *task[NR_TASKS];\nextern struct task_struct *last_task_used_math;\nextern struct task_struct *current;\nextern long volatile jiffies;\nextern long startup_time;\n\n#define CURRENT_TIME (startup_time+jiffies/HZ)\n\nextern void add_timer(long jiffies, void (*fn)(void));\nextern void sleep_on(struct task_struct ** p);\nextern void interruptible_sleep_on(struct task_struct ** p);\nextern void wake_up(struct task_struct ** p);\n\n/*\n * Entry into gdt where to find first TSS. 0-nul, 1-cs, 2-ds, 3-syscall\n * 4-TSS0, 5-LDT0, 6-TSS1 etc ...\n */\n#define FIRST_TSS_ENTRY 4\n#define FIRST_LDT_ENTRY (FIRST_TSS_ENTRY+1)\n#define _TSS(n) ((((unsigned long) n)<<4)+(FIRST_TSS_ENTRY<<3))\n#define _LDT(n) ((((unsigned long) n)<<4)+(FIRST_LDT_ENTRY<<3))\n#define ltr(n) __asm__(\"ltr %%ax\"::\"a\" (_TSS(n)))\n#define lldt(n) __asm__(\"lldt %%ax\"::\"a\" (_LDT(n)))\n#define str(n) \\\n__asm__(\"str %%ax\\n\\t\" \\\n\t\"subl %2,%%eax\\n\\t\" \\\n\t\"shrl $4,%%eax\" \\\n\t:\"=a\" (n) \\\n\t:\"a\" (0),\"i\" (FIRST_TSS_ENTRY<<3))\n/*\n *\tswitch_to(n) should switch tasks to task nr n, first\n * checking that n isn't the current task, in which case it does nothing.\n * This also clears the TS-flag if the task we switched to has used\n * tha math co-processor latest.\n */\n#define switch_to(n) {\\\nstruct {long a,b;} __tmp; \\\n__asm__(\"cmpl %%ecx,_current\\n\\t\" \\\n\t\"je 1f\\n\\t\" \\\n\t\"movw %%dx,%1\\n\\t\" \\\n\t\"xchgl %%ecx,_current\\n\\t\" \\\n\t\"ljmp %0\\n\\t\" \\\n\t\"cmpl %%ecx,_last_task_used_math\\n\\t\" \\\n\t\"jne 1f\\n\\t\" \\\n\t\"clts\\n\" \\\n\t\"1:\" \\\n\t::\"m\" (*&__tmp.a),\"m\" (*&__tmp.b), \\\n\t\"d\" (_TSS(n)),\"c\" ((long) task[n])); \\\n}\n\n#define PAGE_ALIGN(n) (((n)+0xfff)&0xfffff000)\n\n#define _set_base(addr,base) \\\n__asm__(\"movw %%dx,%0\\n\\t\" \\\n\t\"rorl $16,%%edx\\n\\t\" \\\n\t\"movb %%dl,%1\\n\\t\" \\\n\t\"movb %%dh,%2\" \\\n\t::\"m\" (*((addr)+2)), \\\n\t  \"m\" (*((addr)+4)), \\\n\t  \"m\" (*((addr)+7)), \\\n\t  \"d\" (base) \\\n\t:\"dx\")\n\n#define _set_limit(addr,limit) \\\n__asm__(\"movw %%dx,%0\\n\\t\" \\\n\t\"rorl $16,%%edx\\n\\t\" \\\n\t\"movb %1,%%dh\\n\\t\" \\\n\t\"andb $0xf0,%%dh\\n\\t\" \\\n\t\"orb %%dh,%%dl\\n\\t\" \\\n\t\"movb %%dl,%1\" \\\n\t::\"m\" (*(addr)), \\\n\t  \"m\" (*((addr)+6)), \\\n\t  \"d\" (limit) \\\n\t:\"dx\")\n\n#define set_base(ldt,base) _set_base( ((char *)&(ldt)) , base )\n#define set_limit(ldt,limit) _set_limit( ((char *)&(ldt)) , (limit-1)>>12 )\n\n#define _get_base(addr) ({\\\nunsigned long __base; \\\n__asm__(\"movb %3,%%dh\\n\\t\" \\\n\t\"movb %2,%%dl\\n\\t\" \\\n\t\"shll $16,%%edx\\n\\t\" \\\n\t\"movw %1,%%dx\" \\\n\t:\"=d\" (__base) \\\n\t:\"m\" (*((addr)+2)), \\\n\t \"m\" (*((addr)+4)), \\\n\t \"m\" (*((addr)+7))); \\\n__base;})\n\n#define get_base(ldt) _get_base( ((char *)&(ldt)) )\n\n#define get_limit(segment) ({ \\\nunsigned long __limit; \\\n__asm__(\"lsll %1,%0\\n\\tincl %0\":\"=r\" (__limit):\"r\" (segment)); \\\n__limit;})\n\n#endif",
        "/*\n * This file has definitions for some important file table\n * structures etc.\n */\n\n#ifndef _FS_H\n#define _FS_H\n\n#include <sys/types.h>\n\n/* devices are as follows: (same as minix, so we can use the minix\n * file system. These are major numbers.)\n *\n * 0 - unused (nodev)\n * 1 - /dev/mem\n * 2 - /dev/fd\n * 3 - /dev/hd\n * 4 - /dev/ttyx\n * 5 - /dev/tty\n * 6 - /dev/lp\n * 7 - unnamed pipes\n */\n\n#define IS_SEEKABLE(x) ((x)>=1 && (x)<=3)\n\n#define READ 0\n#define WRITE 1\n#define READA 2\t\t/* read-ahead - don't pause */\n#define WRITEA 3\t/* \"write-ahead\" - silly, but somewhat useful */\n\nvoid buffer_init(long buffer_end);\n\n#define MAJOR(a) (((unsigned)(a))>>8)\n#define MINOR(a) ((a)&0xff)\n\n#define NAME_LEN 14\n#define ROOT_INO 1\n\n#define I_MAP_SLOTS 8\n#define Z_MAP_SLOTS 8\n#define SUPER_MAGIC 0x137F\n\n#define NR_OPEN 20\n#define NR_INODE 32\n#define NR_FILE 64\n#define NR_SUPER 8\n#define NR_HASH 307\n#define NR_BUFFERS nr_buffers\n#define BLOCK_SIZE 1024\n#define BLOCK_SIZE_BITS 10\n#ifndef NULL\n#define NULL ((void *) 0)\n#endif\n\n#define INODES_PER_BLOCK ((BLOCK_SIZE)/(sizeof (struct d_inode)))\n#define DIR_ENTRIES_PER_BLOCK ((BLOCK_SIZE)/(sizeof (struct dir_entry)))\n\n#define PIPE_HEAD(inode) ((inode).i_zone[0])\n#define PIPE_TAIL(inode) ((inode).i_zone[1])\n#define PIPE_SIZE(inode) ((PIPE_HEAD(inode)-PIPE_TAIL(inode))&(PAGE_SIZE-1))\n#define PIPE_EMPTY(inode) (PIPE_HEAD(inode)==PIPE_TAIL(inode))\n#define PIPE_FULL(inode) (PIPE_SIZE(inode)==(PAGE_SIZE-1))\n#define INC_PIPE(head) \\\n__asm__(\"incl %0\\n\\tandl $4095,%0\"::\"m\" (head))\n\ntypedef char buffer_block[BLOCK_SIZE];\n\nstruct buffer_head {\n\tchar * b_data;\t\t\t/* pointer to data block (1024 bytes) */\n\tunsigned long b_blocknr;\t/* block number */\n\tunsigned short b_dev;\t\t/* device (0 = free) */\n\tunsigned char b_uptodate;\n\tunsigned char b_dirt;\t\t/* 0-clean,1-dirty */\n\tunsigned char b_count;\t\t/* users using this block */\n\tunsigned char b_lock;\t\t/* 0 - ok, 1 -locked */\n\tstruct task_struct * b_wait;\n\tstruct buffer_head * b_prev;\n\tstruct buffer_head * b_next;\n\tstruct buffer_head * b_prev_free;\n\tstruct buffer_head * b_next_free;\n};\n\nstruct d_inode {\n\tunsigned short i_mode;\n\tunsigned short i_uid;\n\tunsigned long i_size;\n\tunsigned long i_time;\n\tunsigned char i_gid;\n\tunsigned char i_nlinks;\n\tunsigned short i_zone[9];\n};\n\nstruct m_inode {\n\tunsigned short i_mode;\n\tunsigned short i_uid;\n\tunsigned long i_size;\n\tunsigned long i_mtime;\n\tunsigned char i_gid;\n\tunsigned char i_nlinks;\n\tunsigned short i_zone[9];\n/* these are in memory also */\n\tstruct task_struct * i_wait;\n\tunsigned long i_atime;\n\tunsigned long i_ctime;\n\tunsigned short i_dev;\n\tunsigned short i_num;\n\tunsigned short i_count;\n\tunsigned char i_lock;\n\tunsigned char i_dirt;\n\tunsigned char i_pipe;\n\tunsigned char i_mount;\n\tunsigned char i_seek;\n\tunsigned char i_update;\n};\n\nstruct file {\n\tunsigned short f_mode;\n\tunsigned short f_flags;\n\tunsigned short f_count;\n\tstruct m_inode * f_inode;\n\toff_t f_pos;\n};\n\nstruct super_block {\n\tunsigned short s_ninodes;\n\tunsigned short s_nzones;\n\tunsigned short s_imap_blocks;\n\tunsigned short s_zmap_blocks;\n\tunsigned short s_firstdatazone;\n\tunsigned short s_log_zone_size;\n\tunsigned long s_max_size;\n\tunsigned short s_magic;\n/* These are only in memory */\n\tstruct buffer_head * s_imap[8];\n\tstruct buffer_head * s_zmap[8];\n\tunsigned short s_dev;\n\tstruct m_inode * s_isup;\n\tstruct m_inode * s_imount;\n\tunsigned long s_time;\n\tstruct task_struct * s_wait;\n\tunsigned char s_lock;\n\tunsigned char s_rd_only;\n\tunsigned char s_dirt;\n};\n\nstruct d_super_block {\n\tunsigned short s_ninodes;\n\tunsigned short s_nzones;\n\tunsigned short s_imap_blocks;\n\tunsigned short s_zmap_blocks;\n\tunsigned short s_firstdatazone;\n\tunsigned short s_log_zone_size;\n\tunsigned long s_max_size;\n\tunsigned short s_magic;\n};\n\nstruct dir_entry {\n\tunsigned short inode;\n\tchar name[NAME_LEN];\n};\n\nextern struct m_inode inode_table[NR_INODE];\nextern struct file file_table[NR_FILE];\nextern struct super_block super_block[NR_SUPER];\nextern struct buffer_head * start_buffer;\nextern int nr_buffers;\n\nextern void check_disk_change(int dev);\nextern int floppy_change(unsigned int nr);\nextern int ticks_to_floppy_on(unsigned int dev);\nextern void floppy_on(unsigned int dev);\nextern void floppy_off(unsigned int dev);\nextern void truncate(struct m_inode * inode);\nextern void sync_inodes(void);\nextern void wait_on(struct m_inode * inode);\nextern int bmap(struct m_inode * inode,int block);\nextern int create_block(struct m_inode * inode,int block);\nextern struct m_inode * namei(const char * pathname);\nextern int open_namei(const char * pathname, int flag, int mode,\n\tstruct m_inode ** res_inode);\nextern void iput(struct m_inode * inode);\nextern struct m_inode * iget(int dev,int nr);\nextern struct m_inode * get_empty_inode(void);\nextern struct m_inode * get_pipe_inode(void);\nextern struct buffer_head * get_hash_table(int dev, int block);\nextern struct buffer_head * getblk(int dev, int block);\nextern void ll_rw_block(int rw, struct buffer_head * bh);\nextern void brelse(struct buffer_head * buf);\nextern struct buffer_head * bread(int dev,int block);\nextern void bread_page(unsigned long addr,int dev,int b[4]);\nextern struct buffer_head * breada(int dev,int block,...);\nextern int new_block(int dev);\nextern void free_block(int dev, int block);\nextern struct m_inode * new_inode(int dev);\nextern void free_inode(struct m_inode * inode);\nextern int sync_dev(int dev);\nextern struct super_block * get_super(int dev);\nextern int ROOT_DEV;\n\nextern void mount_root(void);\n\n#endif",
        "#ifndef _ERRNO_H\n#define _ERRNO_H\n\n/*\n * ok, as I hadn't got any other source of information about\n * possible error numbers, I was forced to use the same numbers\n * as minix.\n * Hopefully these are posix or something. I wouldn't know (and posix\n * isn't telling me - they want $$$ for their f***ing standard).\n *\n * We don't use the _SIGN cludge of minix, so kernel returns must\n * see to the sign by themselves.\n *\n * NOTE! Remember to change strerror() if you change this file!\n */\n\nextern int errno;\n\n#define ERROR\t\t99\n#define EPERM\t\t 1\n#define ENOENT\t\t 2\n#define ESRCH\t\t 3\n#define EINTR\t\t 4\n#define EIO\t\t 5\n#define ENXIO\t\t 6\n#define E2BIG\t\t 7\n#define ENOEXEC\t\t 8\n#define EBADF\t\t 9\n#define ECHILD\t\t10\n#define EAGAIN\t\t11\n#define ENOMEM\t\t12\n#define EACCES\t\t13\n#define EFAULT\t\t14\n#define ENOTBLK\t\t15\n#define EBUSY\t\t16\n#define EEXIST\t\t17\n#define EXDEV\t\t18\n#define ENODEV\t\t19\n#define ENOTDIR\t\t20\n#define EISDIR\t\t21\n#define EINVAL\t\t22\n#define ENFILE\t\t23\n#define EMFILE\t\t24\n#define ENOTTY\t\t25\n#define ETXTBSY\t\t26\n#define EFBIG\t\t27\n#define ENOSPC\t\t28\n#define ESPIPE\t\t29\n#define EROFS\t\t30\n#define EMLINK\t\t31\n#define EPIPE\t\t32\n#define EDOM\t\t33\n#define ERANGE\t\t34\n#define EDEADLK\t\t35\n#define ENAMETOOLONG\t36\n#define ENOLCK\t\t37\n#define ENOSYS\t\t38\n#define ENOTEMPTY\t39\n\n#endif",
        "#ifndef _TERMIOS_H\n#define _TERMIOS_H\n\n#define TTY_BUF_SIZE 1024\n\n/* 0x54 is just a magic number to make these relatively uniqe ('T') */\n\n#define TCGETS\t\t0x5401\n#define TCSETS\t\t0x5402\n#define TCSETSW\t\t0x5403\n#define TCSETSF\t\t0x5404\n#define TCGETA\t\t0x5405\n#define TCSETA\t\t0x5406\n#define TCSETAW\t\t0x5407\n#define TCSETAF\t\t0x5408\n#define TCSBRK\t\t0x5409\n#define TCXONC\t\t0x540A\n#define TCFLSH\t\t0x540B\n#define TIOCEXCL\t0x540C\n#define TIOCNXCL\t0x540D\n#define TIOCSCTTY\t0x540E\n#define TIOCGPGRP\t0x540F\n#define TIOCSPGRP\t0x5410\n#define TIOCOUTQ\t0x5411\n#define TIOCSTI\t\t0x5412\n#define TIOCGWINSZ\t0x5413\n#define TIOCSWINSZ\t0x5414\n#define TIOCMGET\t0x5415\n#define TIOCMBIS\t0x5416\n#define TIOCMBIC\t0x5417\n#define TIOCMSET\t0x5418\n#define TIOCGSOFTCAR\t0x5419\n#define TIOCSSOFTCAR\t0x541A\n#define TIOCINQ\t\t0x541B\n\nstruct winsize {\n\tunsigned short ws_row;\n\tunsigned short ws_col;\n\tunsigned short ws_xpixel;\n\tunsigned short ws_ypixel;\n};\n\n#define NCC 8\nstruct termio {\n\tunsigned short c_iflag;\t\t/* input mode flags */\n\tunsigned short c_oflag;\t\t/* output mode flags */\n\tunsigned short c_cflag;\t\t/* control mode flags */\n\tunsigned short c_lflag;\t\t/* local mode flags */\n\tunsigned char c_line;\t\t/* line discipline */\n\tunsigned char c_cc[NCC];\t/* control characters */\n};\n\n#define NCCS 17\nstruct termios {\n\tunsigned long c_iflag;\t\t/* input mode flags */\n\tunsigned long c_oflag;\t\t/* output mode flags */\n\tunsigned long c_cflag;\t\t/* control mode flags */\n\tunsigned long c_lflag;\t\t/* local mode flags */\n\tunsigned char c_line;\t\t/* line discipline */\n\tunsigned char c_cc[NCCS];\t/* control characters */\n};\n\n/* c_cc characters */\n#define VINTR 0\n#define VQUIT 1\n#define VERASE 2\n#define VKILL 3\n#define VEOF 4\n#define VTIME 5\n#define VMIN 6\n#define VSWTC 7\n#define VSTART 8\n#define VSTOP 9\n#define VSUSP 10\n#define VEOL 11\n#define VREPRINT 12\n#define VDISCARD 13\n#define VWERASE 14\n#define VLNEXT 15\n#define VEOL2 16\n\n/* c_iflag bits */\n#define IGNBRK\t0000001\n#define BRKINT\t0000002\n#define IGNPAR\t0000004\n#define PARMRK\t0000010\n#define INPCK\t0000020\n#define ISTRIP\t0000040\n#define INLCR\t0000100\n#define IGNCR\t0000200\n#define ICRNL\t0000400\n#define IUCLC\t0001000\n#define IXON\t0002000\n#define IXANY\t0004000\n#define IXOFF\t0010000\n#define IMAXBEL\t0020000\n\n/* c_oflag bits */\n#define OPOST\t0000001\n#define OLCUC\t0000002\n#define ONLCR\t0000004\n#define OCRNL\t0000010\n#define ONOCR\t0000020\n#define ONLRET\t0000040\n#define OFILL\t0000100\n#define OFDEL\t0000200\n#define NLDLY\t0000400\n#define   NL0\t0000000\n#define   NL1\t0000400\n#define CRDLY\t0003000\n#define   CR0\t0000000\n#define   CR1\t0001000\n#define   CR2\t0002000\n#define   CR3\t0003000\n#define TABDLY\t0014000\n#define   TAB0\t0000000\n#define   TAB1\t0004000\n#define   TAB2\t0010000\n#define   TAB3\t0014000\n#define   XTABS\t0014000\n#define BSDLY\t0020000\n#define   BS0\t0000000\n#define   BS1\t0020000\n#define VTDLY\t0040000\n#define   VT0\t0000000\n#define   VT1\t0040000\n#define FFDLY\t0040000\n#define   FF0\t0000000\n#define   FF1\t0040000\n\n/* c_cflag bit meaning */\n#define CBAUD\t0000017\n#define  B0\t0000000\t\t/* hang up */\n#define  B50\t0000001\n#define  B75\t0000002\n#define  B110\t0000003\n#define  B134\t0000004\n#define  B150\t0000005\n#define  B200\t0000006\n#define  B300\t0000007\n#define  B600\t0000010\n#define  B1200\t0000011\n#define  B1800\t0000012\n#define  B2400\t0000013\n#define  B4800\t0000014\n#define  B9600\t0000015\n#define  B19200\t0000016\n#define  B38400\t0000017\n#define EXTA B19200\n#define EXTB B38400\n#define CSIZE\t0000060\n#define   CS5\t0000000\n#define   CS6\t0000020\n#define   CS7\t0000040\n#define   CS8\t0000060\n#define CSTOPB\t0000100\n#define CREAD\t0000200\n#define CPARENB\t0000400\n#define CPARODD\t0001000\n#define HUPCL\t0002000\n#define CLOCAL\t0004000\n#define CIBAUD\t03600000\t\t/* input baud rate (not used) */\n#define CRTSCTS\t020000000000\t\t/* flow control */\n\n#define PARENB CPARENB\n#define PARODD CPARODD\n\n/* c_lflag bits */\n#define ISIG\t0000001\n#define ICANON\t0000002\n#define XCASE\t0000004\n#define ECHO\t0000010\n#define ECHOE\t0000020\n#define ECHOK\t0000040\n#define ECHONL\t0000100\n#define NOFLSH\t0000200\n#define TOSTOP\t0000400\n#define ECHOCTL\t0001000\n#define ECHOPRT\t0002000\n#define ECHOKE\t0004000\n#define FLUSHO\t0010000\n#define PENDIN\t0040000\n#define IEXTEN\t0100000\n\n/* modem lines */\n#define TIOCM_LE\t0x001\n#define TIOCM_DTR\t0x002\n#define TIOCM_RTS\t0x004\n#define TIOCM_ST\t0x008\n#define TIOCM_SR\t0x010\n#define TIOCM_CTS\t0x020\n#define TIOCM_CAR\t0x040\n#define TIOCM_RNG\t0x080\n#define TIOCM_DSR\t0x100\n#define TIOCM_CD\tTIOCM_CAR\n#define TIOCM_RI\tTIOCM_RNG\n\n/* tcflow() and TCXONC use these */\n#define\tTCOOFF\t\t0\n#define\tTCOON\t\t1\n#define\tTCIOFF\t\t2\n#define\tTCION\t\t3\n\n/* tcflush() and TCFLSH use these */\n#define\tTCIFLUSH\t0\n#define\tTCOFLUSH\t1\n#define\tTCIOFLUSH\t2\n\n/* tcsetattr uses these */\n#define\tTCSANOW\t\t0\n#define\tTCSADRAIN\t1\n#define\tTCSAFLUSH\t2\n\ntypedef int speed_t;\n\nextern speed_t cfgetispeed(struct termios *termios_p);\nextern speed_t cfgetospeed(struct termios *termios_p);\nextern int cfsetispeed(struct termios *termios_p, speed_t speed);\nextern int cfsetospeed(struct termios *termios_p, speed_t speed);\nextern int tcdrain(int fildes);\nextern int tcflow(int fildes, int action);\nextern int tcflush(int fildes, int queue_selector);\nextern int tcgetattr(int fildes, struct termios *termios_p);\nextern int tcsendbreak(int fildes, int duration);\nextern int tcsetattr(int fildes, int optional_actions,\n\tstruct termios *termios_p);\n\n#endif",
        "#ifndef _A_OUT_H\n#define _A_OUT_H\n\n#define __GNU_EXEC_MACROS__\n\nstruct exec {\n  unsigned long a_magic;\t/* Use macros N_MAGIC, etc for access */\n  unsigned a_text;\t\t/* length of text, in bytes */\n  unsigned a_data;\t\t/* length of data, in bytes */\n  unsigned a_bss;\t\t/* length of uninitialized data area for file, in bytes */\n  unsigned a_syms;\t\t/* length of symbol table data in file, in bytes */\n  unsigned a_entry;\t\t/* start address */\n  unsigned a_trsize;\t\t/* length of relocation info for text, in bytes */\n  unsigned a_drsize;\t\t/* length of relocation info for data, in bytes */\n};\n\n#ifndef N_MAGIC\n#define N_MAGIC(exec) ((exec).a_magic)\n#endif\n\n#ifndef OMAGIC\n/* Code indicating object file or impure executable.  */\n#define OMAGIC 0407\n/* Code indicating pure executable.  */\n#define NMAGIC 0410\n/* Code indicating demand-paged executable.  */\n#define ZMAGIC 0413\n#endif /* not OMAGIC */\n\n#ifndef N_BADMAG\n#define N_BADMAG(x)\t\t\t\t\t\\\n (N_MAGIC(x) != OMAGIC && N_MAGIC(x) != NMAGIC\t\t\\\n  && N_MAGIC(x) != ZMAGIC)\n#endif\n\n#define _N_BADMAG(x)\t\t\t\t\t\\\n (N_MAGIC(x) != OMAGIC && N_MAGIC(x) != NMAGIC\t\t\\\n  && N_MAGIC(x) != ZMAGIC)\n\n#define _N_HDROFF(x) (SEGMENT_SIZE - sizeof (struct exec))\n\n#ifndef N_TXTOFF\n#define N_TXTOFF(x) \\\n (N_MAGIC(x) == ZMAGIC ? _N_HDROFF((x)) + sizeof (struct exec) : sizeof (struct exec))\n#endif\n\n#ifndef N_DATOFF\n#define N_DATOFF(x) (N_TXTOFF(x) + (x).a_text)\n#endif\n\n#ifndef N_TRELOFF\n#define N_TRELOFF(x) (N_DATOFF(x) + (x).a_data)\n#endif\n\n#ifndef N_DRELOFF\n#define N_DRELOFF(x) (N_TRELOFF(x) + (x).a_trsize)\n#endif\n\n#ifndef N_SYMOFF\n#define N_SYMOFF(x) (N_DRELOFF(x) + (x).a_drsize)\n#endif\n\n#ifndef N_STROFF\n#define N_STROFF(x) (N_SYMOFF(x) + (x).a_syms)\n#endif\n\n/* Address of text segment in memory after it is loaded.  */\n#ifndef N_TXTADDR\n#define N_TXTADDR(x) 0\n#endif\n\n/* Address of data segment in memory after it is loaded.\n   Note that it is up to you to define SEGMENT_SIZE\n   on machines not listed here.  */\n#if defined(vax) || defined(hp300) || defined(pyr)\n#define SEGMENT_SIZE PAGE_SIZE\n#endif\n#ifdef\thp300\n#define\tPAGE_SIZE\t4096\n#endif\n#ifdef\tsony\n#define\tSEGMENT_SIZE\t0x2000\n#endif\t/* Sony.  */\n#ifdef is68k\n#define SEGMENT_SIZE 0x20000\n#endif\n#if defined(m68k) && defined(PORTAR)\n#define PAGE_SIZE 0x400\n#define SEGMENT_SIZE PAGE_SIZE\n#endif\n\n#define PAGE_SIZE 4096\n#define SEGMENT_SIZE 1024\n\n#define _N_SEGMENT_ROUND(x) (((x) + SEGMENT_SIZE - 1) & ~(SEGMENT_SIZE - 1))\n\n#define _N_TXTENDADDR(x) (N_TXTADDR(x)+(x).a_text)\n\n#ifndef N_DATADDR\n#define N_DATADDR(x) \\\n    (N_MAGIC(x)==OMAGIC? (_N_TXTENDADDR(x)) \\\n     : (_N_SEGMENT_ROUND (_N_TXTENDADDR(x))))\n#endif\n\n/* Address of bss segment in memory after it is loaded.  */\n#ifndef N_BSSADDR\n#define N_BSSADDR(x) (N_DATADDR(x) + (x).a_data)\n#endif\n\n#ifndef N_NLIST_DECLARED\nstruct nlist {\n  union {\n    char *n_name;\n    struct nlist *n_next;\n    long n_strx;\n  } n_un;\n  unsigned char n_type;\n  char n_other;\n  short n_desc;\n  unsigned long n_value;\n};\n#endif\n\n#ifndef N_UNDF\n#define N_UNDF 0\n#endif\n#ifndef N_ABS\n#define N_ABS 2\n#endif\n#ifndef N_TEXT\n#define N_TEXT 4\n#endif\n#ifndef N_DATA\n#define N_DATA 6\n#endif\n#ifndef N_BSS\n#define N_BSS 8\n#endif\n#ifndef N_COMM\n#define N_COMM 18\n#endif\n#ifndef N_FN\n#define N_FN 15\n#endif\n\n#ifndef N_EXT\n#define N_EXT 1\n#endif\n#ifndef N_TYPE\n#define N_TYPE 036\n#endif\n#ifndef N_STAB\n#define N_STAB 0340\n#endif\n\n/* The following type indicates the definition of a symbol as being\n   an indirect reference to another symbol.  The other symbol\n   appears as an undefined reference, immediately following this symbol.\n\n   Indirection is asymmetrical.  The other symbol's value will be used\n   to satisfy requests for the indirect symbol, but not vice versa.\n   If the other symbol does not have a definition, libraries will\n   be searched to find a definition.  */\n#define N_INDR 0xa\n\n/* The following symbols refer to set elements.\n   All the N_SET[ATDB] symbols with the same name form one set.\n   Space is allocated for the set in the text section, and each set\n   element's value is stored into one word of the space.\n   The first word of the space is the length of the set (number of elements).\n\n   The address of the set is made into an N_SETV symbol\n   whose name is the same as the name of the set.\n   This symbol acts like a N_DATA global symbol\n   in that it can satisfy undefined external references.  */\n\n/* These appear as input to LD, in a .o file.  */\n#define\tN_SETA\t0x14\t\t/* Absolute set element symbol */\n#define\tN_SETT\t0x16\t\t/* Text set element symbol */\n#define\tN_SETD\t0x18\t\t/* Data set element symbol */\n#define\tN_SETB\t0x1A\t\t/* Bss set element symbol */\n\n/* This is output from LD.  */\n#define N_SETV\t0x1C\t\t/* Pointer to set vector in data area.  */\n\n#ifndef N_RELOCATION_INFO_DECLARED\n\n/* This structure describes a single relocation to be performed.\n   The text-relocation section of the file is a vector of these structures,\n   all of which apply to the text section.\n   Likewise, the data-relocation section applies to the data section.  */\n\nstruct relocation_info\n{\n  /* Address (within segment) to be relocated.  */\n  int r_address;\n  /* The meaning of r_symbolnum depends on r_extern.  */\n  unsigned int r_symbolnum:24;\n  /* Nonzero means value is a pc-relative offset\n     and it should be relocated for changes in its own address\n     as well as for changes in the symbol or section specified.  */\n  unsigned int r_pcrel:1;\n  /* Length (as exponent of 2) of the field to be relocated.\n     Thus, a value of 2 indicates 1<<2 bytes.  */\n  unsigned int r_length:2;\n  /* 1 => relocate with value of symbol.\n          r_symbolnum is the index of the symbol\n\t  in file's the symbol table.\n     0 => relocate with the address of a segment.\n          r_symbolnum is N_TEXT, N_DATA, N_BSS or N_ABS\n\t  (the N_EXT bit may be set also, but signifies nothing).  */\n  unsigned int r_extern:1;\n  /* Four bits that aren't used, but when writing an object file\n     it is desirable to clear them.  */\n  unsigned int r_pad:4;\n};\n#endif /* no N_RELOCATION_INFO_DECLARED.  */\n\n\n#endif /* __A_OUT_GNU_H__ */",
        "#ifndef _STDARG_H\n#define _STDARG_H\n\ntypedef char *va_list;\n\n/* Amount of space required in an argument list for an arg of type TYPE.\n   TYPE may alternatively be an expression whose type is used.  */\n\n#define __va_rounded_size(TYPE)  \\\n  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n\n#ifndef __sparc__\n#define va_start(AP, LASTARG) \t\t\t\t\t\t\\\n (AP = ((char *) &(LASTARG) + __va_rounded_size (LASTARG)))\n#else\n#define va_start(AP, LASTARG) \t\t\t\t\t\t\\\n (__builtin_saveregs (),\t\t\t\t\t\t\\\n  AP = ((char *) &(LASTARG) + __va_rounded_size (LASTARG)))\n#endif\n\nvoid va_end (va_list);\t\t/* Defined in gnulib */\n#define va_end(AP)\n\n#define va_arg(AP, TYPE)\t\t\t\t\t\t\\\n (AP += __va_rounded_size (TYPE),\t\t\t\t\t\\\n  *((TYPE *) (AP - __va_rounded_size (TYPE))))\n\n#endif /* _STDARG_H */",
        "#ifndef _CONST_H\n#define _CONST_H\n\n#define BUFFER_END 0x200000\n\n#define I_TYPE          0170000\n#define I_DIRECTORY\t0040000\n#define I_REGULAR       0100000\n#define I_BLOCK_SPECIAL 0060000\n#define I_CHAR_SPECIAL  0020000\n#define I_NAMED_PIPE\t0010000\n#define I_SET_UID_BIT   0004000\n#define I_SET_GID_BIT   0002000\n\n#endif",
        "#ifndef _STRING_H_\n#define _STRING_H_\n\n#ifndef NULL\n#define NULL ((void *) 0)\n#endif\n\n#ifndef _SIZE_T\n#define _SIZE_T\ntypedef unsigned int size_t;\n#endif\n\nextern char * strerror(int errno);\n\n/*\n * This string-include defines all string functions as inline\n * functions. Use gcc. It also assumes ds=es=data space, this should be\n * normal. Most of the string-functions are rather heavily hand-optimized,\n * see especially strtok,strstr,str[c]spn. They should work, but are not\n * very easy to understand. Everything is done entirely within the register\n * set, making the functions fast and clean. String instructions have been\n * used through-out, making for \"slightly\" unclear code :-)\n *\n *\t\t(C) 1991 Linus Torvalds\n */\n \nextern inline char * strcpy(char * dest,const char *src)\n{\n__asm__(\"cld\\n\"\n\t\"1:\\tlodsb\\n\\t\"\n\t\"stosb\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"jne 1b\"\n\t::\"S\" (src),\"D\" (dest):\"si\",\"di\",\"ax\");\nreturn dest;\n}\n\nextern inline char * strncpy(char * dest,const char *src,int count)\n{\n__asm__(\"cld\\n\"\n\t\"1:\\tdecl %2\\n\\t\"\n\t\"js 2f\\n\\t\"\n\t\"lodsb\\n\\t\"\n\t\"stosb\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"jne 1b\\n\\t\"\n\t\"rep\\n\\t\"\n\t\"stosb\\n\"\n\t\"2:\"\n\t::\"S\" (src),\"D\" (dest),\"c\" (count):\"si\",\"di\",\"ax\",\"cx\");\nreturn dest;\n}\n\nextern inline char * strcat(char * dest,const char * src)\n{\n__asm__(\"cld\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"decl %1\\n\"\n\t\"1:\\tlodsb\\n\\t\"\n\t\"stosb\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"jne 1b\"\n\t::\"S\" (src),\"D\" (dest),\"a\" (0),\"c\" (0xffffffff):\"si\",\"di\",\"ax\",\"cx\");\nreturn dest;\n}\n\nextern inline char * strncat(char * dest,const char * src,int count)\n{\n__asm__(\"cld\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"decl %1\\n\\t\"\n\t\"movl %4,%3\\n\"\n\t\"1:\\tdecl %3\\n\\t\"\n\t\"js 2f\\n\\t\"\n\t\"lodsb\\n\\t\"\n\t\"stosb\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"jne 1b\\n\"\n\t\"2:\\txorl %2,%2\\n\\t\"\n\t\"stosb\"\n\t::\"S\" (src),\"D\" (dest),\"a\" (0),\"c\" (0xffffffff),\"g\" (count)\n\t:\"si\",\"di\",\"ax\",\"cx\");\nreturn dest;\n}\n\nextern inline int strcmp(const char * cs,const char * ct)\n{\nregister int __res __asm__(\"ax\");\n__asm__(\"cld\\n\"\n\t\"1:\\tlodsb\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"jne 2f\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"jne 1b\\n\\t\"\n\t\"xorl %%eax,%%eax\\n\\t\"\n\t\"jmp 3f\\n\"\n\t\"2:\\tmovl $1,%%eax\\n\\t\"\n\t\"jl 3f\\n\\t\"\n\t\"negl %%eax\\n\"\n\t\"3:\"\n\t:\"=a\" (__res):\"D\" (cs),\"S\" (ct):\"si\",\"di\");\nreturn __res;\n}\n\nextern inline int strncmp(const char * cs,const char * ct,int count)\n{\nregister int __res __asm__(\"ax\");\n__asm__(\"cld\\n\"\n\t\"1:\\tdecl %3\\n\\t\"\n\t\"js 2f\\n\\t\"\n\t\"lodsb\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"jne 3f\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"jne 1b\\n\"\n\t\"2:\\txorl %%eax,%%eax\\n\\t\"\n\t\"jmp 4f\\n\"\n\t\"3:\\tmovl $1,%%eax\\n\\t\"\n\t\"jl 4f\\n\\t\"\n\t\"negl %%eax\\n\"\n\t\"4:\"\n\t:\"=a\" (__res):\"D\" (cs),\"S\" (ct),\"c\" (count):\"si\",\"di\",\"cx\");\nreturn __res;\n}\n\nextern inline char * strchr(const char * s,char c)\n{\nregister char * __res __asm__(\"ax\");\n__asm__(\"cld\\n\\t\"\n\t\"movb %%al,%%ah\\n\"\n\t\"1:\\tlodsb\\n\\t\"\n\t\"cmpb %%ah,%%al\\n\\t\"\n\t\"je 2f\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"jne 1b\\n\\t\"\n\t\"movl $1,%1\\n\"\n\t\"2:\\tmovl %1,%0\\n\\t\"\n\t\"decl %0\"\n\t:\"=a\" (__res):\"S\" (s),\"0\" (c):\"si\");\nreturn __res;\n}\n\nextern inline char * strrchr(const char * s,char c)\n{\nregister char * __res __asm__(\"dx\");\n__asm__(\"cld\\n\\t\"\n\t\"movb %%al,%%ah\\n\"\n\t\"1:\\tlodsb\\n\\t\"\n\t\"cmpb %%ah,%%al\\n\\t\"\n\t\"jne 2f\\n\\t\"\n\t\"movl %%esi,%0\\n\\t\"\n\t\"decl %0\\n\"\n\t\"2:\\ttestb %%al,%%al\\n\\t\"\n\t\"jne 1b\"\n\t:\"=d\" (__res):\"0\" (0),\"S\" (s),\"a\" (c):\"ax\",\"si\");\nreturn __res;\n}\n\nextern inline int strspn(const char * cs, const char * ct)\n{\nregister char * __res __asm__(\"si\");\n__asm__(\"cld\\n\\t\"\n\t\"movl %4,%%edi\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"notl %%ecx\\n\\t\"\n\t\"decl %%ecx\\n\\t\"\n\t\"movl %%ecx,%%edx\\n\"\n\t\"1:\\tlodsb\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"je 2f\\n\\t\"\n\t\"movl %4,%%edi\\n\\t\"\n\t\"movl %%edx,%%ecx\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"je 1b\\n\"\n\t\"2:\\tdecl %0\"\n\t:\"=S\" (__res):\"a\" (0),\"c\" (0xffffffff),\"0\" (cs),\"g\" (ct)\n\t:\"ax\",\"cx\",\"dx\",\"di\");\nreturn __res-cs;\n}\n\nextern inline int strcspn(const char * cs, const char * ct)\n{\nregister char * __res __asm__(\"si\");\n__asm__(\"cld\\n\\t\"\n\t\"movl %4,%%edi\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"notl %%ecx\\n\\t\"\n\t\"decl %%ecx\\n\\t\"\n\t\"movl %%ecx,%%edx\\n\"\n\t\"1:\\tlodsb\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"je 2f\\n\\t\"\n\t\"movl %4,%%edi\\n\\t\"\n\t\"movl %%edx,%%ecx\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"jne 1b\\n\"\n\t\"2:\\tdecl %0\"\n\t:\"=S\" (__res):\"a\" (0),\"c\" (0xffffffff),\"0\" (cs),\"g\" (ct)\n\t:\"ax\",\"cx\",\"dx\",\"di\");\nreturn __res-cs;\n}\n\nextern inline char * strpbrk(const char * cs,const char * ct)\n{\nregister char * __res __asm__(\"si\");\n__asm__(\"cld\\n\\t\"\n\t\"movl %4,%%edi\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"notl %%ecx\\n\\t\"\n\t\"decl %%ecx\\n\\t\"\n\t\"movl %%ecx,%%edx\\n\"\n\t\"1:\\tlodsb\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"je 2f\\n\\t\"\n\t\"movl %4,%%edi\\n\\t\"\n\t\"movl %%edx,%%ecx\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"jne 1b\\n\\t\"\n\t\"decl %0\\n\\t\"\n\t\"jmp 3f\\n\"\n\t\"2:\\txorl %0,%0\\n\"\n\t\"3:\"\n\t:\"=S\" (__res):\"a\" (0),\"c\" (0xffffffff),\"0\" (cs),\"g\" (ct)\n\t:\"ax\",\"cx\",\"dx\",\"di\");\nreturn __res;\n}\n\nextern inline char * strstr(const char * cs,const char * ct)\n{\nregister char * __res __asm__(\"ax\");\n__asm__(\"cld\\n\\t\" \\\n\t\"movl %4,%%edi\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"notl %%ecx\\n\\t\"\n\t\"decl %%ecx\\n\\t\"\t/* NOTE! This also sets Z if searchstring='' */\n\t\"movl %%ecx,%%edx\\n\"\n\t\"1:\\tmovl %4,%%edi\\n\\t\"\n\t\"movl %%esi,%%eax\\n\\t\"\n\t\"movl %%edx,%%ecx\\n\\t\"\n\t\"repe\\n\\t\"\n\t\"cmpsb\\n\\t\"\n\t\"je 2f\\n\\t\"\t\t/* also works for empty string, see above */\n\t\"xchgl %%eax,%%esi\\n\\t\"\n\t\"incl %%esi\\n\\t\"\n\t\"cmpb $0,-1(%%eax)\\n\\t\"\n\t\"jne 1b\\n\\t\"\n\t\"xorl %%eax,%%eax\\n\\t\"\n\t\"2:\"\n\t:\"=a\" (__res):\"0\" (0),\"c\" (0xffffffff),\"S\" (cs),\"g\" (ct)\n\t:\"cx\",\"dx\",\"di\",\"si\");\nreturn __res;\n}\n\nextern inline int strlen(const char * s)\n{\nregister int __res __asm__(\"cx\");\n__asm__(\"cld\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"notl %0\\n\\t\"\n\t\"decl %0\"\n\t:\"=c\" (__res):\"D\" (s),\"a\" (0),\"0\" (0xffffffff):\"di\");\nreturn __res;\n}\n\nextern char * ___strtok;\n\nextern inline char * strtok(char * s,const char * ct)\n{\nregister char * __res __asm__(\"si\");\n__asm__(\"testl %1,%1\\n\\t\"\n\t\"jne 1f\\n\\t\"\n\t\"testl %0,%0\\n\\t\"\n\t\"je 8f\\n\\t\"\n\t\"movl %0,%1\\n\"\n\t\"1:\\txorl %0,%0\\n\\t\"\n\t\"movl $-1,%%ecx\\n\\t\"\n\t\"xorl %%eax,%%eax\\n\\t\"\n\t\"cld\\n\\t\"\n\t\"movl %4,%%edi\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"notl %%ecx\\n\\t\"\n\t\"decl %%ecx\\n\\t\"\n\t\"je 7f\\n\\t\"\t\t\t/* empty delimeter-string */\n\t\"movl %%ecx,%%edx\\n\"\n\t\"2:\\tlodsb\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"je 7f\\n\\t\"\n\t\"movl %4,%%edi\\n\\t\"\n\t\"movl %%edx,%%ecx\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"je 2b\\n\\t\"\n\t\"decl %1\\n\\t\"\n\t\"cmpb $0,(%1)\\n\\t\"\n\t\"je 7f\\n\\t\"\n\t\"movl %1,%0\\n\"\n\t\"3:\\tlodsb\\n\\t\"\n\t\"testb %%al,%%al\\n\\t\"\n\t\"je 5f\\n\\t\"\n\t\"movl %4,%%edi\\n\\t\"\n\t\"movl %%edx,%%ecx\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"jne 3b\\n\\t\"\n\t\"decl %1\\n\\t\"\n\t\"cmpb $0,(%1)\\n\\t\"\n\t\"je 5f\\n\\t\"\n\t\"movb $0,(%1)\\n\\t\"\n\t\"incl %1\\n\\t\"\n\t\"jmp 6f\\n\"\n\t\"5:\\txorl %1,%1\\n\"\n\t\"6:\\tcmpb $0,(%0)\\n\\t\"\n\t\"jne 7f\\n\\t\"\n\t\"xorl %0,%0\\n\"\n\t\"7:\\ttestl %0,%0\\n\\t\"\n\t\"jne 8f\\n\\t\"\n\t\"movl %0,%1\\n\"\n\t\"8:\"\n\t:\"=b\" (__res),\"=S\" (___strtok)\n\t:\"0\" (___strtok),\"1\" (s),\"g\" (ct)\n\t:\"ax\",\"cx\",\"dx\",\"di\");\nreturn __res;\n}\n\nextern inline void * memcpy(void * dest,const void * src, int n)\n{\n__asm__(\"cld\\n\\t\"\n\t\"rep\\n\\t\"\n\t\"movsb\"\n\t::\"c\" (n),\"S\" (src),\"D\" (dest)\n\t:\"cx\",\"si\",\"di\");\nreturn dest;\n}\n\nextern inline void * memmove(void * dest,const void * src, int n)\n{\nif (dest<src)\n__asm__(\"cld\\n\\t\"\n\t\"rep\\n\\t\"\n\t\"movsb\"\n\t::\"c\" (n),\"S\" (src),\"D\" (dest)\n\t:\"cx\",\"si\",\"di\");\nelse\n__asm__(\"std\\n\\t\"\n\t\"rep\\n\\t\"\n\t\"movsb\"\n\t::\"c\" (n),\"S\" (src+n-1),\"D\" (dest+n-1)\n\t:\"cx\",\"si\",\"di\");\nreturn dest;\n}\n\nextern inline int memcmp(const void * cs,const void * ct,int count)\n{\nregister int __res __asm__(\"ax\");\n__asm__(\"cld\\n\\t\"\n\t\"repe\\n\\t\"\n\t\"cmpsb\\n\\t\"\n\t\"je 1f\\n\\t\"\n\t\"movl $1,%%eax\\n\\t\"\n\t\"jl 1f\\n\\t\"\n\t\"negl %%eax\\n\"\n\t\"1:\"\n\t:\"=a\" (__res):\"0\" (0),\"D\" (cs),\"S\" (ct),\"c\" (count)\n\t:\"si\",\"di\",\"cx\");\nreturn __res;\n}\n\nextern inline void * memchr(const void * cs,char c,int count)\n{\nregister void * __res __asm__(\"di\");\nif (!count)\n\treturn NULL;\n__asm__(\"cld\\n\\t\"\n\t\"repne\\n\\t\"\n\t\"scasb\\n\\t\"\n\t\"je 1f\\n\\t\"\n\t\"movl $1,%0\\n\"\n\t\"1:\\tdecl %0\"\n\t:\"=D\" (__res):\"a\" (c),\"D\" (cs),\"c\" (count)\n\t:\"cx\");\nreturn __res;\n}\n\nextern inline void * memset(void * s,char c,int count)\n{\n__asm__(\"cld\\n\\t\"\n\t\"rep\\n\\t\"\n\t\"stosb\"\n\t::\"a\" (c),\"D\" (s),\"c\" (count)\n\t:\"cx\",\"di\");\nreturn s;\n}\n\n#endif",
        "#ifndef _BLK_H\n#define _BLK_H\n\n#define NR_BLK_DEV\t7\n/*\n * NR_REQUEST is the number of entries in the request-queue.\n * NOTE that writes may use only the low 2/3 of these: reads\n * take precedence.\n *\n * 32 seems to be a reasonable number: enough to get some benefit\n * from the elevator-mechanism, but not so much as to lock a lot of\n * buffers when they are in the queue. 64 seems to be too many (easily\n * long pauses in reading when heavy writing/syncing is going on)\n */\n#define NR_REQUEST\t32\n\n/*\n * Ok, this is an expanded form so that we can use the same\n * request for paging requests when that is implemented. In\n * paging, 'bh' is NULL, and 'waiting' is used to wait for\n * read/write completion.\n */\nstruct request {\n\tint dev;\t\t/* -1 if no request */\n\tint cmd;\t\t/* READ or WRITE */\n\tint errors;\n\tunsigned long sector;\n\tunsigned long nr_sectors;\n\tchar * buffer;\n\tstruct task_struct * waiting;\n\tstruct buffer_head * bh;\n\tstruct request * next;\n};\n\n/*\n * This is used in the elevator algorithm: Note that\n * reads always go before writes. This is natural: reads\n * are much more time-critical than writes.\n */\n#define IN_ORDER(s1,s2) \\\n((s1)->cmd<(s2)->cmd || (s1)->cmd==(s2)->cmd && \\\n((s1)->dev < (s2)->dev || ((s1)->dev == (s2)->dev && \\\n(s1)->sector < (s2)->sector)))\n\nstruct blk_dev_struct {\n\tvoid (*request_fn)(void);\n\tstruct request * current_request;\n};\n\nextern struct blk_dev_struct blk_dev[NR_BLK_DEV];\nextern struct request request[NR_REQUEST];\nextern struct task_struct * wait_for_request;\n\n#ifdef MAJOR_NR\n\n/*\n * Add entries as needed. Currently the only block devices\n * supported are hard-disks and floppies.\n */\n\n#if (MAJOR_NR == 1)\n/* ram disk */\n#define DEVICE_NAME \"ramdisk\"\n#define DEVICE_REQUEST do_rd_request\n#define DEVICE_NR(device) ((device) & 7)\n#define DEVICE_ON(device) \n#define DEVICE_OFF(device)\n\n#elif (MAJOR_NR == 2)\n/* floppy */\n#define DEVICE_NAME \"floppy\"\n#define DEVICE_INTR do_floppy\n#define DEVICE_REQUEST do_fd_request\n#define DEVICE_NR(device) ((device) & 3)\n#define DEVICE_ON(device) floppy_on(DEVICE_NR(device))\n#define DEVICE_OFF(device) floppy_off(DEVICE_NR(device))\n\n#elif (MAJOR_NR == 3)\n/* harddisk */\n#define DEVICE_NAME \"harddisk\"\n#define DEVICE_INTR do_hd\n#define DEVICE_REQUEST do_hd_request\n#define DEVICE_NR(device) (MINOR(device)/5)\n#define DEVICE_ON(device)\n#define DEVICE_OFF(device)\n\n#elif\n/* unknown blk device */\n#error \"unknown blk device\"\n\n#endif\n\n#define CURRENT (blk_dev[MAJOR_NR].current_request)\n#define CURRENT_DEV DEVICE_NR(CURRENT->dev)\n\n#ifdef DEVICE_INTR\nvoid (*DEVICE_INTR)(void) = NULL;\n#endif\nstatic void (DEVICE_REQUEST)(void);\n\nextern inline void unlock_buffer(struct buffer_head * bh)\n{\n\tif (!bh->b_lock)\n\t\tprintk(DEVICE_NAME \": free buffer being unlocked\\n\");\n\tbh->b_lock=0;\n\twake_up(&bh->b_wait);\n}\n\nextern inline void end_request(int uptodate)\n{\n\tDEVICE_OFF(CURRENT->dev);\n\tif (CURRENT->bh) {\n\t\tCURRENT->bh->b_uptodate = uptodate;\n\t\tunlock_buffer(CURRENT->bh);\n\t}\n\tif (!uptodate) {\n\t\tprintk(DEVICE_NAME \" I/O error\\n\\r\");\n\t\tprintk(\"dev %04x, block %d\\n\\r\",CURRENT->dev,\n\t\t\tCURRENT->bh->b_blocknr);\n\t}\n\twake_up(&CURRENT->waiting);\n\twake_up(&wait_for_request);\n\tCURRENT->dev = -1;\n\tCURRENT = CURRENT->next;\n}\n\n#define INIT_REQUEST \\\nrepeat: \\\n\tif (!CURRENT) \\\n\t\treturn; \\\n\tif (MAJOR(CURRENT->dev) != MAJOR_NR) \\\n\t\tpanic(DEVICE_NAME \": request list destroyed\"); \\\n\tif (CURRENT->bh) { \\\n\t\tif (!CURRENT->bh->b_lock) \\\n\t\t\tpanic(DEVICE_NAME \": block not locked\"); \\\n\t}\n\n#endif\n\n#endif"
    ]
};

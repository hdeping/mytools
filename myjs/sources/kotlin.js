var sources = {
    "keys": [
        "./tasks/src/main/java/app/tivi/tasks/SyncShowWatchedProgress.kt",
        "./tasks/src/main/java/app/tivi/tasks/inject/TasksModule.kt",
        "./tasks/src/main/java/app/tivi/tasks/inject/WorkerKey.kt",
        "./tasks/src/main/java/app/tivi/tasks/inject/TiviWorkerFactory.kt",
        "./tasks/src/main/java/app/tivi/tasks/inject/ChildWorkerFactory.kt",
        "./tasks/src/main/java/app/tivi/tasks/inject/TasksAssistedModule.kt",
        "./tasks/src/main/java/app/tivi/tasks/inject/TasksModuleBinds.kt",
        "./tasks/src/main/java/app/tivi/tasks/ShowTasksImpl.kt",
        "./tasks/src/main/java/app/tivi/tasks/SyncAllFollowedShows.kt",
        "./tasks/src/main/java/app/tivi/appinitializers/ShowTasksInitializer.kt",
        "./app/src/main/java/app/tivi/settings/SettingsFragment.kt",
        "./app/src/main/java/app/tivi/settings/TiviPreferencesImpl.kt",
        "./app/src/main/java/app/tivi/settings/SettingsPreferenceFragment.kt",
        "./app/src/main/java/app/tivi/home/HomeInject.kt",
        "./app/src/main/java/app/tivi/home/HomeActivityViewState.kt",
        "./app/src/main/java/app/tivi/home/HomeActivity.kt",
        "./app/src/main/java/app/tivi/home/HomeActivityViewModel.kt",
        "./app/src/main/java/app/tivi/home/HomeAppNavigator.kt",
        "./app/src/main/java/app/tivi/TiviAppNavigator.kt",
        "./app/src/main/java/app/tivi/inject/AppModule.kt",
        "./app/src/main/java/app/tivi/inject/AppAssistedModule.kt",
        "./app/src/main/java/app/tivi/inject/NetworkModule.kt",
        "./app/src/main/java/app/tivi/inject/AppModuleBinds.kt",
        "./app/src/main/java/app/tivi/inject/AppComponent.kt",
        "./app/src/main/java/app/tivi/showdetails/ShowDetailsActivity.kt",
        "./app/src/main/java/app/tivi/showdetails/ShowDetailsBuilder.kt",
        "./app/src/main/java/app/tivi/showdetails/ShowDetailsModule.kt",
        "./app/src/main/java/app/tivi/appinitializers/TmdbInitializer.kt",
        "./app/src/main/java/app/tivi/appinitializers/EmojiInitializer.kt",
        "./app/src/main/java/app/tivi/appinitializers/ThreeTenBpInitializer.kt",
        "./app/src/main/java/app/tivi/appinitializers/ArchTaskExecutorInitializer.kt",
        "./app/src/main/java/app/tivi/appinitializers/TimberInitializer.kt",
        "./app/src/main/java/app/tivi/appinitializers/ClearGlideCacheInitializer.kt",
        "./app/src/main/java/app/tivi/appinitializers/PreferencesInitializer.kt",
        "./app/src/main/java/app/tivi/appinitializers/AppInitializers.kt",
        "./app/src/main/java/app/tivi/TiviApplication.kt",
        "./ui-discover/src/main/java/app/tivi/home/discover/DiscoverInject.kt",
        "./ui-discover/src/main/java/app/tivi/home/discover/DiscoverViewState.kt",
        "./ui-discover/src/main/java/app/tivi/home/discover/DiscoverViewModel.kt",
        "./ui-discover/src/main/java/app/tivi/home/discover/DiscoverFragment.kt",
        "./ui-discover/src/main/java/app/tivi/home/discover/DiscoverTextCreator.kt",
        "./ui-discover/src/main/java/app/tivi/home/discover/DiscoverEpoxyController.kt",
        "./ui-watched/src/main/java/app/tivi/home/watched/WatchedInject.kt",
        "./ui-watched/src/main/java/app/tivi/home/watched/WatchedEpoxyController.kt",
        "./ui-watched/src/main/java/app/tivi/home/watched/WatchedViewState.kt",
        "./ui-watched/src/main/java/app/tivi/home/watched/WatchedFragment.kt",
        "./ui-watched/src/main/java/app/tivi/home/watched/WatchedViewModel.kt",
        "./trakt/src/main/java/app/tivi/trakt/TraktAuthState.kt",
        "./trakt/src/main/java/app/tivi/trakt/TraktModule.kt",
        "./ui-episodedetails/src/main/java/app/tivi/episodedetails/EpisodeDetailsTextCreator.kt",
        "./ui-episodedetails/src/main/java/app/tivi/episodedetails/EpisodeDetailsFragmentInject.kt",
        "./ui-episodedetails/src/main/java/app/tivi/episodedetails/EpisodeDetailsEpoxyController.kt",
        "./ui-episodedetails/src/main/java/app/tivi/episodedetails/EpisodeDetailsFragment.kt",
        "./presenter-episodedetails/src/main/java/app/tivi/episodedetails/EpisodeDetailsArguments.kt",
        "./presenter-episodedetails/src/main/java/app/tivi/episodedetails/EpisodeDetailsViewState.kt",
        "./presenter-episodedetails/src/main/java/app/tivi/episodedetails/EpisodeDetailsPresenterInject.kt",
        "./presenter-episodedetails/src/main/java/app/tivi/episodedetails/EpisodeDetailsActions.kt",
        "./presenter-episodedetails/src/main/java/app/tivi/episodedetails/Action.kt",
        "./presenter-episodedetails/src/main/java/app/tivi/episodedetails/EpisodeDetailsViewModel.kt",
        "./ui-popular/src/main/java/app/tivi/home/popular/PopularInject.kt",
        "./ui-popular/src/main/java/app/tivi/home/popular/PopularShowsViewModel.kt",
        "./ui-popular/src/main/java/app/tivi/home/popular/PopularShowsFragment.kt",
        "./spotless/copyright.kt",
        "./tmdb/src/main/java/app/tivi/tmdb/TmdbImageSizes.kt",
        "./tmdb/src/main/java/app/tivi/tmdb/TmdbImageUrlProvider.kt",
        "./tmdb/src/main/java/app/tivi/tmdb/TmdbModule.kt",
        "./tmdb/src/main/java/app/tivi/tmdb/TmdbManager.kt",
        "./trakt-auth/src/main/java/app/tivi/trakt/TraktManager.kt",
        "./trakt-auth/src/main/java/app/tivi/trakt/TraktAuthModule.kt",
        "./trakt-auth/src/main/java/app/tivi/trakt/TraktConstants.kt",
        "./ui-search/src/main/java/app/tivi/home/search/SearchInject.kt",
        "./ui-search/src/main/java/app/tivi/home/search/SearchEpoxyController.kt",
        "./ui-search/src/main/java/app/tivi/home/search/SearchViewModel.kt",
        "./ui-search/src/main/java/app/tivi/home/search/SearchViewState.kt",
        "./ui-search/src/main/java/app/tivi/home/search/SearchFragment.kt",
        "./buildSrc/src/main/java/app/tivi/buildsrc/dependencies.kt",
        "./ui-recommended/src/main/java/app/tivi/home/recommended/RecommendedShowsFragment.kt",
        "./ui-recommended/src/main/java/app/tivi/home/recommended/RecommendedShowsViewModel.kt",
        "./ui-recommended/src/main/java/app/tivi/home/recommended/RecommendedInject.kt",
        "./common-imageloading/src/main/java/app/tivi/common/imageloading/CoilAppInitializer.kt",
        "./common-imageloading/src/main/java/app/tivi/common/imageloading/ImageLoadingModule.kt",
        "./common-imageloading/src/main/java/app/tivi/common/imageloading/ImageLoadingExtensions.kt",
        "./common-imageloading/src/main/java/app/tivi/common/imageloading/ImageLoadingBindingAdapters.kt",
        "./common-imageloading/src/main/java/app/tivi/common/imageloading/TmdbImageEntityCoilMapper.kt",
        "./common-imageloading/src/main/java/app/tivi/common/imageloading/SaturatingTransformation.kt",
        "./common-imageloading/src/main/java/app/tivi/common/imageloading/TrimTransparentEdgesTransformation.kt",
        "./base-android/src/main/java/app/tivi/SharedElementHelper.kt",
        "./base-android/src/main/java/app/tivi/util/TiviDateFormatter.kt",
        "./base-android/src/main/java/app/tivi/util/Event.kt",
        "./base-android/src/main/java/app/tivi/util/TiviLogger.kt",
        "./base-android/src/main/java/app/tivi/appinitializers/AppInitializer.kt",
        "./base-android/src/main/java/app/tivi/extensions/LiveDataExtensions.kt",
        "./base-android/src/main/java/app/tivi/extensions/ContextExtensions.kt",
        "./base-android/src/main/java/app/tivi/extensions/datetime.kt",
        "./base-android/src/main/java/app/tivi/extensions/MenuItemExtensions.kt",
        "./base-android/src/main/java/app/tivi/AppNavigator.kt",
        "./ui-followed/src/main/java/app/tivi/home/followed/FollowedInject.kt",
        "./ui-followed/src/main/java/app/tivi/home/followed/FollowedViewModel.kt",
        "./ui-followed/src/main/java/app/tivi/home/followed/FollowedFragment.kt",
        "./ui-followed/src/main/java/app/tivi/home/followed/FollowedViewState.kt",
        "./ui-followed/src/main/java/app/tivi/home/followed/FollowedEpoxyController.kt",
        "./ui-showdetails/src/main/java/app/tivi/showdetails/details/ShowDetailsFragmentInject.kt",
        "./ui-showdetails/src/main/java/app/tivi/showdetails/details/ShowDetailsAction.kt",
        "./ui-showdetails/src/main/java/app/tivi/showdetails/details/ShowDetailsViewState.kt",
        "./ui-showdetails/src/main/java/app/tivi/showdetails/details/ShowDetailsFragmentViewModel.kt",
        "./ui-showdetails/src/main/java/app/tivi/showdetails/details/ShowDetailsTextCreator.kt",
        "./ui-showdetails/src/main/java/app/tivi/showdetails/details/ShowDetailsEpoxyController.kt",
        "./ui-showdetails/src/main/java/app/tivi/showdetails/details/showDetailsItemIdGenerators.kt",
        "./ui-showdetails/src/main/java/app/tivi/showdetails/details/ShowDetailsFragment.kt",
        "./common-entrygrid/src/main/java/app/tivi/util/EntryGridFragment.kt",
        "./common-entrygrid/src/main/java/app/tivi/util/EntryViewModel.kt",
        "./common-entrygrid/src/main/java/app/tivi/util/EntryViewState.kt",
        "./common-entrygrid/src/main/java/app/tivi/util/EntryGridEpoxyController.kt",
        "./data-android/src/test/java/app/tivi/utils/fakeDataSources.kt",
        "./data-android/src/test/java/app/tivi/utils/TiviTestDatabase.kt",
        "./data-android/src/test/java/app/tivi/utils/SampleData.kt",
        "./data-android/src/test/java/app/tivi/utils/TestTransactionRunner.kt",
        "./data-android/src/test/java/app/tivi/utils/FakeTiviShowFts.kt",
        "./data-android/src/test/java/app/tivi/data/TestDatabaseInject.kt",
        "./data-android/src/test/java/app/tivi/data/dao/EpisodesTest.kt",
        "./data-android/src/test/java/app/tivi/data/dao/EpisodeWatchEntryTest.kt",
        "./data-android/src/test/java/app/tivi/data/dao/SeasonsTest.kt",
        "./data-android/src/test/java/app/tivi/data/repositories/SeasonsEpisodesRepositoryTest.kt",
        "./data-android/src/test/java/app/tivi/data/repositories/FollowedShowRepositoryTest.kt",
        "./data-android/src/main/java/app/tivi/data/RoomTransactionRunner.kt",
        "./data-android/src/main/java/app/tivi/data/TiviTypeConverters.kt",
        "./data-android/src/main/java/app/tivi/data/DatabaseInject.kt",
        "./data-android/src/main/java/app/tivi/data/FlowPagedListBuilder.kt",
        "./data-android/src/main/java/app/tivi/data/TiviRoomDatabase.kt",
        "./ui-trending/src/main/java/app/tivi/home/trending/TrendingInject.kt",
        "./ui-trending/src/main/java/app/tivi/home/trending/TrendingShowsFragment.kt",
        "./ui-trending/src/main/java/app/tivi/home/trending/TrendingShowsViewModel.kt",
        "./common-epoxy/src/main/java/app/tivi/common/epoxy/EpoxyModule.kt",
        "./common-epoxy/src/main/java/app/tivi/common/epoxy/StickyHeaderScrollListener.kt",
        "./common-epoxy/src/main/java/app/tivi/common/epoxy/EpoxyExtensions.kt",
        "./common-epoxy/src/main/java/app/tivi/common/epoxy/EpoxyModelProperty.kt",
        "./common-epoxy/src/main/java/app/tivi/common/epoxy/EmptyEpoxyController.kt",
        "./common-epoxy/src/main/java/app/tivi/common/epoxy/SwipeAwayCallbacks.kt",
        "./common-epoxy/src/main/java/app/tivi/common/epoxy/TiviCarousel.kt",
        "./common-epoxy/src/main/java/app/tivi/common/epoxy/EpoxyInitializer.kt",
        "./common-epoxy/src/main/java/app/tivi/common/epoxy/spanOverrides.kt",
        "./data/src/main/java/app/tivi/data/Entry.kt",
        "./data/src/main/java/app/tivi/data/DataModule.kt",
        "./data/src/main/java/app/tivi/data/syncers/ItemSyncer.kt",
        "./data/src/main/java/app/tivi/data/TiviDatabase.kt",
        "./data/src/main/java/app/tivi/data/repositories/popularshows/inject.kt",
        "./data/src/main/java/app/tivi/data/repositories/popularshows/PopularShowsLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/popularshows/TraktPopularShowsDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/traktusers/TraktUsersStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/traktusers/TraktUsersRepository.kt",
        "./data/src/main/java/app/tivi/data/repositories/traktusers/TraktUsersLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/traktusers/TraktUsersDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/lastrequests/GroupLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/lastrequests/EntityLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/recommendedshows/inject.kt",
        "./data/src/main/java/app/tivi/data/repositories/recommendedshows/RecommendedShowsLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/recommendedshows/TraktRecommendedShowsDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/relatedshows/inject.kt",
        "./data/src/main/java/app/tivi/data/repositories/relatedshows/RelatedShowsLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/relatedshows/TraktRelatedShowsDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/TraktEpisodeDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/SeasonsEpisodesDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/EpisodeDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/EpisodesModule.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/SeasonsLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/SeasonsEpisodesRepository.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/TmdbEpisodeDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/EpisodeWatchLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/TraktSeasonsEpisodesDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/EpisodeWatchStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/episodes/SeasonsEpisodesStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/search/TmdbSearchDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/search/SearchStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/search/SearchRepository.kt",
        "./data/src/main/java/app/tivi/data/repositories/search/SearchDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/followedshows/FollowedShowsRepository.kt",
        "./data/src/main/java/app/tivi/data/repositories/followedshows/TraktFollowedShowsDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/followedshows/FollowedShowsModule.kt",
        "./data/src/main/java/app/tivi/data/repositories/followedshows/FollowedShowsDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/followedshows/FollowedShowsStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/followedshows/FollowedShowsLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/watchedshows/inject.kt",
        "./data/src/main/java/app/tivi/data/repositories/watchedshows/TraktWatchedShowsDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/watchedshows/WatchedShowsLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/showimages/TmdbShowImagesDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/showimages/ShowImagesLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/showimages/inject.kt",
        "./data/src/main/java/app/tivi/data/repositories/showimages/ShowImagesDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/trendingshows/inject.kt",
        "./data/src/main/java/app/tivi/data/repositories/trendingshows/TraktTrendingShowsDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/trendingshows/TrendingShowsLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/repositories/shows/ShowDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/shows/inject.kt",
        "./data/src/main/java/app/tivi/data/repositories/shows/showutils.kt",
        "./data/src/main/java/app/tivi/data/repositories/shows/TraktShowDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/shows/TmdbShowDataSource.kt",
        "./data/src/main/java/app/tivi/data/repositories/shows/ShowLastRequestStore.kt",
        "./data/src/main/java/app/tivi/data/DatabaseTransactionRunner.kt",
        "./data/src/main/java/app/tivi/data/ThreeTenExtensions.kt",
        "./data/src/main/java/app/tivi/data/mappers/TmdbShowToTiviShow.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktHistoryItemToEpisodeWatchEntry.kt",
        "./data/src/main/java/app/tivi/data/mappers/mappers.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktListEntryToTiviShow.kt",
        "./data/src/main/java/app/tivi/data/mappers/TmdbShowResultsPageToTiviShows.kt",
        "./data/src/main/java/app/tivi/data/mappers/ShowIdToTraktIdMapper.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktSeasonToSeasonWithEpisodes.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktShowToTiviShow.kt",
        "./data/src/main/java/app/tivi/data/mappers/ShowIdToTmdbIdMapper.kt",
        "./data/src/main/java/app/tivi/data/mappers/UserToTraktUser.kt",
        "./data/src/main/java/app/tivi/data/mappers/TmdbEpisodeToEpisode.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktSeasonToSeason.kt",
        "./data/src/main/java/app/tivi/data/mappers/EpisodeIdToTraktIdMapper.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktEpisodeToEpisode.kt",
        "./data/src/main/java/app/tivi/data/mappers/TmdbImagesToShowImages.kt",
        "./data/src/main/java/app/tivi/data/mappers/SeasonIdToTraktIdMapper.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktTrendingShowToTiviShow.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktStatusToShowStatus.kt",
        "./data/src/main/java/app/tivi/data/mappers/TmdbBaseShowToTiviShow.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktTrendingShowToTrendingShowEntry.kt",
        "./data/src/main/java/app/tivi/data/mappers/Mapper.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktHistoryEntryToEpisode.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktListEntryToFollowedShowEntry.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktSearchResultToTiviShow.kt",
        "./data/src/main/java/app/tivi/data/mappers/TraktBaseShowToTiviShow.kt",
        "./data/src/main/java/app/tivi/data/views/FollowedShowsWatchStats.kt",
        "./data/src/main/java/app/tivi/data/views/FollowedShowsLastWatched.kt",
        "./data/src/main/java/app/tivi/data/views/FollowedShowsNextToWatch.kt",
        "./data/src/main/java/app/tivi/data/entities/EpisodeWatchEntry.kt",
        "./data/src/main/java/app/tivi/data/entities/ShowImages.kt",
        "./data/src/main/java/app/tivi/data/entities/Season.kt",
        "./data/src/main/java/app/tivi/data/entities/TiviEntity.kt",
        "./data/src/main/java/app/tivi/data/entities/RecommendedShowEntry.kt",
        "./data/src/main/java/app/tivi/data/entities/LastRequest.kt",
        "./data/src/main/java/app/tivi/data/entities/ShowTmdbImage.kt",
        "./data/src/main/java/app/tivi/data/entities/TiviShow.kt",
        "./data/src/main/java/app/tivi/data/entities/Genre.kt",
        "./data/src/main/java/app/tivi/data/entities/ShowStatus.kt",
        "./data/src/main/java/app/tivi/data/entities/RelatedShowEntry.kt",
        "./data/src/main/java/app/tivi/data/entities/FollowedShowEntry.kt",
        "./data/src/main/java/app/tivi/data/entities/RefreshType.kt",
        "./data/src/main/java/app/tivi/data/entities/PopularShowEntry.kt",
        "./data/src/main/java/app/tivi/data/entities/WatchedShowEntry.kt",
        "./data/src/main/java/app/tivi/data/entities/Episode.kt",
        "./data/src/main/java/app/tivi/data/entities/PendingAction.kt",
        "./data/src/main/java/app/tivi/data/entities/SortOption.kt",
        "./data/src/main/java/app/tivi/data/entities/SearchResults.kt",
        "./data/src/main/java/app/tivi/data/entities/TraktUser.kt",
        "./data/src/main/java/app/tivi/data/entities/Request.kt",
        "./data/src/main/java/app/tivi/data/entities/TrendingShowEntry.kt",
        "./data/src/main/java/app/tivi/data/entities/TiviShowFts.kt",
        "./data/src/main/java/app/tivi/data/entities/ActionDate.kt",
        "./data/src/main/java/app/tivi/data/StoreExtensions.kt",
        "./data/src/main/java/app/tivi/data/daos/EpisodeWatchEntryDao.kt",
        "./data/src/main/java/app/tivi/data/daos/FollowedShowsDao.kt",
        "./data/src/main/java/app/tivi/data/daos/PopularDao.kt",
        "./data/src/main/java/app/tivi/data/daos/TiviShowDao.kt",
        "./data/src/main/java/app/tivi/data/daos/EntityDao.kt",
        "./data/src/main/java/app/tivi/data/daos/RecommendedDao.kt",
        "./data/src/main/java/app/tivi/data/daos/ShowImagesDao.kt",
        "./data/src/main/java/app/tivi/data/daos/SeasonsDao.kt",
        "./data/src/main/java/app/tivi/data/daos/UserDao.kt",
        "./data/src/main/java/app/tivi/data/daos/TrendingDao.kt",
        "./data/src/main/java/app/tivi/data/daos/EntryDao.kt",
        "./data/src/main/java/app/tivi/data/daos/ShowFtsDao.kt",
        "./data/src/main/java/app/tivi/data/daos/PairEntryDao.kt",
        "./data/src/main/java/app/tivi/data/daos/PaginatedEntryDao.kt",
        "./data/src/main/java/app/tivi/data/daos/WatchedShowDao.kt",
        "./data/src/main/java/app/tivi/data/daos/LastRequestDao.kt",
        "./data/src/main/java/app/tivi/data/daos/RelatedShowsDao.kt",
        "./data/src/main/java/app/tivi/data/daos/EpisodesDao.kt",
        "./data/src/main/java/app/tivi/data/resultentities/TrendingEntryWithShow.kt",
        "./data/src/main/java/app/tivi/data/resultentities/SeasonWithShow.kt",
        "./data/src/main/java/app/tivi/data/resultentities/PopularEntryWithShow.kt",
        "./data/src/main/java/app/tivi/data/resultentities/SeasonWithEpisodesAndWatches.kt",
        "./data/src/main/java/app/tivi/data/resultentities/SeasonWithEpisodes.kt",
        "./data/src/main/java/app/tivi/data/resultentities/ShowDetailed.kt",
        "./data/src/main/java/app/tivi/data/resultentities/WatchedShowEntryWithShow.kt",
        "./data/src/main/java/app/tivi/data/resultentities/RelatedShowEntryWithShow.kt",
        "./data/src/main/java/app/tivi/data/resultentities/RecommendedEntryWithShow.kt",
        "./data/src/main/java/app/tivi/data/resultentities/EpisodeWithSeasonWithShow.kt",
        "./data/src/main/java/app/tivi/data/resultentities/EpisodeWithSeason.kt",
        "./data/src/main/java/app/tivi/data/resultentities/EpisodeWithWatches.kt",
        "./data/src/main/java/app/tivi/data/resultentities/FollowedShowEntryWithShow.kt",
        "./data/src/main/java/app/tivi/data/resultentities/EntryWithShow.kt",
        "./domain/src/main/java/app/tivi/domain/Interactor.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateShowSeasonData.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/RemoveEpisodeWatches.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateTmdbConfig.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/RemoveEpisodeWatch.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateFollowedShows.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateUserDetails.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/AddEpisodeWatch.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateShowDetails.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateShowImages.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/GetEpisodeDetails.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateRecommendedShows.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateRelatedShows.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/ChangeSeasonFollowStatus.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateTrendingShows.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/SearchShows.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdatePopularShows.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateShowSeasons.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateWatchedShows.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/UpdateEpisodeDetails.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/DeleteFolder.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/ChangeSeasonWatchedStatus.kt",
        "./domain/src/main/java/app/tivi/domain/interactors/ChangeShowFollowStatus.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveShowViewStats.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveEpisodeWatches.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveRecommendedShows.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveShowNextEpisodeToWatch.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveShowFollowStatus.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveShowSeasons.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveTrendingShows.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveShowImages.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveTraktAuthState.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObservePagedFollowedShows.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveEpisodeDetails.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObservePagedRecommendedShows.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveNextShowEpisodeToWatch.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObservePagedWatchedShows.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveShowSeasonData.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObservePagedPopularShows.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObservePagedTrendingShows.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveUserDetails.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObservePopularShows.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveShowDetails.kt",
        "./domain/src/main/java/app/tivi/domain/observers/ObserveRelatedShows.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/MaxLinesToggleClickListener.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/motionlayout/TransitionListenerAdapter.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/motionlayout/FabShowHideTransitionListener.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/listSharedElementHelperExtensions.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/NestedChildMotionLayout.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/CheckableConstraintLayout.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/TintingToolbar.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/MaterialShapeConstraintLayout.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/BaselineGridTextView.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/TopLeftCutoutBackgroundView.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/HeaderHolderFrameLayout.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/CheckableFloatingActionButton.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/PopupMenuButton.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/TiviMotionLayout.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/widget/TwoThreeImageView.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/StatusBarHeightBehavior.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/SortPopupMenuListener.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/SpacingItemDecorator.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/ScrimUtil.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/GenreStringer.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/recyclerview/TiviLinearSmoothScroller.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/recyclerview/HideImeOnScrollListener.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/ProgressTimeLatch.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/AuthStateMenuItemBinder.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/text/TypefaceSpan.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/text/TextUtils.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/transitions/ColumnedChangeBounds.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/transitions/ViewChangeBounds.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/transitions/DrawableAlphaProperty.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/transitions/GridToGridTransitioner.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/transitions/ViewGroupUtils.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/transitions/BabySlide.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/graphics/ImageLoadingColorMatrix.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/RoundRectViewOutline.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/NoopApplyWindowInsetsListener.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/animations/animators.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/animations/Property.kt",
        "./common-ui-view/src/main/java/app/tivi/ui/animations/AnimationUtils.kt",
        "./common-ui-view/src/main/java/app/tivi/home/HomeTextCreator.kt",
        "./common-ui-view/src/main/java/app/tivi/util/ShowStateSelector.kt",
        "./common-ui-view/src/main/java/app/tivi/util/ObservableLoadingCounter.kt",
        "./common-ui-view/src/main/java/app/tivi/TiviActivity.kt",
        "./common-ui-view/src/main/java/app/tivi/extensions/AnimatorExtensions.kt",
        "./common-ui-view/src/main/java/app/tivi/extensions/FragmentExtensions.kt",
        "./common-ui-view/src/main/java/app/tivi/extensions/ThemeExtensions.kt",
        "./common-ui-view/src/main/java/app/tivi/extensions/ViewExtensions.kt",
        "./common-ui-view/src/main/java/app/tivi/extensions/MultipleBackStackNavigationExtensions.kt",
        "./common-ui-view/src/main/java/app/tivi/extensions/RecyclerViewExtensions.kt",
        "./common-ui-view/src/main/java/app/tivi/extensions/MotionLayoutExtensions.kt",
        "./common-ui-view/src/main/java/app/tivi/extensions/SharedElementExtensions.kt",
        "./common-ui-view/src/main/java/app/tivi/extensions/NavigationExtensions.kt",
        "./common-ui-view/src/main/java/app/tivi/TiviActivityMvRxView.kt",
        "./common-ui-view/src/main/java/app/tivi/TiviFragment.kt",
        "./common-ui-view/src/main/java/app/tivi/api/UiStatus.kt",
        "./common-ui-view/src/main/java/app/tivi/TiviMvRxViewModel.kt",
        "./base/src/main/java/app/tivi/settings/TiviPreferences.kt",
        "./base/src/main/java/app/tivi/util/AppCoroutineDispatchers.kt",
        "./base/src/main/java/app/tivi/util/Logger.kt",
        "./base/src/main/java/app/tivi/inject/Annotations.kt",
        "./base/src/main/java/app/tivi/extensions/RetrofitExtensions.kt",
        "./base/src/main/java/app/tivi/extensions/CharSequenceExtensions.kt",
        "./base/src/main/java/app/tivi/extensions/CoroutineExtensions.kt",
        "./base/src/main/java/app/tivi/extensions/delgates.kt",
        "./base/src/main/java/app/tivi/actions/ShowTasks.kt",
        "./base/src/main/java/app/tivi/data/entities/Result.kt",
        "./base/src/main/java/app/tivi/base/InvokeStatus.kt",
        "./common-databinding/src/main/java/app/tivi/TiviFragmentWithBinding.kt",
        "./common-databinding/src/main/java/app/tivi/databinding/TiviBindingMethods.kt",
        "./common-databinding/src/main/java/app/tivi/databinding/TiviBindingAdapters.kt"
    ],
    "values": [
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tasks\n\nimport android.content.Context\nimport androidx.work.CoroutineWorker\nimport androidx.work.Data\nimport androidx.work.WorkerParameters\nimport app.tivi.domain.interactors.UpdateShowSeasonData\nimport app.tivi.tasks.inject.ChildWorkerFactory\nimport app.tivi.util.Logger\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\n\nclass SyncShowWatchedProgress @AssistedInject constructor(\n    @Assisted params: WorkerParameters,\n    @Assisted context: Context,\n    private val updateShowSeasonData: UpdateShowSeasonData,\n    private val logger: Logger\n) : CoroutineWorker(context, params) {\n    companion object {\n        const val TAG = \"sync-show-watched-episodes\"\n        private const val PARAM_SHOW_ID = \"show-id\"\n\n        fun buildData(showId: Long) = Data.Builder()\n            .putLong(PARAM_SHOW_ID, showId)\n            .build()\n    }\n\n    override suspend fun doWork(): Result {\n        val showId = inputData.getLong(PARAM_SHOW_ID, -1)\n        logger.d(\"$TAG worker running for show id: $showId\")\n\n        updateShowSeasonData.executeSync(UpdateShowSeasonData.Params(showId, true))\n\n        return Result.success()\n    }\n\n    @AssistedInject.Factory\n    interface Factory : ChildWorkerFactory\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tasks.inject\n\nimport android.content.Context\nimport androidx.work.Configuration\nimport androidx.work.WorkManager\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\n\n@Module(includes = [TasksModuleBinds::class, TasksAssistedModule::class])\nclass TasksModule {\n    @Provides\n    @Singleton\n    fun provideWorkManager(context: Context): WorkManager = WorkManager.getInstance(context)\n\n    @Provides\n    fun provideWorkConfiguration(workerFactory: TiviWorkerFactory): Configuration {\n        return Configuration.Builder()\n            .setWorkerFactory(workerFactory)\n            .build()\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tasks.inject\n\nimport androidx.work.ListenableWorker\nimport dagger.MapKey\nimport kotlin.reflect.KClass\n\n@MapKey\n@Retention(AnnotationRetention.RUNTIME)\n@Target(AnnotationTarget.FUNCTION)\nannotation class WorkerKey(val value: KClass<out ListenableWorker>)",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tasks.inject\n\nimport android.content.Context\nimport androidx.work.ListenableWorker\nimport androidx.work.WorkerFactory\nimport androidx.work.WorkerParameters\nimport javax.inject.Inject\nimport javax.inject.Provider\n\nclass TiviWorkerFactory @Inject constructor(\n    private val creators: Map<Class<out ListenableWorker>, @JvmSuppressWildcards Provider<ChildWorkerFactory>>\n) : WorkerFactory() {\n    override fun createWorker(\n        context: Context,\n        workerClassName: String,\n        workerParameters: WorkerParameters\n    ): ListenableWorker? {\n        val workerClass = Class.forName(workerClassName)\n        val foundEntry = creators.entries.find { workerClass.isAssignableFrom(it.key) }\n        val factory = foundEntry?.value\n            ?: throw IllegalArgumentException(\"unknown worker class name: $workerClassName\")\n        return factory.get().create(context, workerParameters)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tasks.inject\n\nimport android.content.Context\nimport androidx.work.ListenableWorker\nimport androidx.work.WorkerParameters\n\ninterface ChildWorkerFactory {\n    fun create(context: Context, params: WorkerParameters): ListenableWorker\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tasks.inject\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\n\n@Module(includes = [AssistedInject_TasksAssistedModule::class])\n@AssistedModule\ninterface TasksAssistedModule",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tasks.inject\n\nimport app.tivi.actions.ShowTasks\nimport app.tivi.appinitializers.AppInitializer\nimport app.tivi.appinitializers.ShowTasksInitializer\nimport app.tivi.tasks.ShowTasksImpl\nimport app.tivi.tasks.SyncAllFollowedShows\nimport app.tivi.tasks.SyncShowWatchedProgress\nimport dagger.Binds\nimport dagger.Module\nimport dagger.multibindings.IntoMap\nimport dagger.multibindings.IntoSet\nimport javax.inject.Singleton\n\n@Module\nabstract class TasksModuleBinds {\n    @Binds\n    @IntoMap\n    @WorkerKey(SyncAllFollowedShows::class)\n    abstract fun bindSyncAllFollowedShows(factory: SyncAllFollowedShows.Factory): ChildWorkerFactory\n\n    @Binds\n    @IntoMap\n    @WorkerKey(SyncShowWatchedProgress::class)\n    abstract fun bindSyncShowWatchedProgress(factory: SyncShowWatchedProgress.Factory): ChildWorkerFactory\n\n    @Binds\n    @IntoSet\n    abstract fun provideShowTasksInitializer(bind: ShowTasksInitializer): AppInitializer\n\n    @Binds\n    @Singleton\n    abstract fun provideTiviActions(bind: ShowTasksImpl): ShowTasks\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tasks\n\nimport androidx.work.Constraints\nimport androidx.work.ExistingPeriodicWorkPolicy\nimport androidx.work.NetworkType\nimport androidx.work.OneTimeWorkRequest\nimport androidx.work.PeriodicWorkRequest\nimport androidx.work.WorkManager\nimport app.tivi.actions.ShowTasks\nimport java.util.concurrent.TimeUnit\nimport javax.inject.Inject\n\nclass ShowTasksImpl @Inject constructor(\n    private val workManager: WorkManager\n) : ShowTasks {\n    override fun syncShowWatchedEpisodes(showId: Long) {\n        val request = OneTimeWorkRequest.Builder(SyncShowWatchedProgress::class.java)\n            .addTag(SyncShowWatchedProgress.TAG)\n            .setInputData(SyncShowWatchedProgress.buildData(showId))\n            .build()\n        workManager.enqueue(request)\n    }\n\n    override fun syncFollowedShows() {\n        val request = OneTimeWorkRequest.Builder(SyncAllFollowedShows::class.java)\n            .addTag(SyncAllFollowedShows.TAG)\n            .build()\n        workManager.enqueue(request)\n    }\n\n    override fun syncFollowedShowsWhenIdle() {\n        val request = OneTimeWorkRequest.Builder(SyncAllFollowedShows::class.java)\n            .addTag(SyncAllFollowedShows.TAG)\n            .setConstraints(\n                Constraints.Builder()\n                    .setRequiresDeviceIdle(true)\n                    .build()\n            )\n            .build()\n        workManager.enqueue(request)\n    }\n\n    override fun setupNightSyncs() {\n        val request = PeriodicWorkRequest.Builder(\n            SyncAllFollowedShows::class.java,\n            24, TimeUnit.HOURS,\n            12, TimeUnit.HOURS\n        ).setConstraints(\n            Constraints.Builder()\n                .setRequiredNetworkType(NetworkType.CONNECTED)\n                .setRequiresBatteryNotLow(true)\n                .setRequiresDeviceIdle(true)\n                .build()\n        ).build()\n\n        workManager.enqueueUniquePeriodicWork(\n            SyncAllFollowedShows.NIGHTLY_SYNC_TAG,\n            ExistingPeriodicWorkPolicy.REPLACE,\n            request\n        )\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tasks\n\nimport android.content.Context\nimport androidx.work.CoroutineWorker\nimport androidx.work.WorkerParameters\nimport app.tivi.data.entities.RefreshType\nimport app.tivi.domain.interactors.UpdateFollowedShows\nimport app.tivi.tasks.inject.ChildWorkerFactory\nimport app.tivi.util.Logger\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\n\nclass SyncAllFollowedShows @AssistedInject constructor(\n    @Assisted params: WorkerParameters,\n    @Assisted context: Context,\n    private val updateFollowedShows: UpdateFollowedShows,\n    private val logger: Logger\n) : CoroutineWorker(context, params) {\n    companion object {\n        const val TAG = \"sync-all-followed-shows\"\n        const val NIGHTLY_SYNC_TAG = \"night-sync-all-followed-shows\"\n    }\n\n    override suspend fun doWork(): Result {\n        logger.d(\"$TAG worker running\")\n        updateFollowedShows.executeSync(UpdateFollowedShows.Params(true, RefreshType.FULL))\n        return Result.success()\n    }\n\n    @AssistedInject.Factory\n    interface Factory : ChildWorkerFactory\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.appinitializers\n\nimport android.app.Application\nimport app.tivi.actions.ShowTasks\nimport dagger.Lazy\nimport javax.inject.Inject\n\nclass ShowTasksInitializer @Inject constructor(\n    private val showTasks: Lazy<ShowTasks>\n) : AppInitializer {\n    override fun init(application: Application) {\n        showTasks.get().setupNightSyncs()\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.settings\n\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.commitNow\nimport androidx.navigation.fragment.findNavController\nimport app.tivi.R\nimport app.tivi.databinding.FragmentSettingsBinding\n\nclass SettingsFragment : Fragment() {\n    private lateinit var binding: FragmentSettingsBinding\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        binding = FragmentSettingsBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        binding.settingsToolbar.setNavigationOnClickListener {\n            findNavController().navigateUp()\n        }\n\n        childFragmentManager.commitNow {\n            replace(R.id.settings_container, SettingsPreferenceFragment())\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.settings\n\nimport android.content.Context\nimport android.content.SharedPreferences\nimport androidx.appcompat.app.AppCompatDelegate\nimport androidx.core.content.edit\nimport app.tivi.R\nimport app.tivi.settings.TiviPreferences.Theme\nimport javax.inject.Inject\nimport javax.inject.Named\n\nclass TiviPreferencesImpl @Inject constructor(\n    private val context: Context,\n    @Named(\"app\") private val sharedPreferences: SharedPreferences\n) : TiviPreferences {\n    private val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->\n        when (key) {\n            KEY_THEME -> updateUsingThemePreference()\n        }\n    }\n\n    private val defaultThemeValue = context.getString(R.string.pref_theme_default_value)\n\n    companion object {\n        const val KEY_THEME = \"pref_theme\"\n    }\n\n    override fun setup() {\n        updateUsingThemePreference()\n        sharedPreferences.registerOnSharedPreferenceChangeListener(listener)\n    }\n\n    override var themePreference: Theme\n        get() = getThemeForStorageValue(sharedPreferences.getString(KEY_THEME, defaultThemeValue)!!)\n        set(value) = sharedPreferences.edit {\n            putString(KEY_THEME, getStorageKeyForTheme(value))\n        }\n\n    private fun getStorageKeyForTheme(theme: Theme) = when (theme) {\n        Theme.LIGHT -> context.getString(R.string.pref_theme_light_value)\n        Theme.DARK -> context.getString(R.string.pref_theme_dark_value)\n        Theme.BATTERY_SAVER_ONLY -> context.getString(R.string.pref_theme_battery_value)\n        Theme.SYSTEM -> context.getString(R.string.pref_theme_system_value)\n    }\n\n    private fun getThemeForStorageValue(value: String) = when (value) {\n        context.getString(R.string.pref_theme_system_value) -> Theme.SYSTEM\n        context.getString(R.string.pref_theme_light_value) -> Theme.LIGHT\n        context.getString(R.string.pref_theme_dark_value) -> Theme.DARK\n        context.getString(R.string.pref_theme_battery_value) -> Theme.BATTERY_SAVER_ONLY\n        else -> throw IllegalArgumentException(\"Invalid preference value for theme\")\n    }\n\n    private fun updateUsingThemePreference() = when (themePreference) {\n        Theme.DARK -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)\n        Theme.LIGHT -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)\n        Theme.SYSTEM -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM)\n        Theme.BATTERY_SAVER_ONLY -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_AUTO_BATTERY)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.settings\n\nimport android.content.Intent\nimport android.os.Bundle\nimport androidx.browser.customtabs.CustomTabsIntent\nimport androidx.core.net.toUri\nimport androidx.preference.Preference\nimport androidx.preference.PreferenceFragmentCompat\nimport app.tivi.BuildConfig\nimport app.tivi.R\nimport app.tivi.extensions.resolveThemeColor\nimport com.google.android.gms.oss.licenses.OssLicensesMenuActivity\n\ninternal class SettingsPreferenceFragment : PreferenceFragmentCompat() {\n    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {\n        setPreferencesFromResource(R.xml.preferences, rootKey)\n\n        findPreference<Preference>(\"privacy_policy\")?.setOnPreferenceClickListener {\n            CustomTabsIntent.Builder()\n                .setToolbarColor(requireContext().resolveThemeColor(R.attr.colorPrimaryVariant))\n                .build()\n                .launchUrl(requireContext(), getString(R.string.privacy_policy_url).toUri())\n            true\n        }\n\n        findPreference<Preference>(\"open_source\")?.setOnPreferenceClickListener {\n            startActivity(Intent(requireContext(), OssLicensesMenuActivity::class.java))\n            true\n        }\n\n        findPreference<Preference>(\"version\")?.apply {\n            summary = getString(R.string.settings_app_version_summary,\n                BuildConfig.VERSION_NAME, BuildConfig.VERSION_CODE)\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home\n\nimport android.content.Context\nimport app.tivi.AppNavigator\nimport app.tivi.home.discover.DiscoverBuilder\nimport app.tivi.home.followed.FollowedBuilder\nimport app.tivi.home.popular.PopularBuilder\nimport app.tivi.home.recommended.RecommendedBuilder\nimport app.tivi.home.search.SearchBuilder\nimport app.tivi.home.trending.TrendingBuilder\nimport app.tivi.home.watched.WatchedBuilder\nimport app.tivi.inject.PerActivity\nimport dagger.Binds\nimport dagger.Module\nimport dagger.Provides\nimport dagger.android.ContributesAndroidInjector\n\n@Module\ninternal abstract class HomeBuilder {\n    @ContributesAndroidInjector(modules = [\n        HomeModule::class,\n        SearchBuilder::class,\n        DiscoverBuilder::class,\n        TrendingBuilder::class,\n        PopularBuilder::class,\n        WatchedBuilder::class,\n        FollowedBuilder::class,\n        RecommendedBuilder::class\n    ])\n    internal abstract fun homeActivity(): HomeActivity\n}\n\n@Module(includes = [HomeModuleBinds::class])\nclass HomeModule {\n    @Provides\n    fun provideAppNavigator(activity: HomeActivity): AppNavigator = HomeAppNavigator(activity)\n}\n\n@Module\nabstract class HomeModuleBinds {\n    @Binds\n    @PerActivity\n    abstract fun bindContext(activity: HomeActivity): Context\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home\n\nimport app.tivi.data.entities.TraktUser\nimport app.tivi.trakt.TraktAuthState\nimport com.airbnb.mvrx.MvRxState\n\ndata class HomeActivityViewState(\n    val user: TraktUser? = null,\n    val authState: TraktAuthState = TraktAuthState.LOGGED_OUT\n) : MvRxState",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home\n\nimport android.content.Intent\nimport android.os.Bundle\nimport androidx.databinding.DataBindingUtil\nimport androidx.lifecycle.observe\nimport androidx.navigation.NavController\nimport app.tivi.R\nimport app.tivi.TiviActivityMvRxView\nimport app.tivi.databinding.ActivityHomeBinding\nimport app.tivi.extensions.hideSoftInput\nimport app.tivi.extensions.setupWithNavController\nimport app.tivi.trakt.TraktConstants\nimport com.airbnb.mvrx.viewModel\nimport javax.inject.Inject\nimport net.openid.appauth.AuthorizationException\nimport net.openid.appauth.AuthorizationResponse\nimport net.openid.appauth.AuthorizationService\n\nclass HomeActivity : TiviActivityMvRxView() {\n    private val authService by lazy(LazyThreadSafetyMode.NONE) { AuthorizationService(this) }\n\n    private val viewModel: HomeActivityViewModel by viewModel()\n\n    @Inject lateinit var homeNavigationViewModelFactory: HomeActivityViewModel.Factory\n\n    private lateinit var binding: ActivityHomeBinding\n\n    private var currentNavController: NavController? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        binding = DataBindingUtil.setContentView(this, R.layout.activity_home)\n\n        if (savedInstanceState == null) {\n            setupBottomNavigationBar()\n        }\n    }\n\n    override fun onStart() {\n        super.onStart()\n        viewModel.subscribe(this) { postInvalidate() }\n    }\n\n    override fun onRestoreInstanceState(savedInstanceState: Bundle) {\n        super.onRestoreInstanceState(savedInstanceState)\n        // Now that BottomNavigationBar has restored its instance state\n        // and its selectedItemId, we can proceed with setting up the\n        // BottomNavigationBar with Navigation\n        setupBottomNavigationBar()\n    }\n\n    override fun invalidate() {\n    }\n\n    override fun handleIntent(intent: Intent) {\n        when (intent.action) {\n            TraktConstants.INTENT_ACTION_HANDLE_AUTH_RESPONSE -> {\n                val response = AuthorizationResponse.fromIntent(intent)\n                val error = AuthorizationException.fromIntent(intent)\n                viewModel.onAuthResponse(authService, response, error)\n            }\n        }\n    }\n\n    internal fun startLogin() {\n        viewModel.onLoginItemClicked(authService)\n    }\n\n    private fun setupBottomNavigationBar() {\n        binding.homeBottomNavigation.setupWithNavController(\n            listOf(R.navigation.discover_nav_graph, R.navigation.watched_nav_graph,\n                R.navigation.following_nav_graph, R.navigation.search_nav_graph),\n            supportFragmentManager,\n            R.id.home_nav_container,\n            intent\n        ).observe(this) { navController ->\n            currentNavController = navController\n\n            navController.addOnDestinationChangedListener { _, destination, _ ->\n                if (destination.id != R.id.navigation_search) {\n                    hideSoftInput()\n                }\n            }\n        }\n    }\n\n    override fun onSupportNavigateUp(): Boolean {\n        return currentNavController?.navigateUp() ?: super.onSupportNavigateUp()\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home\n\nimport androidx.lifecycle.viewModelScope\nimport app.tivi.TiviMvRxViewModel\nimport app.tivi.domain.interactors.UpdateUserDetails\nimport app.tivi.domain.invoke\nimport app.tivi.domain.launchObserve\nimport app.tivi.domain.observers.ObserveTraktAuthState\nimport app.tivi.domain.observers.ObserveUserDetails\nimport app.tivi.trakt.TraktAuthState\nimport app.tivi.trakt.TraktManager\nimport com.airbnb.mvrx.MvRxViewModelFactory\nimport com.airbnb.mvrx.ViewModelContext\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\nimport kotlinx.coroutines.flow.distinctUntilChanged\nimport kotlinx.coroutines.flow.onEach\nimport net.openid.appauth.AuthorizationException\nimport net.openid.appauth.AuthorizationResponse\nimport net.openid.appauth.AuthorizationService\n\nclass HomeActivityViewModel @AssistedInject constructor(\n    @Assisted initialState: HomeActivityViewState,\n    observeTraktAuthState: ObserveTraktAuthState,\n    private val traktManager: TraktManager,\n    private val updateUserDetails: UpdateUserDetails,\n    observeUserDetails: ObserveUserDetails\n) : TiviMvRxViewModel<HomeActivityViewState>(initialState) {\n    init {\n        viewModelScope.launchObserve(observeUserDetails) {\n            it.execute { copy(user = it()) }\n        }\n\n        observeUserDetails(ObserveUserDetails.Params(\"me\"))\n\n        viewModelScope.launchObserve(observeTraktAuthState) { flow ->\n            flow.distinctUntilChanged().onEach {\n                if (it == TraktAuthState.LOGGED_IN) {\n                    updateUserDetails(UpdateUserDetails.Params(\"me\", false))\n                }\n            }.execute { copy(authState = it() ?: TraktAuthState.LOGGED_OUT) }\n        }\n        observeTraktAuthState()\n    }\n\n    fun onAuthResponse(\n        authService: AuthorizationService,\n        response: AuthorizationResponse?,\n        ex: AuthorizationException?\n    ) {\n        when {\n            response != null -> traktManager.onAuthResponse(authService, response)\n            ex != null -> traktManager.onAuthException(ex)\n        }\n    }\n\n    fun onLoginItemClicked(authService: AuthorizationService) {\n        traktManager.startAuth(0, authService)\n    }\n\n    @AssistedInject.Factory\n    interface Factory {\n        fun create(initialState: HomeActivityViewState): HomeActivityViewModel\n    }\n\n    companion object : MvRxViewModelFactory<HomeActivityViewModel, HomeActivityViewState> {\n        override fun create(\n            viewModelContext: ViewModelContext,\n            state: HomeActivityViewState\n        ): HomeActivityViewModel? {\n            val fragment: HomeActivity = viewModelContext.activity()\n            return fragment.homeNavigationViewModelFactory.create(state)\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home\n\nimport app.tivi.TiviAppNavigator\n\ninternal class HomeAppNavigator(\n    private val activity: HomeActivity\n) : TiviAppNavigator(activity) {\n    override fun startLogin() {\n        activity.startLogin()\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi\n\nimport android.app.PendingIntent\nimport android.content.Context\nimport android.content.Intent\nimport app.tivi.home.HomeActivity\nimport app.tivi.trakt.TraktConstants\nimport javax.inject.Inject\n\nopen class TiviAppNavigator @Inject constructor(\n    private val context: Context\n) : AppNavigator {\n    override fun provideAuthHandleResponseIntent(requestCode: Int): PendingIntent {\n        val intent = Intent(context, HomeActivity::class.java).apply {\n            action = TraktConstants.INTENT_ACTION_HANDLE_AUTH_RESPONSE\n        }\n        return PendingIntent.getActivity(context, requestCode, intent, 0)\n    }\n\n    override fun startLogin() {\n        throw IllegalArgumentException(\"This app navigator can't handle login calls\")\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.inject\n\nimport android.content.Context\nimport android.content.SharedPreferences\nimport android.os.Build\nimport android.text.format.DateFormat as AndroidDateFormat\nimport androidx.lifecycle.ProcessLifecycleOwner\nimport androidx.lifecycle.coroutineScope\nimport androidx.navigation.ui.AppBarConfiguration\nimport androidx.preference.PreferenceManager\nimport app.tivi.BuildConfig\nimport app.tivi.TiviApplication\nimport app.tivi.extensions.toThreeTenDateTimeFormatter\nimport app.tivi.home.followed.R\nimport app.tivi.util.AppCoroutineDispatchers\nimport dagger.Module\nimport dagger.Provides\nimport io.reactivex.disposables.CompositeDisposable\nimport java.io.File\nimport java.text.SimpleDateFormat\nimport java.util.concurrent.Executor\nimport java.util.concurrent.Executors\nimport javax.inject.Named\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport org.threeten.bp.ZoneId\nimport org.threeten.bp.format.DateTimeFormatter\n\n@Module(includes = [AppModuleBinds::class])\nclass AppModule {\n    @Provides\n    fun provideContext(application: TiviApplication): Context = application.applicationContext\n\n    @ApplicationId\n    @Provides\n    fun provideApplicationId(application: TiviApplication): String = application.packageName\n\n    @Singleton\n    @Provides\n    fun provideCoroutineDispatchers() = AppCoroutineDispatchers(\n        io = Dispatchers.IO,\n        computation = Dispatchers.Default,\n        main = Dispatchers.Main\n    )\n\n    @Singleton\n    @Provides\n    fun provideBackgroundExecutor(): Executor {\n        val parallelism = (Runtime.getRuntime().availableProcessors() * 2)\n            .coerceIn(4, 32)\n        return if (Build.VERSION.SDK_INT < 24) {\n            Executors.newFixedThreadPool(parallelism)\n        } else {\n            Executors.newWorkStealingPool(parallelism)\n        }\n    }\n\n    @Named(\"app\")\n    @Provides\n    @Singleton\n    fun provideAppPreferences(application: TiviApplication): SharedPreferences {\n        return PreferenceManager.getDefaultSharedPreferences(application)\n    }\n\n    @Provides\n    @Singleton\n    @Named(\"cache\")\n    fun provideCacheDir(application: TiviApplication): File = application.cacheDir\n\n    @Provides\n    @Named(\"tmdb-api\")\n    fun provideTmdbApiKey(): String = BuildConfig.TMDB_API_KEY\n\n    @Provides\n    @Named(\"trakt-client-id\")\n    fun provideTraktClientId(): String = BuildConfig.TRAKT_CLIENT_ID\n\n    @Provides\n    @Named(\"trakt-client-secret\")\n    fun provideTraktClientSecret(): String = BuildConfig.TRAKT_CLIENT_SECRET\n\n    @Provides\n    fun provideCompositeDisposable() = CompositeDisposable()\n\n    @Singleton\n    @Provides\n    @MediumDate\n    fun provideMediumDateFormatter(application: TiviApplication): DateTimeFormatter {\n        @Suppress(\"DEPRECATION\")\n        return (AndroidDateFormat.getMediumDateFormat(application) as SimpleDateFormat)\n            .toThreeTenDateTimeFormatter()\n            .withLocale(application.resources.configuration.locale)\n            .withZone(ZoneId.systemDefault())\n    }\n\n    @Singleton\n    @Provides\n    @MediumDateTime\n    fun provideDateTimeFormatter(application: TiviApplication): DateTimeFormatter {\n        val dateF = AndroidDateFormat.getMediumDateFormat(application) as SimpleDateFormat\n        val timeF = AndroidDateFormat.getTimeFormat(application) as SimpleDateFormat\n\n        @Suppress(\"DEPRECATION\")\n        return DateTimeFormatter.ofPattern(\"${dateF.toPattern()} ${timeF.toPattern()}\")\n            .withLocale(application.resources.configuration.locale)\n            .withZone(ZoneId.systemDefault())\n    }\n\n    @Singleton\n    @Provides\n    @ShortDate\n    fun provideShortDateFormatter(application: TiviApplication): DateTimeFormatter {\n        @Suppress(\"DEPRECATION\")\n        return (AndroidDateFormat.getDateFormat(application) as SimpleDateFormat)\n            .toThreeTenDateTimeFormatter()\n            .withLocale(application.resources.configuration.locale)\n            .withZone(ZoneId.systemDefault())\n    }\n\n    @Singleton\n    @Provides\n    @ShortTime\n    fun provideShortTimeFormatter(application: TiviApplication): DateTimeFormatter {\n        @Suppress(\"DEPRECATION\")\n        return (AndroidDateFormat.getTimeFormat(application) as SimpleDateFormat)\n            .toThreeTenDateTimeFormatter()\n    }\n\n    @Provides\n    @ProcessLifetime\n    fun provideLongLifetimeScope(): CoroutineScope {\n        return ProcessLifecycleOwner.get().lifecycle.coroutineScope\n    }\n\n    @Provides\n    @Singleton\n    fun provideAppBarConfiguration() = AppBarConfiguration.Builder(\n        R.id.navigation_followed,\n        R.id.navigation_watched,\n        R.id.navigation_discover,\n        R.id.navigation_search\n    ).build()\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.inject\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\n\n@AssistedModule\n@Module(includes = [AssistedInject_AppAssistedModule::class])\nabstract class AppAssistedModule",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.inject\n\nimport app.tivi.BuildConfig\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\nimport okhttp3.logging.HttpLoggingInterceptor\n\n@Module\nclass NetworkModule {\n    @Singleton\n    @Provides\n    fun provideHttpLoggingInterceptor(): HttpLoggingInterceptor {\n        return HttpLoggingInterceptor().apply {\n            if (BuildConfig.DEBUG) {\n                level = HttpLoggingInterceptor.Level.HEADERS\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.inject\n\nimport android.app.Application\nimport app.tivi.AppNavigator\nimport app.tivi.TiviAppNavigator\nimport app.tivi.TiviApplication\nimport app.tivi.appinitializers.AppInitializer\nimport app.tivi.appinitializers.ArchTaskExecutorInitializer\nimport app.tivi.appinitializers.ClearGlideCacheInitializer\nimport app.tivi.appinitializers.EmojiInitializer\nimport app.tivi.appinitializers.PreferencesInitializer\nimport app.tivi.appinitializers.ThreeTenBpInitializer\nimport app.tivi.appinitializers.TimberInitializer\nimport app.tivi.appinitializers.TmdbInitializer\nimport app.tivi.settings.TiviPreferences\nimport app.tivi.settings.TiviPreferencesImpl\nimport app.tivi.util.Logger\nimport app.tivi.util.TiviLogger\nimport dagger.Binds\nimport dagger.Module\nimport dagger.multibindings.IntoSet\nimport javax.inject.Named\nimport javax.inject.Singleton\n\n@Module\nabstract class AppModuleBinds {\n    @Binds\n    abstract fun provideApplication(bind: TiviApplication): Application\n\n    @Singleton\n    @Named(\"app\")\n    @Binds\n    abstract fun provideAppNavigator(bind: TiviAppNavigator): AppNavigator\n\n    @Singleton\n    @Binds\n    abstract fun provideLogger(bind: TiviLogger): Logger\n\n    @Singleton\n    @Binds\n    abstract fun providePreferences(bind: TiviPreferencesImpl): TiviPreferences\n\n    @Binds\n    @IntoSet\n    abstract fun provideEmojiInitializer(bind: EmojiInitializer): AppInitializer\n\n    @Binds\n    @IntoSet\n    abstract fun provideThreeTenAbpInitializer(bind: ThreeTenBpInitializer): AppInitializer\n\n    @Binds\n    @IntoSet\n    abstract fun provideTimberInitializer(bind: TimberInitializer): AppInitializer\n\n    @Binds\n    @IntoSet\n    abstract fun providePreferencesInitializer(bind: PreferencesInitializer): AppInitializer\n\n    @Binds\n    @IntoSet\n    abstract fun provideArchTaskExecutorInitializer(bind: ArchTaskExecutorInitializer): AppInitializer\n\n    @Binds\n    @IntoSet\n    abstract fun provideTmdbInitializer(bind: TmdbInitializer): AppInitializer\n\n    @Binds\n    @IntoSet\n    abstract fun provideClearGlideInitializer(bind: ClearGlideCacheInitializer): AppInitializer\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.inject\n\nimport app.tivi.TiviApplication\nimport app.tivi.common.epoxy.EpoxyModule\nimport app.tivi.common.imageloading.ImageLoadingModule\nimport app.tivi.data.DataModule\nimport app.tivi.data.DatabaseModule\nimport app.tivi.home.HomeBuilder\nimport app.tivi.showdetails.ShowDetailsBuilder\nimport app.tivi.tasks.inject.TasksModule\nimport app.tivi.tmdb.TmdbModule\nimport app.tivi.trakt.TraktAuthModule\nimport app.tivi.trakt.TraktModule\nimport dagger.BindsInstance\nimport dagger.Component\nimport dagger.android.AndroidInjector\nimport dagger.android.support.AndroidSupportInjectionModule\nimport javax.inject.Singleton\n\n@Singleton\n@Component(modules = [\n    AndroidSupportInjectionModule::class,\n    AppModule::class,\n    TasksModule::class,\n    AppAssistedModule::class,\n    DatabaseModule::class,\n    DataModule::class,\n    HomeBuilder::class,\n    ShowDetailsBuilder::class,\n    TraktModule::class,\n    TraktAuthModule::class,\n    TmdbModule::class,\n    NetworkModule::class,\n    ImageLoadingModule::class,\n    EpoxyModule::class\n])\ninterface AppComponent : AndroidInjector<TiviApplication> {\n    @Component.Factory\n    interface Factory {\n        fun create(@BindsInstance application: TiviApplication): AppComponent\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails\n\nimport android.content.Intent\nimport android.os.Bundle\nimport android.view.View\nimport androidx.core.view.updatePadding\nimport androidx.fragment.app.commit\nimport androidx.navigation.fragment.NavHostFragment\nimport app.tivi.R\nimport app.tivi.TiviActivity\nimport dev.chrisbanes.insetter.doOnApplyWindowInsets\n\nclass ShowDetailsActivity : TiviActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_show_details)\n\n        findViewById<View>(R.id.details_root).apply {\n            systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or\n                View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or\n                View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION\n\n            doOnApplyWindowInsets { view, insets, initialState ->\n                view.updatePadding(\n                    left = insets.systemWindowInsetLeft + initialState.paddings.left,\n                    right = insets.systemWindowInsetRight + initialState.paddings.right\n                )\n            }\n        }\n\n        postponeEnterTransition()\n    }\n\n    override fun handleIntent(intent: Intent) {\n        supportFragmentManager.commit {\n            replace(R.id.details_content,\n                NavHostFragment.create(R.navigation.show_details_nav_graph, intent.extras))\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails\n\nimport app.tivi.episodedetails.EpisodeDetailsFragmentBuilder\nimport app.tivi.showdetails.details.ShowDetailsFragmentBuilder\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\ninternal abstract class ShowDetailsBuilder {\n    @ContributesAndroidInjector(modules = [\n        ShowDetailsModule::class,\n        ShowDetailsFragmentBuilder::class,\n        EpisodeDetailsFragmentBuilder::class\n    ])\n    internal abstract fun bindDetailsActivity(): ShowDetailsActivity\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails\n\nimport android.content.Context\nimport app.tivi.inject.PerActivity\nimport dagger.Module\nimport dagger.Provides\n\n@Module\nclass ShowDetailsModule {\n    @Provides\n    @PerActivity\n    fun provideActivity(activity: ShowDetailsActivity): Context = activity\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.appinitializers\n\nimport android.app.Application\nimport app.tivi.domain.interactors.UpdateTmdbConfig\nimport javax.inject.Inject\n\nclass TmdbInitializer @Inject constructor(\n    private val updateTmdbConfig: UpdateTmdbConfig\n) : AppInitializer {\n    override fun init(application: Application) {\n        updateTmdbConfig(Unit)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.appinitializers\n\nimport android.app.Application\nimport androidx.core.provider.FontRequest\nimport androidx.emoji.text.EmojiCompat\nimport androidx.emoji.text.FontRequestEmojiCompatConfig\nimport app.tivi.R\nimport javax.inject.Inject\n\nclass EmojiInitializer @Inject constructor() : AppInitializer {\n    override fun init(application: Application) {\n        val fontRequest = FontRequest(\n            \"com.google.android.gms.fonts\",\n            \"com.google.android.gms\",\n            \"Noto Color Emoji Compat\",\n            R.array.com_google_android_gms_fonts_certs)\n\n        val config = FontRequestEmojiCompatConfig(application, fontRequest)\n            .setReplaceAll(true)\n\n        EmojiCompat.init(config)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.appinitializers\n\nimport android.app.Application\nimport app.tivi.util.AppCoroutineDispatchers\nimport com.jakewharton.threetenabp.AndroidThreeTen\nimport javax.inject.Inject\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\nimport org.threeten.bp.zone.ZoneRulesProvider\n\nclass ThreeTenBpInitializer @Inject constructor(\n    private val dispatchers: AppCoroutineDispatchers\n) : AppInitializer {\n    override fun init(application: Application) {\n        // Init ThreeTenABP\n        AndroidThreeTen.init(application)\n\n        // Query the ZoneRulesProvider so that it is loaded on a background coroutine\n        GlobalScope.launch(dispatchers.io) {\n            ZoneRulesProvider.getAvailableZoneIds()\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.appinitializers\n\nimport android.annotation.SuppressLint\nimport android.app.Application\nimport android.os.Handler\nimport android.os.Looper\nimport androidx.arch.core.executor.ArchTaskExecutor\nimport androidx.arch.core.executor.TaskExecutor\nimport java.util.concurrent.Executor\nimport javax.inject.Inject\n\nclass ArchTaskExecutorInitializer @Inject constructor(\n    private val backgroundExecutor: Executor\n) : AppInitializer {\n    @SuppressLint(\"RestrictedApi\")\n    override fun init(application: Application) {\n        ArchTaskExecutor.getInstance().setDelegate(object : TaskExecutor() {\n            @Volatile private var mainHandler: Handler? = null\n            private val lock = Any()\n\n            override fun executeOnDiskIO(runnable: Runnable) {\n                backgroundExecutor.execute(runnable)\n            }\n\n            override fun postToMainThread(runnable: Runnable) {\n                if (mainHandler == null) {\n                    synchronized(lock) {\n                        if (mainHandler == null) {\n                            mainHandler = Handler(Looper.getMainLooper())\n                        }\n                    }\n                }\n                mainHandler?.post(runnable)\n            }\n\n            override fun isMainThread(): Boolean {\n                return Looper.getMainLooper().thread === Thread.currentThread()\n            }\n        })\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.appinitializers\n\nimport android.app.Application\nimport app.tivi.BuildConfig\nimport app.tivi.util.TiviLogger\nimport javax.inject.Inject\n\nclass TimberInitializer @Inject constructor(\n    private val tiviLogger: TiviLogger\n) : AppInitializer {\n    override fun init(application: Application) = tiviLogger.setup(BuildConfig.DEBUG)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.appinitializers\n\nimport android.app.Application\nimport app.tivi.domain.interactors.DeleteFolder\nimport java.io.File\nimport javax.inject.Inject\n\nclass ClearGlideCacheInitializer @Inject constructor(\n    private val deleteFolder: DeleteFolder\n) : AppInitializer {\n    override fun init(application: Application) {\n        val dir = File(application.cacheDir, \"image_manager_disk_cache\")\n        deleteFolder(DeleteFolder.Params(dir))\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.appinitializers\n\nimport android.app.Application\nimport app.tivi.settings.TiviPreferences\nimport javax.inject.Inject\n\nclass PreferencesInitializer @Inject constructor(\n    private val prefs: TiviPreferences\n) : AppInitializer {\n    override fun init(application: Application) {\n        prefs.setup()\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.appinitializers\n\nimport android.app.Application\nimport javax.inject.Inject\n\nclass AppInitializers @Inject constructor(\n    private val initializers: Set<@JvmSuppressWildcards AppInitializer>\n) {\n    fun init(application: Application) {\n        initializers.forEach {\n            it.init(application)\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi\n\nimport androidx.work.Configuration\nimport app.tivi.appinitializers.AppInitializers\nimport app.tivi.inject.DaggerAppComponent\nimport dagger.android.AndroidInjector\nimport dagger.android.DaggerApplication\nimport javax.inject.Inject\n\nclass TiviApplication : DaggerApplication(), Configuration.Provider {\n    @Inject lateinit var workConfiguration: Configuration\n    @Inject lateinit var initializers: AppInitializers\n\n    override fun onCreate() {\n        super.onCreate()\n        initializers.init(this)\n    }\n\n    override fun applicationInjector(): AndroidInjector<out DaggerApplication> {\n        return DaggerAppComponent.factory().create(this)\n    }\n\n    override fun getWorkManagerConfiguration(): Configuration = workConfiguration\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.discover\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\nabstract class DiscoverBuilder {\n    @ContributesAndroidInjector(modules = [DiscoverAssistedModule::class])\n    abstract fun discoverFragment(): DiscoverFragment\n}\n\n@Module(includes = [AssistedInject_DiscoverAssistedModule::class])\n@AssistedModule\ninterface DiscoverAssistedModule",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.discover\n\nimport app.tivi.data.entities.TraktUser\nimport app.tivi.data.resultentities.EpisodeWithSeasonWithShow\nimport app.tivi.data.resultentities.PopularEntryWithShow\nimport app.tivi.data.resultentities.RecommendedEntryWithShow\nimport app.tivi.data.resultentities.TrendingEntryWithShow\nimport app.tivi.trakt.TraktAuthState\nimport com.airbnb.mvrx.MvRxState\n\ndata class DiscoverViewState(\n    val user: TraktUser? = null,\n    val authState: TraktAuthState = TraktAuthState.LOGGED_OUT,\n    val trendingItems: List<TrendingEntryWithShow> = emptyList(),\n    val trendingRefreshing: Boolean = false,\n    val popularItems: List<PopularEntryWithShow> = emptyList(),\n    val popularRefreshing: Boolean = false,\n    val recommendedItems: List<RecommendedEntryWithShow> = emptyList(),\n    val recommendedRefreshing: Boolean = false,\n    val nextEpisodeWithShowToWatched: EpisodeWithSeasonWithShow? = null\n) : MvRxState",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.discover\n\nimport androidx.lifecycle.viewModelScope\nimport app.tivi.AppNavigator\nimport app.tivi.TiviMvRxViewModel\nimport app.tivi.domain.interactors.UpdatePopularShows\nimport app.tivi.domain.interactors.UpdateRecommendedShows\nimport app.tivi.domain.interactors.UpdateTrendingShows\nimport app.tivi.domain.invoke\nimport app.tivi.domain.launchObserve\nimport app.tivi.domain.observers.ObserveNextShowEpisodeToWatch\nimport app.tivi.domain.observers.ObservePopularShows\nimport app.tivi.domain.observers.ObserveRecommendedShows\nimport app.tivi.domain.observers.ObserveTraktAuthState\nimport app.tivi.domain.observers.ObserveTrendingShows\nimport app.tivi.domain.observers.ObserveUserDetails\nimport app.tivi.trakt.TraktAuthState\nimport app.tivi.util.ObservableLoadingCounter\nimport app.tivi.util.collectFrom\nimport com.airbnb.mvrx.FragmentViewModelContext\nimport com.airbnb.mvrx.MvRxViewModelFactory\nimport com.airbnb.mvrx.ViewModelContext\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\nimport javax.inject.Provider\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.distinctUntilChanged\nimport kotlinx.coroutines.flow.onEach\nimport kotlinx.coroutines.launch\n\ninternal class DiscoverViewModel @AssistedInject constructor(\n    @Assisted initialState: DiscoverViewState,\n    private val updatePopularShows: UpdatePopularShows,\n    observePopularShows: ObservePopularShows,\n    private val updateTrendingShows: UpdateTrendingShows,\n    observeTrendingShows: ObserveTrendingShows,\n    private val updateRecommendedShows: UpdateRecommendedShows,\n    observeRecommendedShows: ObserveRecommendedShows,\n    observeNextShowEpisodeToWatch: ObserveNextShowEpisodeToWatch,\n    observeTraktAuthState: ObserveTraktAuthState,\n    observeUserDetails: ObserveUserDetails,\n    private val appNavigator: Provider<AppNavigator>\n) : TiviMvRxViewModel<DiscoverViewState>(initialState) {\n    private val trendingLoadingState = ObservableLoadingCounter()\n    private val popularLoadingState = ObservableLoadingCounter()\n    private val recommendedLoadingState = ObservableLoadingCounter()\n\n    init {\n        viewModelScope.launch {\n            trendingLoadingState.observable.collect { active ->\n                setState { copy(trendingRefreshing = active) }\n            }\n        }\n\n        viewModelScope.launch {\n            popularLoadingState.observable.collect { active ->\n                setState { copy(popularRefreshing = active) }\n            }\n        }\n\n        viewModelScope.launch {\n            recommendedLoadingState.observable.collect { active ->\n                setState { copy(recommendedRefreshing = active) }\n            }\n        }\n\n        viewModelScope.launchObserve(observeTrendingShows) {\n            it.distinctUntilChanged().execute {\n                copy(trendingItems = it() ?: emptyList())\n            }\n        }\n        observeTrendingShows(ObserveTrendingShows.Params(15))\n\n        viewModelScope.launchObserve(observePopularShows) {\n            it.distinctUntilChanged().execute {\n                copy(popularItems = it() ?: emptyList())\n            }\n        }\n        observePopularShows()\n\n        viewModelScope.launchObserve(observeRecommendedShows) {\n            it.distinctUntilChanged().execute {\n                copy(recommendedItems = it() ?: emptyList())\n            }\n        }\n        observeRecommendedShows()\n\n        viewModelScope.launchObserve(observeNextShowEpisodeToWatch) {\n            it.distinctUntilChanged().execute {\n                copy(nextEpisodeWithShowToWatched = it())\n            }\n        }\n        observeNextShowEpisodeToWatch()\n\n        viewModelScope.launchObserve(observeTraktAuthState) { flow ->\n            flow.distinctUntilChanged().onEach {\n                if (it == TraktAuthState.LOGGED_IN) {\n                    refresh(false)\n                }\n            }.execute {\n                copy(authState = it() ?: TraktAuthState.LOGGED_OUT)\n            }\n        }\n        observeTraktAuthState()\n\n        viewModelScope.launchObserve(observeUserDetails) {\n            it.execute { copy(user = it()) }\n        }\n        observeUserDetails(ObserveUserDetails.Params(\"me\"))\n\n        refresh(false)\n    }\n\n    fun onLoginClicked() {\n        appNavigator.get().startLogin()\n    }\n\n    fun refresh() = refresh(true)\n\n    private fun refresh(fromUser: Boolean) {\n        updatePopularShows(UpdatePopularShows.Params(UpdatePopularShows.Page.REFRESH, fromUser)).also {\n            viewModelScope.launch {\n                popularLoadingState.collectFrom(it)\n            }\n        }\n        updateTrendingShows(UpdateTrendingShows.Params(UpdateTrendingShows.Page.REFRESH, fromUser)).also {\n            viewModelScope.launch {\n                trendingLoadingState.collectFrom(it)\n            }\n        }\n        updateRecommendedShows(UpdateRecommendedShows.Params(UpdateRecommendedShows.Page.REFRESH, fromUser)).also {\n            viewModelScope.launch {\n                recommendedLoadingState.collectFrom(it)\n            }\n        }\n    }\n\n    @AssistedInject.Factory\n    interface Factory {\n        fun create(initialState: DiscoverViewState): DiscoverViewModel\n    }\n\n    companion object : MvRxViewModelFactory<DiscoverViewModel, DiscoverViewState> {\n        override fun create(\n            viewModelContext: ViewModelContext,\n            state: DiscoverViewState\n        ): DiscoverViewModel? {\n            val fragment: DiscoverFragment = (viewModelContext as FragmentViewModelContext).fragment()\n            return fragment.discoverViewModelFactory.create(state)\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.discover\n\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.ViewGroup\nimport androidx.core.net.toUri\nimport androidx.core.view.updatePadding\nimport androidx.navigation.fragment.findNavController\nimport app.tivi.TiviFragmentWithBinding\nimport app.tivi.common.imageloading.loadImageUrl\nimport app.tivi.data.Entry\nimport app.tivi.data.resultentities.EntryWithShow\nimport app.tivi.extensions.doOnSizeChange\nimport app.tivi.extensions.navigateToNavDestination\nimport app.tivi.extensions.scheduleStartPostponedTransitions\nimport app.tivi.extensions.toActivityNavigatorExtras\nimport app.tivi.extensions.toFragmentNavigatorExtras\nimport app.tivi.home.discover.databinding.FragmentDiscoverBinding\nimport app.tivi.ui.AuthStateMenuItemBinder\nimport app.tivi.ui.SpacingItemDecorator\nimport app.tivi.ui.authStateToolbarMenuBinder\nimport app.tivi.ui.createSharedElementHelperForItemId\nimport app.tivi.ui.createSharedElementHelperForItems\nimport app.tivi.ui.transitions.GridToGridTransitioner\nimport com.airbnb.mvrx.fragmentViewModel\nimport com.airbnb.mvrx.withState\nimport javax.inject.Inject\n\nclass DiscoverFragment : TiviFragmentWithBinding<FragmentDiscoverBinding>() {\n    private val viewModel: DiscoverViewModel by fragmentViewModel()\n\n    @Inject internal lateinit var discoverViewModelFactory: DiscoverViewModel.Factory\n    @Inject internal lateinit var controller: DiscoverEpoxyController\n\n    private var authStateMenuItemBinder: AuthStateMenuItemBinder? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        GridToGridTransitioner.setupFirstFragment(this)\n    }\n\n    override fun createBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): FragmentDiscoverBinding {\n        return FragmentDiscoverBinding.inflate(inflater, container, false)\n    }\n\n    override fun onViewCreated(binding: FragmentDiscoverBinding, savedInstanceState: Bundle?) {\n        // Disable transition for now due to https://issuetracker.google.com/129035555\n        // postponeEnterTransitionWithTimeout()\n\n        binding.summaryRv.apply {\n            setController(controller)\n            addItemDecoration(SpacingItemDecorator(paddingLeft))\n        }\n\n        binding.followedAppBar.doOnSizeChange {\n            binding.summaryRv.updatePadding(top = it.height)\n            binding.summarySwipeRefresh.setProgressViewOffset(true, 0,\n                it.height + binding.summarySwipeRefresh.progressCircleDiameter / 2)\n            true\n        }\n\n        authStateMenuItemBinder = authStateToolbarMenuBinder(\n            binding.discoverToolbar,\n            R.id.home_menu_user_avatar,\n            R.id.home_menu_user_login\n        ) { menuItem, url -> menuItem.loadImageUrl(requireContext(), url) }\n\n        binding.discoverToolbar.setOnMenuItemClickListener {\n            when (it.itemId) {\n                R.id.home_menu_user_login -> {\n                    viewModel.onLoginClicked()\n                }\n                R.id.home_menu_user_avatar -> {\n                    findNavController().navigateToNavDestination(R.id.navigation_settings)\n                }\n            }\n            true\n        }\n\n        controller.callbacks = object : DiscoverEpoxyController.Callbacks {\n            override fun onTrendingHeaderClicked() {\n                withState(viewModel) { state ->\n                    val extras = binding.summaryRv.createSharedElementHelperForItems(state.trendingItems)\n\n                    findNavController().navigate(\n                        R.id.navigation_trending,\n                        null,\n                        null,\n                        extras.toFragmentNavigatorExtras())\n                }\n            }\n\n            override fun onPopularHeaderClicked() {\n                withState(viewModel) { state ->\n                    val extras = binding.summaryRv.createSharedElementHelperForItems(state.popularItems)\n\n                    findNavController().navigate(\n                        R.id.navigation_popular,\n                        null,\n                        null,\n                        extras.toFragmentNavigatorExtras())\n                }\n            }\n\n            override fun onRecommendedHeaderClicked() {\n                withState(viewModel) { state ->\n                    val extras = binding.summaryRv.createSharedElementHelperForItems(state.recommendedItems)\n\n                    findNavController().navigate(\n                        R.id.navigation_recommended,\n                        null,\n                        null,\n                        extras.toFragmentNavigatorExtras())\n                }\n            }\n\n            override fun onItemClicked(viewHolderId: Long, item: EntryWithShow<out Entry>) {\n                val elements = binding.summaryRv.createSharedElementHelperForItemId(viewHolderId, \"poster\") {\n                    it.findViewById(R.id.show_poster)\n                }\n                findNavController().navigate(\n                    \"app.tivi://show/${item.show.id}\".toUri(),\n                    null,\n                    elements.toActivityNavigatorExtras(requireActivity())\n                )\n            }\n\n            override fun onNextEpisodeToWatchClicked() {\n                withState(viewModel) {\n                    checkNotNull(it.nextEpisodeWithShowToWatched)\n                    val show = it.nextEpisodeWithShowToWatched.show\n                    val episode = it.nextEpisodeWithShowToWatched.episode\n                    findNavController().navigate(\n                        \"app.tivi://show/${show.id}/episode/${episode.id}\".toUri()\n                    )\n                }\n            }\n        }\n\n        binding.summarySwipeRefresh.setOnRefreshListener {\n            viewModel.refresh()\n            binding.summarySwipeRefresh.postOnAnimation {\n                binding.summarySwipeRefresh.isRefreshing = false\n            }\n        }\n    }\n\n    override fun invalidate(binding: FragmentDiscoverBinding) = withState(viewModel) { state ->\n        if (binding.state == null) {\n            // First time we've had state, start any postponed transitions\n            scheduleStartPostponedTransitions()\n        }\n\n        authStateMenuItemBinder?.bind(state.authState, state.user)\n\n        binding.state = state\n        controller.state = state\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        controller.clear()\n        authStateMenuItemBinder = null\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.discover\n\nimport android.content.Context\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport app.tivi.inject.PerActivity\nimport javax.inject.Inject\n\ninternal class DiscoverTextCreator @Inject constructor(\n    @PerActivity private val context: Context\n) {\n    fun seasonEpisodeTitleText(season: Season, episode: Episode): String {\n        return context.getString(R.string.season_episode_number, season.number, episode.number)\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.discover\n\nimport android.content.Context\nimport app.tivi.common.epoxy.TotalSpanOverride\nimport app.tivi.common.epoxy.tiviCarousel\nimport app.tivi.common.epoxy.withModelsFrom\nimport app.tivi.common.layouts.PosterCardItemBindingModel_\nimport app.tivi.common.layouts.emptyState\nimport app.tivi.common.layouts.header\nimport app.tivi.common.layouts.vertSpacerNormal\nimport app.tivi.data.Entry\nimport app.tivi.data.entities.findHighestRatedPoster\nimport app.tivi.data.resultentities.EntryWithShow\nimport app.tivi.extensions.observable\nimport com.airbnb.epoxy.Carousel\nimport com.airbnb.epoxy.EpoxyController\nimport javax.inject.Inject\n\ninternal class DiscoverEpoxyController @Inject constructor(\n    private val context: Context,\n    private val textCreator: DiscoverTextCreator\n) : EpoxyController() {\n    var callbacks: Callbacks? by observable(null, ::requestModelBuild)\n    var state: DiscoverViewState by observable(DiscoverViewState(), ::requestModelBuild)\n\n    interface Callbacks {\n        fun onTrendingHeaderClicked()\n        fun onPopularHeaderClicked()\n        fun onRecommendedHeaderClicked()\n        fun onNextEpisodeToWatchClicked()\n        fun onItemClicked(viewHolderId: Long, item: EntryWithShow<out Entry>)\n    }\n\n    override fun buildModels() {\n        val trendingShows = state.trendingItems\n        val popularShows = state.popularItems\n        val recommendedShows = state.recommendedItems\n\n        vertSpacerNormal {\n            id(\"top_spacer\")\n        }\n\n        state.nextEpisodeWithShowToWatched?.also { nextEpisodeToWatch ->\n            header {\n                id(\"keep_watching_header\")\n                title(R.string.discover_keep_watching_title)\n                spanSizeOverride(TotalSpanOverride)\n            }\n            discoverNextShowEpisodeToWatch {\n                id(\"keep_watching_${nextEpisodeToWatch.episode.id}\")\n                spanSizeOverride(TotalSpanOverride)\n                episode(nextEpisodeToWatch.episode)\n                season(nextEpisodeToWatch.season)\n                tiviShow(nextEpisodeToWatch.show)\n                posterImage(nextEpisodeToWatch.images.findHighestRatedPoster())\n                textCreator(textCreator)\n                clickListener { _ -> callbacks?.onNextEpisodeToWatchClicked() }\n            }\n        }\n\n        if (modelCountBuiltSoFar > 1) {\n            vertSpacerNormal {\n                id(\"trending_header_spacer\")\n            }\n        }\n        header {\n            id(\"trending_header\")\n            title(R.string.discover_trending_title)\n            showProgress(state.trendingRefreshing)\n            spanSizeOverride(TotalSpanOverride)\n            buttonClickListener { _ -> callbacks?.onTrendingHeaderClicked() }\n        }\n        if (trendingShows.isNotEmpty()) {\n            tiviCarousel {\n                id(\"trending_carousel\")\n                itemWidth(context.resources.getDimensionPixelSize(R.dimen.discover_carousel_item_width))\n                hasFixedSize(true)\n\n                val vert = context.resources.getDimensionPixelSize(R.dimen.spacing_small)\n                val horiz = context.resources.getDimensionPixelSize(R.dimen.spacing_normal)\n                val itemSpacing = context.resources.getDimensionPixelSize(R.dimen.spacing_micro)\n                padding(Carousel.Padding(horiz, vert, horiz, vert, itemSpacing))\n\n                withModelsFrom(trendingShows) { item ->\n                    PosterCardItemBindingModel_().apply {\n                        id(item.generateStableId())\n                        tiviShow(item.show)\n                        posterImage(item.images.findHighestRatedPoster())\n                        transitionName(\"trending_${item.show.homepage}\")\n                        clickListener { model, _, _, _ ->\n                            callbacks?.onItemClicked(model.id(), item)\n                        }\n                    }\n                }\n            }\n        } else {\n            emptyState {\n                id(\"trending_placeholder\")\n                spanSizeOverride(TotalSpanOverride)\n            }\n        }\n\n        if (recommendedShows.isNotEmpty()) {\n            vertSpacerNormal {\n                id(\"recommended_header_spacer\")\n            }\n            header {\n                id(\"recommended_header\")\n                title(R.string.discover_recommended_title)\n                showProgress(state.recommendedRefreshing)\n                spanSizeOverride(TotalSpanOverride)\n                buttonClickListener { _ -> callbacks?.onRecommendedHeaderClicked() }\n            }\n            tiviCarousel {\n                id(\"recommended_carousel\")\n                itemWidth(context.resources.getDimensionPixelSize(R.dimen.discover_carousel_item_width))\n                hasFixedSize(true)\n\n                val vert = context.resources.getDimensionPixelSize(R.dimen.spacing_small)\n                val horiz = context.resources.getDimensionPixelSize(R.dimen.spacing_normal)\n                val itemSpacing = context.resources.getDimensionPixelSize(R.dimen.spacing_micro)\n                padding(Carousel.Padding(horiz, vert, horiz, vert, itemSpacing))\n\n                withModelsFrom(recommendedShows) { item ->\n                    PosterCardItemBindingModel_().apply {\n                        id(item.generateStableId())\n                        tiviShow(item.show)\n                        posterImage(item.images.findHighestRatedPoster())\n                        transitionName(\"recommended_${item.show.homepage}\")\n                        clickListener { model, _, _, _ ->\n                            callbacks?.onItemClicked(model.id(), item)\n                        }\n                    }\n                }\n            }\n        }\n\n        vertSpacerNormal {\n            id(\"popular_header_spacer\")\n        }\n        header {\n            id(\"popular_header\")\n            title(R.string.discover_popular_title)\n            showProgress(state.popularRefreshing)\n            spanSizeOverride(TotalSpanOverride)\n            buttonClickListener { _ -> callbacks?.onPopularHeaderClicked() }\n        }\n        if (popularShows.isNotEmpty()) {\n            tiviCarousel {\n                id(\"popular_carousel\")\n                itemWidth(context.resources.getDimensionPixelSize(R.dimen.discover_carousel_item_width))\n                hasFixedSize(true)\n\n                val vert = context.resources.getDimensionPixelSize(R.dimen.spacing_small)\n                val horiz = context.resources.getDimensionPixelSize(R.dimen.spacing_normal)\n                val itemSpacing = context.resources.getDimensionPixelSize(R.dimen.spacing_micro)\n                padding(Carousel.Padding(horiz, vert, horiz, vert, itemSpacing))\n\n                withModelsFrom(popularShows) { item ->\n                    PosterCardItemBindingModel_().apply {\n                        id(item.generateStableId())\n                        posterImage(item.images.findHighestRatedPoster())\n                        tiviShow(item.show)\n                        transitionName(\"popular_${item.show.homepage}\")\n                        clickListener { model, _, _, _ ->\n                            callbacks?.onItemClicked(model.id(), item)\n                        }\n                    }\n                }\n            }\n        } else {\n            emptyState {\n                id(\"popular_placeholder\")\n                spanSizeOverride(TotalSpanOverride)\n            }\n        }\n\n        vertSpacerNormal {\n            id(\"bottom_spacer\")\n        }\n    }\n\n    fun clear() {\n        callbacks = null\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.watched\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\nabstract class WatchedBuilder {\n    @ContributesAndroidInjector(modules = [\n        WatchedAssistedModule::class\n    ])\n    abstract fun fragment(): WatchedFragment\n}\n\n@Module(includes = [AssistedInject_WatchedAssistedModule::class])\n@AssistedModule\ninterface WatchedAssistedModule",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.watched\n\nimport android.text.Editable\nimport android.text.TextWatcher\nimport app.tivi.common.epoxy.TotalSpanOverride\nimport app.tivi.common.layouts.emptyState\nimport app.tivi.common.layouts.filter\nimport app.tivi.common.layouts.vertSpacerNormal\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.entities.findHighestRatedPoster\nimport app.tivi.data.resultentities.WatchedShowEntryWithShow\nimport app.tivi.extensions.observable\nimport app.tivi.home.HomeTextCreator\nimport app.tivi.ui.SortPopupMenuListener\nimport app.tivi.ui.popupMenuItemIdToSortOption\nimport app.tivi.util.TiviDateFormatter\nimport com.airbnb.epoxy.EpoxyModel\nimport com.airbnb.epoxy.paging.PagedListEpoxyController\nimport javax.inject.Inject\n\ninternal class WatchedEpoxyController @Inject constructor(\n    private val textCreator: HomeTextCreator,\n    private val dateFormatter: TiviDateFormatter\n) : PagedListEpoxyController<WatchedShowEntryWithShow>() {\n    var state by observable(WatchedViewState(), ::requestModelBuild)\n    var callbacks: Callbacks? by observable(null, ::requestModelBuild)\n\n    override fun addModels(models: List<EpoxyModel<*>>) {\n        if (state.isEmpty) {\n            emptyState {\n                id(\"empty\")\n                spanSizeOverride(TotalSpanOverride)\n            }\n        } else {\n            vertSpacerNormal {\n                id(\"top_spacer\")\n            }\n\n            filter {\n                id(\"filters\")\n                filter(state.filter)\n                numberShows(models.size)\n                watcher(object : TextWatcher {\n                    override fun afterTextChanged(s: Editable?) {\n                        callbacks?.onFilterChanged(s?.toString() ?: \"\")\n                    }\n\n                    override fun beforeTextChanged(\n                        s: CharSequence?,\n                        start: Int,\n                        count: Int,\n                        after: Int\n                    ) {\n                    }\n\n                    override fun onTextChanged(\n                        s: CharSequence?,\n                        start: Int,\n                        before: Int,\n                        count: Int\n                    ) {\n                    }\n                })\n\n                popupMenuListener(SortPopupMenuListener(state.sort, state.availableSorts))\n                popupMenuClickListener {\n                    val option = popupMenuItemIdToSortOption(it.itemId)\n                        ?: throw IllegalArgumentException(\"Selected sort option is null\")\n                    callbacks?.onSortSelected(option)\n                    true\n                }\n            }\n\n            super.addModels(models)\n\n            vertSpacerNormal {\n                id(\"bottom_spacer\")\n            }\n        }\n    }\n\n    override fun buildItemModel(\n        currentPosition: Int,\n        item: WatchedShowEntryWithShow?\n    ): EpoxyModel<*> {\n        return LibraryWatchedItemBindingModel_().apply {\n            if (item != null) {\n                id(item.generateStableId())\n                tiviShow(item.show)\n                posterImage(item.images.findHighestRatedPoster())\n                posterTransitionName(\"show_${item.show.homepage}\")\n                selected(item.show.id in state.selectedShowIds)\n                clickListener { _ -> callbacks?.onItemClicked(item) }\n                longClickListener { _ -> callbacks?.onItemLongClicked(item) ?: false }\n            } else {\n                id(\"item_placeholder_$currentPosition\")\n            }\n            watchedEntry(item?.entry)\n            dateFormatter(dateFormatter)\n            textCreator(textCreator)\n        }\n    }\n\n    fun clear() {\n        callbacks = null\n    }\n\n    interface Callbacks {\n        fun onItemClicked(item: WatchedShowEntryWithShow)\n        fun onItemLongClicked(item: WatchedShowEntryWithShow): Boolean\n        fun onFilterChanged(filter: String)\n        fun onSortSelected(sort: SortOption)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.watched\n\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.entities.TraktUser\nimport app.tivi.trakt.TraktAuthState\nimport com.airbnb.mvrx.MvRxState\n\ndata class WatchedViewState(\n    val user: TraktUser? = null,\n    val authState: TraktAuthState = TraktAuthState.LOGGED_OUT,\n    val isLoading: Boolean = false,\n    val isEmpty: Boolean = false,\n    val selectionOpen: Boolean = false,\n    val selectedShowIds: Set<Long> = emptySet(),\n    val filterActive: Boolean = false,\n    val filter: String? = null,\n    val availableSorts: List<SortOption> = emptyList(),\n    val sort: SortOption = SortOption.LAST_WATCHED\n) : MvRxState",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.watched\n\nimport android.os.Bundle\nimport android.view.ActionMode\nimport android.view.LayoutInflater\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.ViewGroup\nimport androidx.core.net.toUri\nimport androidx.core.view.updatePadding\nimport androidx.lifecycle.lifecycleScope\nimport androidx.navigation.fragment.findNavController\nimport app.tivi.TiviFragmentWithBinding\nimport app.tivi.common.imageloading.loadImageUrl\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.resultentities.WatchedShowEntryWithShow\nimport app.tivi.extensions.doOnSizeChange\nimport app.tivi.extensions.navigateToNavDestination\nimport app.tivi.extensions.postponeEnterTransitionWithTimeout\nimport app.tivi.extensions.scheduleStartPostponedTransitions\nimport app.tivi.extensions.toActivityNavigatorExtras\nimport app.tivi.home.watched.databinding.FragmentWatchedBinding\nimport app.tivi.ui.AuthStateMenuItemBinder\nimport app.tivi.ui.SpacingItemDecorator\nimport app.tivi.ui.authStateToolbarMenuBinder\nimport app.tivi.ui.createSharedElementHelperForItem\nimport app.tivi.ui.recyclerview.HideImeOnScrollListener\nimport com.airbnb.mvrx.fragmentViewModel\nimport com.airbnb.mvrx.withState\nimport javax.inject.Inject\nimport kotlinx.coroutines.flow.collect\n\nclass WatchedFragment : TiviFragmentWithBinding<FragmentWatchedBinding>() {\n    private val viewModel: WatchedViewModel by fragmentViewModel()\n\n    @Inject internal lateinit var watchedViewModelFactory: WatchedViewModel.Factory\n    @Inject internal lateinit var controller: WatchedEpoxyController\n\n    private var authStateMenuItemBinder: AuthStateMenuItemBinder? = null\n\n    private var currentActionMode: ActionMode? = null\n\n    override fun createBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): FragmentWatchedBinding {\n        return FragmentWatchedBinding.inflate(inflater, container, false)\n    }\n\n    override fun onViewCreated(binding: FragmentWatchedBinding, savedInstanceState: Bundle?) {\n        postponeEnterTransitionWithTimeout()\n\n        authStateMenuItemBinder = authStateToolbarMenuBinder(\n            binding.watchedToolbar,\n            R.id.home_menu_user_avatar,\n            R.id.home_menu_user_login\n        ) { menuItem, url -> menuItem.loadImageUrl(requireContext(), url) }\n\n        binding.watchedToolbar.setOnMenuItemClickListener {\n            when (it.itemId) {\n                R.id.home_menu_user_login -> {\n                    viewModel.onLoginClicked()\n                }\n                R.id.home_menu_user_avatar -> {\n                    findNavController().navigateToNavDestination(R.id.navigation_settings)\n                }\n            }\n            true\n        }\n        binding.watchedToolbar.setNavigationOnClickListener {\n            findNavController().navigateUp()\n        }\n\n        binding.watchedAppBar.doOnSizeChange {\n            binding.watchedRv.updatePadding(top = it.height)\n            binding.watchedSwipeRefresh.setProgressViewOffset(true, 0,\n                it.height + binding.watchedSwipeRefresh.progressCircleDiameter / 2)\n            true\n        }\n\n        controller.callbacks = object : WatchedEpoxyController.Callbacks {\n            override fun onItemClicked(item: WatchedShowEntryWithShow) {\n                // Let the ViewModel have the first go\n                if (viewModel.onItemClick(item.show)) {\n                    return\n                }\n\n                val extras = binding.watchedRv.createSharedElementHelperForItem(item, \"poster\") {\n                    it.findViewById(R.id.show_poster)\n                }\n\n                findNavController().navigate(\n                    \"app.tivi://show/${item.show.id}\".toUri(),\n                    null,\n                    extras.toActivityNavigatorExtras(requireActivity())\n                )\n            }\n\n            override fun onItemLongClicked(item: WatchedShowEntryWithShow): Boolean {\n                return viewModel.onItemLongClick(item.show)\n            }\n\n            override fun onFilterChanged(filter: String) = viewModel.setFilter(filter)\n\n            override fun onSortSelected(sort: SortOption) = viewModel.setSort(sort)\n        }\n\n        binding.watchedRv.apply {\n            addItemDecoration(SpacingItemDecorator(paddingLeft))\n            addOnScrollListener(HideImeOnScrollListener())\n            setController(controller)\n        }\n\n        binding.watchedSwipeRefresh.setOnRefreshListener(viewModel::refresh)\n\n        lifecycleScope.launchWhenStarted {\n            viewModel.pagedList.collect {\n                controller.submitList(it)\n            }\n        }\n    }\n\n    override fun invalidate(binding: FragmentWatchedBinding) = withState(viewModel) { state ->\n        if (binding.state == null) {\n            // First time we've had state, start any postponed transitions\n            scheduleStartPostponedTransitions()\n        }\n\n        if (state.selectionOpen && currentActionMode == null) {\n            startSelectionActionMode()\n        } else if (!state.selectionOpen && currentActionMode != null) {\n            currentActionMode?.finish()\n        }\n\n        currentActionMode?.title = getString(R.string.selection_title, state.selectedShowIds.size)\n\n        authStateMenuItemBinder?.bind(state.authState, state.user)\n\n        binding.state = state\n        controller.state = state\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        currentActionMode?.finish()\n        controller.clear()\n        authStateMenuItemBinder = null\n    }\n\n    private fun startSelectionActionMode() {\n        currentActionMode = requireActivity().startActionMode(object : ActionMode.Callback {\n            override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {\n                when (item.itemId) {\n                    R.id.menu_follow -> viewModel.followSelectedShows()\n                }\n                return true\n            }\n\n            override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {\n                mode.menuInflater.inflate(R.menu.action_mode_watched, menu)\n                return true\n            }\n\n            override fun onPrepareActionMode(mode: ActionMode, menu: Menu) = true\n\n            override fun onDestroyActionMode(mode: ActionMode) {\n                viewModel.clearSelection()\n\n                if (mode == currentActionMode) {\n                    currentActionMode = null\n                }\n            }\n        })\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.watched\n\nimport androidx.lifecycle.viewModelScope\nimport androidx.paging.PagedList\nimport app.tivi.AppNavigator\nimport app.tivi.TiviMvRxViewModel\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.resultentities.WatchedShowEntryWithShow\nimport app.tivi.domain.interactors.ChangeShowFollowStatus\nimport app.tivi.domain.interactors.UpdateWatchedShows\nimport app.tivi.domain.invoke\nimport app.tivi.domain.launchObserve\nimport app.tivi.domain.observers.ObservePagedWatchedShows\nimport app.tivi.domain.observers.ObserveTraktAuthState\nimport app.tivi.domain.observers.ObserveUserDetails\nimport app.tivi.trakt.TraktAuthState\nimport app.tivi.util.ObservableLoadingCounter\nimport app.tivi.util.ShowStateSelector\nimport app.tivi.util.collectFrom\nimport com.airbnb.mvrx.FragmentViewModelContext\nimport com.airbnb.mvrx.MvRxViewModelFactory\nimport com.airbnb.mvrx.ViewModelContext\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.debounce\nimport kotlinx.coroutines.flow.distinctUntilChanged\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.flow.onEach\nimport kotlinx.coroutines.launch\n\ninternal class WatchedViewModel @AssistedInject constructor(\n    @Assisted initialState: WatchedViewState,\n    private val updateWatchedShows: UpdateWatchedShows,\n    private val changeShowFollowStatus: ChangeShowFollowStatus,\n    private val observePagedWatchedShows: ObservePagedWatchedShows,\n    private val observeTraktAuthState: ObserveTraktAuthState,\n    observeUserDetails: ObserveUserDetails,\n    private val appNavigator: AppNavigator\n) : TiviMvRxViewModel<WatchedViewState>(initialState) {\n    private val boundaryCallback = object : PagedList.BoundaryCallback<WatchedShowEntryWithShow>() {\n        override fun onZeroItemsLoaded() {\n            setState { copy(isEmpty = filter.isNullOrEmpty()) }\n        }\n\n        override fun onItemAtEndLoaded(itemAtEnd: WatchedShowEntryWithShow) {\n            setState { copy(isEmpty = false) }\n        }\n\n        override fun onItemAtFrontLoaded(itemAtFront: WatchedShowEntryWithShow) {\n            setState { copy(isEmpty = false) }\n        }\n    }\n\n    private val loadingState = ObservableLoadingCounter()\n    private val showSelection = ShowStateSelector()\n\n    val pagedList: Flow<PagedList<WatchedShowEntryWithShow>>\n        get() = observePagedWatchedShows.observe()\n\n    init {\n        viewModelScope.launch {\n            loadingState.observable\n                .distinctUntilChanged()\n                .debounce(2000)\n                .execute { copy(isLoading = it() ?: false) }\n        }\n\n        viewModelScope.launch {\n            showSelection.observeSelectedShowIds().collect {\n                setState { copy(selectedShowIds = it) }\n            }\n        }\n\n        viewModelScope.launch {\n            showSelection.observeIsSelectionOpen().collect {\n                setState { copy(selectionOpen = it) }\n            }\n        }\n\n        viewModelScope.launchObserve(observeTraktAuthState) { flow ->\n            flow.distinctUntilChanged().onEach {\n                if (it == TraktAuthState.LOGGED_IN) {\n                    refresh(false)\n                }\n            }.execute {\n                copy(authState = it() ?: TraktAuthState.LOGGED_OUT)\n            }\n        }\n        observeTraktAuthState()\n\n        viewModelScope.launchObserve(observeUserDetails) {\n            it.execute { copy(user = it()) }\n        }\n        observeUserDetails(ObserveUserDetails.Params(\"me\"))\n\n        // Set the available sorting options\n        setState {\n            copy(availableSorts = listOf(SortOption.LAST_WATCHED, SortOption.ALPHABETICAL))\n        }\n\n        // Subscribe to state changes, so update the observed data source\n        subscribe(::updateDataSource)\n\n        refresh(false)\n    }\n\n    private fun updateDataSource(state: WatchedViewState) {\n        observePagedWatchedShows(\n            ObservePagedWatchedShows.Params(\n                sort = state.sort,\n                filter = state.filter,\n                pagingConfig = PAGING_CONFIG,\n                boundaryCallback = boundaryCallback\n            )\n        )\n    }\n\n    fun refresh() = refresh(true)\n\n    private fun refresh(fromUser: Boolean) {\n        viewModelScope.launch {\n            observeTraktAuthState.observe()\n                .first { it == TraktAuthState.LOGGED_IN }\n                .also { refreshWatched(fromUser) }\n        }\n    }\n\n    fun onLoginClicked() {\n        appNavigator.startLogin()\n    }\n\n    fun setFilter(filter: String) {\n        setState { copy(filter = filter, filterActive = filter.isNotEmpty()) }\n    }\n\n    fun setSort(sort: SortOption) {\n        setState { copy(sort = sort) }\n    }\n\n    fun clearSelection() {\n        showSelection.clearSelection()\n    }\n\n    fun onItemClick(show: TiviShow): Boolean {\n        return showSelection.onItemClick(show)\n    }\n\n    fun onItemLongClick(show: TiviShow): Boolean {\n        return showSelection.onItemLongClick(show)\n    }\n\n    fun followSelectedShows() {\n        changeShowFollowStatus(\n            ChangeShowFollowStatus.Params(\n                showSelection.getSelectedShowIds(),\n                ChangeShowFollowStatus.Action.FOLLOW,\n                deferDataFetch = true)\n        )\n        showSelection.clearSelection()\n    }\n\n    fun unfollowSelectedShows() {\n        changeShowFollowStatus(\n            ChangeShowFollowStatus.Params(\n                showSelection.getSelectedShowIds(),\n                ChangeShowFollowStatus.Action.UNFOLLOW)\n        )\n        showSelection.clearSelection()\n    }\n\n    private fun refreshWatched(fromUser: Boolean) {\n        updateWatchedShows(UpdateWatchedShows.Params(fromUser)).also {\n            viewModelScope.launch {\n                loadingState.collectFrom(it)\n            }\n        }\n    }\n\n    @AssistedInject.Factory\n    interface Factory {\n        fun create(initialState: WatchedViewState): WatchedViewModel\n    }\n\n    companion object : MvRxViewModelFactory<WatchedViewModel, WatchedViewState> {\n        private val PAGING_CONFIG = PagedList.Config.Builder()\n            .setPageSize(60)\n            .setPrefetchDistance(20)\n            .setEnablePlaceholders(false)\n            .build()\n\n        override fun create(\n            viewModelContext: ViewModelContext,\n            state: WatchedViewState\n        ): WatchedViewModel? {\n            val fragment: WatchedFragment = (viewModelContext as FragmentViewModelContext).fragment()\n            return fragment.watchedViewModelFactory.create(state)\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.trakt\n\nenum class TraktAuthState {\n    LOGGED_IN, LOGGED_OUT\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.trakt\n\nimport com.uwetrottmann.trakt5.TraktV2\nimport dagger.Module\nimport dagger.Provides\nimport java.io.File\nimport java.util.concurrent.TimeUnit\nimport javax.inject.Named\nimport javax.inject.Singleton\nimport okhttp3.Cache\nimport okhttp3.OkHttpClient\nimport okhttp3.logging.HttpLoggingInterceptor\n\n@Module(includes = [TraktServiceModule::class])\nclass TraktModule {\n    @Provides\n    @Singleton\n    fun provideTrakt(\n        @Named(\"cache\") cacheDir: File,\n        interceptor: HttpLoggingInterceptor,\n        @Named(\"trakt-client-id\") clientId: String\n    ): TraktV2 {\n        return object : TraktV2(clientId) {\n            override fun setOkHttpClientDefaults(builder: OkHttpClient.Builder) {\n                super.setOkHttpClientDefaults(builder)\n                builder.apply {\n                    addInterceptor(interceptor)\n                    cache(Cache(File(cacheDir, \"trakt_cache\"), 10 * 1024 * 1024))\n                    connectTimeout(20, TimeUnit.SECONDS)\n                    readTimeout(20, TimeUnit.SECONDS)\n                    writeTimeout(20, TimeUnit.SECONDS)\n                }\n            }\n        }\n    }\n}\n\n@Module\nclass TraktServiceModule {\n    @Provides\n    fun provideTraktUsersService(traktV2: TraktV2) = traktV2.users()\n\n    @Provides\n    fun provideTraktShowsService(traktV2: TraktV2) = traktV2.shows()\n\n    @Provides\n    fun provideTraktEpisodesService(traktV2: TraktV2) = traktV2.episodes()\n\n    @Provides\n    fun provideTraktSeasonsService(traktV2: TraktV2) = traktV2.seasons()\n\n    @Provides\n    fun provideTraktSyncService(traktV2: TraktV2) = traktV2.sync()\n\n    @Provides\n    fun provideTraktSearchService(traktV2: TraktV2) = traktV2.search()\n\n    @Provides\n    fun provideTraktRecommendationsService(traktV2: TraktV2) = traktV2.recommendations()\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.episodedetails\n\nimport android.content.Context\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport app.tivi.inject.PerActivity\nimport javax.inject.Inject\n\ninternal class EpisodeDetailsTextCreator @Inject constructor(\n    @PerActivity private val context: Context\n) {\n    fun seasonEpisodeTitleText(season: Season?, episode: Episode?): String? {\n        return if (season != null && episode != null) {\n            context.getString(R.string.season_episode_number, season.number, episode.number)\n        } else {\n            null\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.episodedetails\n\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\nabstract class EpisodeDetailsFragmentBuilder {\n    @ContributesAndroidInjector(modules = [\n        EpisodeDetailsPresenterAssistedModule::class\n    ])\n    abstract fun episodeDetailsFragment(): EpisodeDetailsFragment\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.episodedetails\n\nimport android.content.Context\nimport app.tivi.common.layouts.header\nimport app.tivi.common.layouts.vertSpacerMicro\nimport app.tivi.inject.PerActivity\nimport app.tivi.util.TiviDateFormatter\nimport com.airbnb.epoxy.EpoxyModel\nimport com.airbnb.epoxy.EpoxyModelGroup\nimport com.airbnb.epoxy.TypedEpoxyController\nimport javax.inject.Inject\nimport kotlin.math.roundToInt\n\ninternal class EpisodeDetailsEpoxyController @Inject constructor(\n    @PerActivity private val context: Context,\n    private val dateFormatter: TiviDateFormatter\n) : TypedEpoxyController<EpisodeDetailsViewState>() {\n\n    override fun buildModels(viewState: EpisodeDetailsViewState) {\n        if (viewState.episode != null) {\n            val episode = viewState.episode\n\n            val badges = ArrayList<EpoxyModel<*>>()\n            episode?.traktRating?.also { rating ->\n                badges += EpisodeDetailsBadgeBindingModel_().apply {\n                    val ratingOutOfOneHundred = (rating * 10).roundToInt()\n                    id(\"rating\")\n                    label(context.getString(R.string.percentage_format, ratingOutOfOneHundred))\n                    icon(R.drawable.ic_details_rating)\n                    contentDescription(context.getString(\n                        R.string.rating_content_description_format, ratingOutOfOneHundred))\n                }\n            }\n            episode?.firstAired?.also { firstAired ->\n                badges += EpisodeDetailsBadgeBindingModel_().apply {\n                    id(\"aired\")\n                    label(dateFormatter.formatShortRelativeTime(firstAired))\n                    icon(R.drawable.ic_details_date)\n                }\n            }\n            if (badges.isNotEmpty()) {\n                EpoxyModelGroup(R.layout.layout_badge_holder, badges).addTo(this)\n            }\n\n            episodeDetailsSummary {\n                id(\"episode_summary\")\n                episode(episode)\n            }\n        }\n\n        val watches = viewState.watches\n        if (watches.isNotEmpty()) {\n            vertSpacerMicro {\n                id(\"watches_spacer\")\n            }\n            header {\n                id(\"watches_header\")\n                title(R.string.episode_watches)\n            }\n            watches.forEach { entry ->\n                episodeDetailsWatchItem {\n                    id(\"watch_${entry.id}\")\n                    dateTimeFormatter(dateFormatter)\n                    watch(entry)\n                }\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.episodedetails\n\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.core.os.bundleOf\nimport app.tivi.TiviFragmentWithBinding\nimport app.tivi.common.epoxy.SwipeAwayCallbacks\nimport app.tivi.episodedetails.databinding.FragmentEpisodeDetailsBinding\nimport app.tivi.extensions.resolveThemeColor\nimport com.airbnb.epoxy.EpoxyTouchHelper\nimport com.airbnb.mvrx.fragmentViewModel\nimport com.airbnb.mvrx.withState\nimport javax.inject.Inject\n\nclass EpisodeDetailsFragment : TiviFragmentWithBinding<FragmentEpisodeDetailsBinding>(),\n    EpisodeDetailsViewModel.FactoryProvider {\n    companion object {\n        @JvmStatic\n        fun create(id: Long): EpisodeDetailsFragment {\n            return EpisodeDetailsFragment().apply {\n                arguments = bundleOf(\"episode_id\" to id)\n            }\n        }\n    }\n\n    private val viewModel: EpisodeDetailsViewModel by fragmentViewModel()\n\n    @Inject internal lateinit var episodeDetailsViewModelFactory: EpisodeDetailsViewModel.Factory\n    @Inject internal lateinit var controller: EpisodeDetailsEpoxyController\n    @Inject internal lateinit var textCreator: EpisodeDetailsTextCreator\n\n    override fun createBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): FragmentEpisodeDetailsBinding {\n        return FragmentEpisodeDetailsBinding.inflate(layoutInflater, container, false)\n    }\n\n    override fun onViewCreated(\n        binding: FragmentEpisodeDetailsBinding,\n        savedInstanceState: Bundle?\n    ) {\n        binding.epDetailsRv.setController(controller)\n\n        binding.epDetailsFab.setOnClickListener {\n            withState(viewModel) { state ->\n                when (state.action) {\n                    Action.WATCH -> viewModel.submitAction(AddEpisodeWatchAction)\n                    Action.UNWATCH -> viewModel.submitAction(RemoveAllEpisodeWatchesAction)\n                }\n            }\n        }\n\n        val context = requireContext()\n        val swipeCallback = object : SwipeAwayCallbacks<EpisodeDetailsWatchItemBindingModel_>(\n            context.getDrawable(R.drawable.ic_eye_off_24dp)!!,\n            context.resources.getDimensionPixelSize(R.dimen.spacing_large),\n            context.getColor(R.color.swipe_away_background),\n            context.resolveThemeColor(R.attr.colorSecondary)\n        ) {\n            override fun onSwipeCompleted(\n                model: EpisodeDetailsWatchItemBindingModel_,\n                itemView: View,\n                position: Int,\n                direction: Int\n            ) = viewModel.submitAction(RemoveEpisodeWatchAction(model.watch().id))\n\n            override fun isSwipeEnabledForModel(model: EpisodeDetailsWatchItemBindingModel_): Boolean {\n                return model.watch() != null\n            }\n        }\n\n        EpoxyTouchHelper.initSwiping(binding.epDetailsRv)\n            .let {\n                if (binding.epDetailsRv.layoutDirection == View.LAYOUT_DIRECTION_RTL) {\n                    it.right()\n                } else {\n                    it.left()\n                }\n            }\n            .withTarget(EpisodeDetailsWatchItemBindingModel_::class.java)\n            .andCallbacks(swipeCallback)\n    }\n\n    override fun invalidate(binding: FragmentEpisodeDetailsBinding) = withState(viewModel) { state ->\n        binding.state = state\n        controller.setData(state)\n    }\n\n    override fun provideFactory(): EpisodeDetailsViewModel.Factory = episodeDetailsViewModelFactory\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.episodedetails\n\nimport android.os.Parcelable\nimport kotlinx.android.parcel.Parcelize\n\n@Parcelize\ndata class EpisodeDetailsArguments(val episodeId: Long) : Parcelable",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.episodedetails\n\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.entities.Season\nimport com.airbnb.mvrx.MvRxState\n\ndata class EpisodeDetailsViewState(\n    val episodeId: Long,\n    val season: Season? = null,\n    val episode: Episode? = null,\n    val watches: List<EpisodeWatchEntry> = emptyList(),\n    val action: Action = Action.WATCH\n) : MvRxState",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.episodedetails\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\n\n@Module(includes = [AssistedInject_EpisodeDetailsPresenterAssistedModule::class])\n@AssistedModule\ninterface EpisodeDetailsPresenterAssistedModule",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.episodedetails\n\nsealed class EpisodeDetailsAction\nobject RefreshAction : EpisodeDetailsAction()\nobject AddEpisodeWatchAction : EpisodeDetailsAction()\ndata class RemoveEpisodeWatchAction(val watchId: Long) : EpisodeDetailsAction()\nobject RemoveAllEpisodeWatchesAction : EpisodeDetailsAction()",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.episodedetails\n\nenum class Action {\n    WATCH,\n    UNWATCH\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.episodedetails\n\nimport androidx.fragment.app.Fragment\nimport androidx.lifecycle.viewModelScope\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.resultentities.EpisodeWithSeason\nimport app.tivi.domain.interactors.AddEpisodeWatch\nimport app.tivi.domain.interactors.RemoveEpisodeWatch\nimport app.tivi.domain.interactors.RemoveEpisodeWatches\nimport app.tivi.domain.interactors.UpdateEpisodeDetails\nimport app.tivi.domain.launchObserve\nimport app.tivi.domain.observers.ObserveEpisodeDetails\nimport app.tivi.domain.observers.ObserveEpisodeWatches\nimport app.tivi.episodedetails.presenter.BuildConfig\nimport com.airbnb.mvrx.BaseMvRxViewModel\nimport com.airbnb.mvrx.FragmentViewModelContext\nimport com.airbnb.mvrx.MvRxViewModelFactory\nimport com.airbnb.mvrx.ViewModelContext\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\nimport kotlinx.coroutines.channels.Channel\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.onStart\nimport kotlinx.coroutines.launch\nimport org.threeten.bp.OffsetDateTime\n\nclass EpisodeDetailsViewModel @AssistedInject constructor(\n    @Assisted initialState: EpisodeDetailsViewState,\n    private val updateEpisodeDetails: UpdateEpisodeDetails,\n    observeEpisodeDetails: ObserveEpisodeDetails,\n    private val observeEpisodeWatches: ObserveEpisodeWatches,\n    private val addEpisodeWatch: AddEpisodeWatch,\n    private val removeEpisodeWatches: RemoveEpisodeWatches,\n    private val removeEpisodeWatch: RemoveEpisodeWatch\n) : BaseMvRxViewModel<EpisodeDetailsViewState>(initialState, debugMode = BuildConfig.DEBUG) {\n\n    private val pendingActions = Channel<EpisodeDetailsAction>(Channel.BUFFERED)\n\n    init {\n        viewModelScope.launchObserve(observeEpisodeDetails) {\n            it.collect { result -> updateFromEpisodeDetails(result) }\n        }\n\n        viewModelScope.launchObserve(observeEpisodeWatches) {\n            it.onStart {\n                emit(emptyList())\n            }.collect { result -> updateFromEpisodeWatches(result) }\n        }\n\n        viewModelScope.launch {\n            for (action in pendingActions) when (action) {\n                RefreshAction -> refresh()\n                AddEpisodeWatchAction -> markWatched()\n                RemoveAllEpisodeWatchesAction -> markUnwatched()\n                is RemoveEpisodeWatchAction -> removeWatchEntry(action)\n            }\n        }\n\n        withState {\n            observeEpisodeDetails(ObserveEpisodeDetails.Params(it.episodeId))\n            observeEpisodeWatches(ObserveEpisodeWatches.Params(it.episodeId))\n        }\n\n        refresh()\n    }\n\n    private fun updateFromEpisodeDetails(episodeWithSeason: EpisodeWithSeason) = setState {\n        copy(episode = episodeWithSeason.episode, season = episodeWithSeason.season)\n    }\n\n    private fun updateFromEpisodeWatches(watches: List<EpisodeWatchEntry>) = setState {\n        val action = if (watches.isNotEmpty()) Action.UNWATCH else Action.WATCH\n        copy(watches = watches, action = action)\n    }\n\n    fun submitAction(action: EpisodeDetailsAction) {\n        viewModelScope.launch { pendingActions.send(action) }\n    }\n\n    private fun refresh() = withState {\n        updateEpisodeDetails(UpdateEpisodeDetails.Params(it.episodeId, true))\n    }\n\n    private fun removeWatchEntry(action: RemoveEpisodeWatchAction) {\n        removeEpisodeWatch(RemoveEpisodeWatch.Params(action.watchId))\n    }\n\n    private fun markWatched() = withState {\n        addEpisodeWatch(AddEpisodeWatch.Params(it.episodeId, OffsetDateTime.now()))\n    }\n\n    private fun markUnwatched() = withState {\n        removeEpisodeWatches(RemoveEpisodeWatches.Params(it.episodeId))\n    }\n\n    @AssistedInject.Factory\n    interface Factory {\n        fun create(initialState: EpisodeDetailsViewState): EpisodeDetailsViewModel\n    }\n\n    interface FactoryProvider {\n        fun provideFactory(): Factory\n    }\n\n    companion object : MvRxViewModelFactory<EpisodeDetailsViewModel, EpisodeDetailsViewState> {\n        override fun create(\n            viewModelContext: ViewModelContext,\n            state: EpisodeDetailsViewState\n        ): EpisodeDetailsViewModel? {\n            val fvmc = viewModelContext as FragmentViewModelContext\n            val f: FactoryProvider = (fvmc.fragment<Fragment>()) as FactoryProvider\n            return f.provideFactory().create(state)\n        }\n\n        override fun initialState(\n            viewModelContext: ViewModelContext\n        ): EpisodeDetailsViewState? {\n            val f: Fragment = (viewModelContext as FragmentViewModelContext).fragment()\n            val args = f.requireArguments()\n            return EpisodeDetailsViewState(episodeId = args.getLong(\"episode_id\"))\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.popular\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\nabstract class PopularBuilder {\n    @ContributesAndroidInjector(modules = [\n        PopularAssistedModule::class\n    ])\n    internal abstract fun popularShowsFragment(): PopularShowsFragment\n}\n\n@Module(includes = [AssistedInject_PopularAssistedModule::class])\n@AssistedModule\ninterface PopularAssistedModule",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.popular\n\nimport app.tivi.base.InvokeStatus\nimport app.tivi.data.resultentities.PopularEntryWithShow\nimport app.tivi.domain.interactors.ChangeShowFollowStatus\nimport app.tivi.domain.interactors.UpdatePopularShows\nimport app.tivi.domain.observers.ObservePagedPopularShows\nimport app.tivi.util.AppCoroutineDispatchers\nimport app.tivi.util.EntryViewModel\nimport app.tivi.util.EntryViewState\nimport app.tivi.util.Logger\nimport com.airbnb.mvrx.FragmentViewModelContext\nimport com.airbnb.mvrx.MvRxViewModelFactory\nimport com.airbnb.mvrx.ViewModelContext\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\nimport kotlinx.coroutines.flow.Flow\n\nclass PopularShowsViewModel @AssistedInject constructor(\n    @Assisted initialState: EntryViewState,\n    override val dispatchers: AppCoroutineDispatchers,\n    override val pagingInteractor: ObservePagedPopularShows,\n    private val interactor: UpdatePopularShows,\n    override val logger: Logger,\n    override val changeShowFollowStatus: ChangeShowFollowStatus\n) : EntryViewModel<PopularEntryWithShow, ObservePagedPopularShows>(initialState) {\n    init {\n        pagingInteractor(ObservePagedPopularShows.Params(pageListConfig, boundaryCallback))\n\n        launchObserves()\n\n        refresh(false)\n    }\n\n    override fun callLoadMore(): Flow<InvokeStatus> {\n        return interactor(UpdatePopularShows.Params(UpdatePopularShows.Page.NEXT_PAGE, true))\n    }\n\n    override fun callRefresh(fromUser: Boolean): Flow<InvokeStatus> {\n        return interactor(UpdatePopularShows.Params(UpdatePopularShows.Page.REFRESH, fromUser))\n    }\n\n    @AssistedInject.Factory\n    interface Factory {\n        fun create(initialState: EntryViewState): PopularShowsViewModel\n    }\n\n    companion object : MvRxViewModelFactory<PopularShowsViewModel, EntryViewState> {\n        override fun create(\n            viewModelContext: ViewModelContext,\n            state: EntryViewState\n        ): PopularShowsViewModel? {\n            val fragment: PopularShowsFragment = (viewModelContext as FragmentViewModelContext).fragment()\n            return fragment.popularShowsViewModelFactory.create(state)\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.popular\n\nimport android.os.Bundle\nimport android.view.ActionMode\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.View\nimport androidx.core.net.toUri\nimport androidx.navigation.fragment.findNavController\nimport app.tivi.SharedElementHelper\nimport app.tivi.common.entrygrid.databinding.FragmentEntryGridBinding\nimport app.tivi.common.layouts.PosterGridItemBindingModel_\nimport app.tivi.data.entities.findHighestRatedPoster\nimport app.tivi.data.resultentities.PopularEntryWithShow\nimport app.tivi.extensions.toActivityNavigatorExtras\nimport app.tivi.util.EntryGridEpoxyController\nimport app.tivi.util.EntryGridFragment\nimport com.airbnb.epoxy.EpoxyModel\nimport com.airbnb.mvrx.fragmentViewModel\nimport javax.inject.Inject\n\nclass PopularShowsFragment : EntryGridFragment<PopularEntryWithShow, PopularShowsViewModel>() {\n    override val viewModel: PopularShowsViewModel by fragmentViewModel()\n    @Inject lateinit var popularShowsViewModelFactory: PopularShowsViewModel.Factory\n\n    override fun onViewCreated(binding: FragmentEntryGridBinding, savedInstanceState: Bundle?) {\n        super.onViewCreated(binding, savedInstanceState)\n\n        binding.gridToolbar.apply {\n            setTitle(R.string.discover_popular_title)\n        }\n    }\n\n    internal fun onItemClicked(item: PopularEntryWithShow) {\n        val sharedElements = SharedElementHelper()\n        requireBinding().gridRecyclerview.findViewHolderForItemId(item.generateStableId()).let {\n            sharedElements.addSharedElement(it.itemView, \"poster\")\n        }\n\n        findNavController().navigate(\n            \"app.tivi://show/${item.show.id}\".toUri(),\n            null,\n            sharedElements.toActivityNavigatorExtras(requireActivity())\n        )\n    }\n\n    override fun createController(): EntryGridEpoxyController<PopularEntryWithShow> {\n        return object : EntryGridEpoxyController<PopularEntryWithShow>() {\n            override fun buildItemModel(item: PopularEntryWithShow): EpoxyModel<*> {\n                return PosterGridItemBindingModel_()\n                    .id(item.generateStableId())\n                    .posterImage(item.images.findHighestRatedPoster())\n                    .tiviShow(item.show)\n                    .transitionName(item.show.homepage)\n                    .selected(item.show.id in state.selectedShowIds)\n                    .clickListener(View.OnClickListener {\n                        if (viewModel.onItemClick(item.show)) {\n                            return@OnClickListener\n                        }\n                        onItemClicked(item)\n                    })\n                    .longClickListener(View.OnLongClickListener {\n                        viewModel.onItemLongClick(item.show)\n                    })\n            }\n        }\n    }\n\n    override fun startSelectionActionMode(): ActionMode? {\n        return requireActivity().startActionMode(object : ActionMode.Callback {\n            override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {\n                when (item.itemId) {\n                    R.id.menu_follow -> viewModel.followSelectedShows()\n                }\n                return true\n            }\n\n            override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {\n                mode.menuInflater.inflate(R.menu.action_mode_entry, menu)\n                return true\n            }\n\n            override fun onPrepareActionMode(mode: ActionMode, menu: Menu) = true\n\n            override fun onDestroyActionMode(mode: ActionMode) {\n                viewModel.clearSelection()\n            }\n        })\n    }\n}",
        "/*\n * Copyright $YEAR Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tmdb\n\nobject TmdbImageSizes {\n\n    const val baseImageUrl = \"https://image.tmdb.org/t/p/\"\n\n    val posterSizes = listOf(\n        \"w92\",\n        \"w154\",\n        \"w185\",\n        \"w342\",\n        \"w500\",\n        \"w780\",\n        \"original\"\n    )\n\n    val backdropSizes = listOf(\n        \"w300\",\n        \"w780\",\n        \"w1280\",\n        \"original\"\n    )\n\n    val logoSizes = listOf(\n        \"w45\",\n        \"w92\",\n        \"w154\",\n        \"w185\",\n        \"w300\",\n        \"w500\",\n        \"original\"\n    )\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tmdb\n\nprivate val IMAGE_SIZE_PATTERN = \"w(\\\\d+)$\".toRegex()\n\ndata class TmdbImageUrlProvider(\n    private val baseImageUrl: String = TmdbImageSizes.baseImageUrl,\n    private val posterSizes: List<String> = TmdbImageSizes.posterSizes,\n    private val backdropSizes: List<String> = TmdbImageSizes.backdropSizes,\n    private val logoSizes: List<String> = TmdbImageSizes.logoSizes\n) {\n    fun getPosterUrl(path: String, imageWidth: Int): String {\n        return \"$baseImageUrl${selectSize(posterSizes, imageWidth)}$path\"\n    }\n\n    fun getBackdropUrl(path: String, imageWidth: Int): String {\n        return \"$baseImageUrl${selectSize(backdropSizes, imageWidth)}$path\"\n    }\n\n    fun getLogoUrl(path: String, imageWidth: Int): String {\n        return \"$baseImageUrl${selectSize(logoSizes, imageWidth)}$path\"\n    }\n\n    private fun selectSize(sizes: List<String>, imageWidth: Int): String {\n        var previousSize: String? = null\n        var previousWidth = 0\n\n        for (i in sizes.indices) {\n            val size = sizes[i]\n            val sizeWidth = extractWidthAsIntFrom(size) ?: continue\n\n            if (sizeWidth > imageWidth) {\n                if (previousSize != null && imageWidth > (previousWidth + sizeWidth) / 2) {\n                    return size\n                } else if (previousSize != null) {\n                    return previousSize\n                }\n            } else if (i == sizes.size - 1) {\n                // If we get here then we're larger than the last bucket\n                if (imageWidth < sizeWidth * 2) {\n                    return size\n                }\n            }\n\n            previousSize = size\n            previousWidth = sizeWidth\n        }\n\n        return previousSize ?: sizes.last()\n    }\n\n    private fun extractWidthAsIntFrom(size: String): Int? {\n        return IMAGE_SIZE_PATTERN.matchEntire(size)?.groups?.get(1)?.value?.toInt()\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tmdb\n\nimport com.uwetrottmann.tmdb2.Tmdb\nimport dagger.Module\nimport dagger.Provides\nimport java.io.File\nimport java.util.concurrent.TimeUnit\nimport javax.inject.Named\nimport javax.inject.Singleton\nimport okhttp3.Cache\nimport okhttp3.OkHttpClient\nimport okhttp3.logging.HttpLoggingInterceptor\n\n@Module\nclass TmdbModule {\n    @Provides\n    fun provideTmdbImageUrlProvider(tmdbManager: TmdbManager): TmdbImageUrlProvider {\n        return tmdbManager.getLatestImageProvider()\n    }\n\n    @Singleton\n    @Provides\n    fun provideTmdb(\n        @Named(\"cache\") cacheDir: File,\n        interceptor: HttpLoggingInterceptor,\n        @Named(\"tmdb-api\") apiKey: String\n    ): Tmdb {\n        return object : Tmdb(apiKey) {\n            override fun setOkHttpClientDefaults(builder: OkHttpClient.Builder) {\n                super.setOkHttpClientDefaults(builder)\n                builder.apply {\n                    addInterceptor(interceptor)\n                    cache(Cache(File(cacheDir, \"tmdb_cache\"), 10 * 1024 * 1024))\n                    connectTimeout(20, TimeUnit.SECONDS)\n                    readTimeout(20, TimeUnit.SECONDS)\n                    writeTimeout(20, TimeUnit.SECONDS)\n                }\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.tmdb\n\nimport app.tivi.extensions.fetchBodyWithRetry\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport com.uwetrottmann.tmdb2.Tmdb\nimport com.uwetrottmann.tmdb2.entities.Configuration\nimport javax.inject.Inject\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.channels.ConflatedBroadcastChannel\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.asFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\n\n@Singleton\nclass TmdbManager @Inject constructor(\n    private val dispatchers: AppCoroutineDispatchers,\n    private val tmdbClient: Tmdb,\n    @ProcessLifetime val processScope: CoroutineScope\n) {\n    private val imageProviderSubject = ConflatedBroadcastChannel(TmdbImageUrlProvider())\n    val imageProviderFlow: Flow<TmdbImageUrlProvider> = imageProviderSubject.asFlow()\n\n    fun getLatestImageProvider() = imageProviderSubject.value\n\n    fun refreshConfiguration() {\n        processScope.launch {\n            try {\n                val config = withContext(dispatchers.io) {\n                    tmdbClient.configurationService().configuration().fetchBodyWithRetry()\n                }\n                onConfigurationLoaded(config)\n            } catch (e: Exception) {\n                // TODO\n            }\n        }\n    }\n\n    private fun onConfigurationLoaded(configuration: Configuration) {\n        configuration.images?.let { images ->\n            processScope.launch {\n                val newProvider = TmdbImageUrlProvider(\n                    images.secure_base_url!!,\n                    images.poster_sizes ?: emptyList(),\n                    images.backdrop_sizes ?: emptyList(),\n                    images.logo_sizes ?: emptyList()\n                )\n                imageProviderSubject.send(newProvider)\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.trakt\n\nimport android.content.SharedPreferences\nimport androidx.core.content.edit\nimport app.tivi.AppNavigator\nimport app.tivi.actions.ShowTasks\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport app.tivi.util.Logger\nimport com.uwetrottmann.trakt5.TraktV2\nimport dagger.Lazy\nimport javax.inject.Inject\nimport javax.inject.Named\nimport javax.inject.Provider\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.channels.ConflatedBroadcastChannel\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.asFlow\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport net.openid.appauth.AuthState\nimport net.openid.appauth.AuthorizationException\nimport net.openid.appauth.AuthorizationRequest\nimport net.openid.appauth.AuthorizationResponse\nimport net.openid.appauth.AuthorizationService\nimport net.openid.appauth.ClientAuthentication\nimport net.openid.appauth.TokenResponse\n\n@Singleton\nclass TraktManager @Inject constructor(\n    private val dispatchers: AppCoroutineDispatchers,\n    @Named(\"app\") private val appNavigator: AppNavigator,\n    private val requestProvider: Provider<AuthorizationRequest>,\n    private val clientAuth: Lazy<ClientAuthentication>,\n    @Named(\"auth\") private val authPrefs: SharedPreferences,\n    private val showTasks: ShowTasks,\n    private val logger: Logger,\n    private val traktClient: Lazy<TraktV2>,\n    @ProcessLifetime val processScope: CoroutineScope\n) {\n    private val authState = ConflatedBroadcastChannel<AuthState>()\n\n    private val _state = ConflatedBroadcastChannel(TraktAuthState.LOGGED_OUT)\n    val state: Flow<TraktAuthState>\n        get() = _state.asFlow()\n\n    init {\n        // Observer which updates local state\n        processScope.launch {\n            authState.asFlow().collect { authState ->\n                updateAuthState(authState)\n\n                traktClient.get().apply {\n                    accessToken(authState.accessToken)\n                    refreshToken(authState.refreshToken)\n                }\n            }\n        }\n\n        // Read the auth state from prefs\n        processScope.launch {\n            val state = withContext(dispatchers.io) {\n                readAuthState()\n            }\n            authState.send(state)\n        }\n    }\n\n    private suspend fun updateAuthState(authState: AuthState) {\n        if (authState.isAuthorized) {\n            _state.send(TraktAuthState.LOGGED_IN)\n        } else {\n            _state.send(TraktAuthState.LOGGED_OUT)\n        }\n    }\n\n    fun startAuth(requestCode: Int, authService: AuthorizationService) {\n        authService.performAuthorizationRequest(\n            requestProvider.get(),\n            appNavigator.provideAuthHandleResponseIntent(requestCode)\n        )\n    }\n\n    fun onAuthResponse(authService: AuthorizationService, response: AuthorizationResponse) {\n        authService.performTokenRequest(\n            response.createTokenExchangeRequest(),\n            clientAuth.get(),\n            ::onTokenExchangeResponse\n        )\n    }\n\n    fun onAuthException(exception: AuthorizationException) {\n        logger.d(exception, \"AuthException\")\n    }\n\n    private fun onTokenExchangeResponse(response: TokenResponse?, ex: AuthorizationException?) {\n        val newState = AuthState().apply { update(response, ex) }\n        processScope.launch(dispatchers.main) {\n            // Update our local state\n            authState.send(newState)\n        }\n        processScope.launch(dispatchers.io) {\n            // Persist auth state\n            persistAuthState(newState)\n        }\n        // Now trigger a sync of all shows\n        showTasks.syncFollowedShowsWhenIdle()\n    }\n\n    private fun readAuthState(): AuthState {\n        val stateJson = authPrefs.getString(\"stateJson\", null)\n        return when {\n            stateJson != null -> AuthState.jsonDeserialize(stateJson)\n            else -> AuthState()\n        }\n    }\n\n    private fun persistAuthState(state: AuthState) {\n        authPrefs.edit {\n            putString(\"stateJson\", state.jsonSerializeString())\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.trakt\n\nimport android.content.Context\nimport android.content.SharedPreferences\nimport android.net.Uri\nimport app.tivi.inject.ApplicationId\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Named\nimport javax.inject.Singleton\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.runBlocking\nimport net.openid.appauth.AuthorizationRequest\nimport net.openid.appauth.AuthorizationServiceConfiguration\nimport net.openid.appauth.ClientAuthentication\nimport net.openid.appauth.ClientSecretBasic\nimport net.openid.appauth.ResponseTypeValues\n\n@Module\nclass TraktAuthModule {\n    @Singleton\n    @Provides\n    fun provideAuthConfig(): AuthorizationServiceConfiguration {\n        return AuthorizationServiceConfiguration(\n            Uri.parse(\"https://trakt.tv/oauth/authorize\"),\n            Uri.parse(\"https://trakt.tv/oauth/token\"),\n            null)\n    }\n\n    @Provides\n    fun provideAuthState(traktManager: TraktManager) = runBlocking {\n        traktManager.state.first()\n    }\n\n    @Provides\n    fun provideAuthRequest(\n        serviceConfig: AuthorizationServiceConfiguration,\n        @Named(\"trakt-client-id\") clientId: String,\n        @ApplicationId applicationId: String\n    ): AuthorizationRequest {\n        return AuthorizationRequest.Builder(\n            serviceConfig,\n            clientId,\n            ResponseTypeValues.CODE,\n            Uri.parse(\"$applicationId://${TraktConstants.URI_AUTH_CALLBACK_PATH}\")\n        ).build()\n    }\n\n    @Singleton\n    @Provides\n    fun provideClientAuth(@Named(\"trakt-client-secret\") clientSecret: String): ClientAuthentication {\n        return ClientSecretBasic(clientSecret)\n    }\n\n    @Singleton\n    @Provides\n    @Named(\"auth\")\n    fun provideAuthSharedPrefs(context: Context): SharedPreferences {\n        return context.getSharedPreferences(\"trakt_auth\", Context.MODE_PRIVATE)\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.trakt\n\nobject TraktConstants {\n    const val INTENT_ACTION_HANDLE_AUTH_RESPONSE = \"app.tivi.HANDLE_AUTHORIZATION_RESPONSE\"\n    const val URI_AUTH_CALLBACK_PATH = \"auth/oauth2callback\"\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.search\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\nabstract class SearchBuilder {\n    @ContributesAndroidInjector(modules = [\n        SearchAssistedModule::class\n    ])\n    internal abstract fun searchFragment(): SearchFragment\n}\n\n@Module(includes = [AssistedInject_SearchAssistedModule::class])\n@AssistedModule\ninterface SearchAssistedModule",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.search\n\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.extensions.observable\nimport app.tivi.home.HomeTextCreator\nimport com.airbnb.epoxy.EpoxyController\nimport dagger.Lazy\nimport javax.inject.Inject\n\ninternal class SearchEpoxyController @Inject constructor(\n    private val textCreator: Lazy<HomeTextCreator>\n) : EpoxyController() {\n    var callbacks: Callbacks? by observable(null, ::requestModelBuild)\n    var state by observable(SearchViewState(), ::requestModelBuild)\n\n    interface Callbacks {\n        fun onSearchItemClicked(show: TiviShow)\n    }\n\n    override fun buildModels() {\n        val searchResult = state.searchResults\n\n        searchResult?.results?.forEach { showDetailed ->\n            searchItemShow {\n                id(showDetailed.show.id)\n                tiviShow(showDetailed.show)\n                posterImage(showDetailed.poster)\n                textCreator(textCreator.get())\n                clickListener { _ -> callbacks?.onSearchItemClicked(showDetailed.show) }\n            }\n        }\n    }\n\n    fun clear() {\n        callbacks = null\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.search\n\nimport androidx.lifecycle.viewModelScope\nimport app.tivi.TiviMvRxViewModel\nimport app.tivi.domain.interactors.SearchShows\nimport app.tivi.domain.launchObserve\nimport app.tivi.util.ObservableLoadingCounter\nimport com.airbnb.mvrx.FragmentViewModelContext\nimport com.airbnb.mvrx.MvRxViewModelFactory\nimport com.airbnb.mvrx.ViewModelContext\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\nimport kotlinx.coroutines.async\nimport kotlinx.coroutines.channels.ConflatedBroadcastChannel\nimport kotlinx.coroutines.channels.sendBlocking\nimport kotlinx.coroutines.flow.asFlow\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.collectLatest\nimport kotlinx.coroutines.flow.debounce\nimport kotlinx.coroutines.launch\n\ninternal class SearchViewModel @AssistedInject constructor(\n    @Assisted initialState: SearchViewState,\n    private val searchShows: SearchShows\n) : TiviMvRxViewModel<SearchViewState>(initialState) {\n    private val searchQuery = ConflatedBroadcastChannel<String>()\n    private val loadingState = ObservableLoadingCounter()\n\n    init {\n        viewModelScope.launch {\n            searchQuery.asFlow()\n                .debounce(300)\n                .collectLatest { query ->\n                    loadingState.addLoader()\n                    val job = async(searchShows.dispatcher) {\n                        searchShows(SearchShows.Params(query))\n                    }\n                    job.invokeOnCompletion { loadingState.removeLoader() }\n                    job.await()\n                }\n        }\n\n        viewModelScope.launch {\n            loadingState.observable.collect { setState { copy(refreshing = it) } }\n        }\n\n        viewModelScope.launchObserve(searchShows) {\n            it.execute { copy(searchResults = it()) }\n        }\n    }\n\n    fun setSearchQuery(query: String) {\n        searchQuery.sendBlocking(query)\n    }\n\n    fun clearQuery() = setSearchQuery(\"\")\n\n    @AssistedInject.Factory\n    interface Factory {\n        fun create(initialState: SearchViewState): SearchViewModel\n    }\n\n    companion object : MvRxViewModelFactory<SearchViewModel, SearchViewState> {\n        override fun create(\n            viewModelContext: ViewModelContext,\n            state: SearchViewState\n        ): SearchViewModel? {\n            val fragment: SearchFragment = (viewModelContext as FragmentViewModelContext).fragment()\n            return fragment.searchViewModelFactory.create(state)\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.search\n\nimport app.tivi.data.entities.SearchResults\nimport com.airbnb.mvrx.MvRxState\n\ndata class SearchViewState(\n    val searchResults: SearchResults? = null,\n    val refreshing: Boolean = false\n) : MvRxState",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.search\n\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.ViewGroup\nimport androidx.appcompat.widget.SearchView\nimport androidx.core.net.toUri\nimport androidx.core.view.marginBottom\nimport androidx.core.view.updatePadding\nimport androidx.navigation.fragment.findNavController\nimport app.tivi.TiviFragmentWithBinding\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.extensions.doOnLayouts\nimport app.tivi.extensions.hideSoftInput\nimport app.tivi.extensions.toActivityNavigatorExtras\nimport app.tivi.home.search.databinding.FragmentSearchBinding\nimport app.tivi.ui.createSharedElementHelperForItemId\nimport app.tivi.ui.recyclerview.HideImeOnScrollListener\nimport app.tivi.ui.transitions.GridToGridTransitioner\nimport com.airbnb.mvrx.fragmentViewModel\nimport com.airbnb.mvrx.withState\nimport javax.inject.Inject\n\ninternal class SearchFragment : TiviFragmentWithBinding<FragmentSearchBinding>() {\n    private val viewModel: SearchViewModel by fragmentViewModel()\n\n    @Inject internal lateinit var searchViewModelFactory: SearchViewModel.Factory\n    @Inject internal lateinit var controller: SearchEpoxyController\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        GridToGridTransitioner.setupFirstFragment(this)\n    }\n\n    override fun createBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): FragmentSearchBinding {\n        return FragmentSearchBinding.inflate(inflater, container, false)\n    }\n\n    override fun onViewCreated(binding: FragmentSearchBinding, savedInstanceState: Bundle?) {\n        binding.searchRecyclerview.apply {\n            setController(controller)\n            addOnScrollListener(HideImeOnScrollListener())\n        }\n\n        binding.searchAppbar.doOnLayouts { appBar ->\n            binding.searchRecyclerview.updatePadding(top = appBar.bottom + appBar.marginBottom)\n            true\n        }\n\n        binding.searchSearchview.apply {\n            setOnQueryTextListener(object : SearchView.OnQueryTextListener {\n                override fun onQueryTextSubmit(query: String): Boolean {\n                    viewModel.setSearchQuery(query)\n                    hideSoftInput()\n                    return true\n                }\n\n                override fun onQueryTextChange(newText: String): Boolean {\n                    viewModel.setSearchQuery(newText)\n                    return true\n                }\n            })\n        }\n\n        controller.callbacks = object : SearchEpoxyController.Callbacks {\n            override fun onSearchItemClicked(show: TiviShow) {\n                // We should really use AndroidX navigation here, but this fragment isn't in the tree\n                val extras = binding.searchRecyclerview.createSharedElementHelperForItemId(show.id, \"poster\") {\n                    it.findViewById(R.id.show_poster)\n                }\n                findNavController().navigate(\n                    \"app.tivi://show/${show.id}\".toUri(),\n                    null,\n                    extras.toActivityNavigatorExtras(requireActivity()))\n            }\n        }\n    }\n\n    override fun invalidate(binding: FragmentSearchBinding) = withState(viewModel) { state ->\n        binding.state = state\n        controller.state = state\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        controller.clear()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.buildsrc\n\nobject Versions {\n    const val ktlint = \"0.35.0\"\n}\n\nobject Libs {\n    const val androidGradlePlugin = \"com.android.tools.build:gradle:3.6.0-rc03\"\n    const val dexcountGradlePlugin = \"com.getkeepsafe.dexcount:dexcount-gradle-plugin:1.0.0\"\n    const val playPublisherPlugin = \"com.github.triplet.gradle:play-publisher:2.6.1\"\n\n    const val mvRx = \"com.airbnb.android:mvrx:1.3.0\"\n\n    const val threeTenBp = \"org.threeten:threetenbp:1.4.1\"\n    const val threeTenBpNoTzdb = \"$threeTenBp:no-tzdb\"\n    const val threeTenAbp = \"com.jakewharton.threetenabp:threetenabp:1.2.2\"\n\n    const val gravitySnapHelper = \"com.github.rubensousa:gravitysnaphelper:2.2.0\"\n\n    const val timber = \"com.jakewharton.timber:timber:4.7.1\"\n\n    const val tmdbJava = \"com.github.chrisbanes:tmdb-java:master-SNAPSHOT\"\n    const val traktJava = \"com.uwetrottmann.trakt5:trakt-java:6.4.0\"\n\n    const val appauth = \"net.openid:appauth:0.7.1\"\n\n    const val junit = \"junit:junit:4.13\"\n    const val robolectric = \"org.robolectric:robolectric:4.3.1\"\n    const val mockK = \"io.mockk:mockk:1.9.3\"\n\n    const val inboxRecyclerView = \"me.saket:inboxrecyclerview:2.0.0-beta3\"\n\n    const val leakCanary = \"com.squareup.leakcanary:leakcanary-android:2.1\"\n\n    const val flexbox = \"com.google.android:flexbox:2.0.1\"\n\n    const val store = \"com.dropbox.mobile.store:store4:4.0.0-alpha02\"\n\n    object Insetter {\n        private const val version = \"0.2.0\"\n        const val dbx = \"dev.chrisbanes:insetter-dbx:$version\"\n        const val ktx = \"dev.chrisbanes:insetter-ktx:$version\"\n    }\n\n    object Google {\n        const val material = \"com.google.android.material:material:1.1.0-rc02\"\n        const val firebaseCore = \"com.google.firebase:firebase-core:17.2.2\"\n        const val crashlytics = \"com.crashlytics.sdk.android:crashlytics:2.10.1\"\n        const val gmsGoogleServices = \"com.google.gms:google-services:4.3.3\"\n        const val fabricPlugin = \"io.fabric.tools:gradle:1.31.2\"\n\n        const val openSourceLicensesPlugin = \"com.google.android.gms:oss-licenses-plugin:0.10.1\"\n        const val openSourceLicensesLibrary = \"com.google.android.gms:play-services-oss-licenses:17.0.0\"\n    }\n\n    object Kotlin {\n        private const val version = \"1.3.61\"\n        const val stdlib = \"org.jetbrains.kotlin:kotlin-stdlib-jdk8:$version\"\n        const val reflect = \"org.jetbrains.kotlin:kotlin-reflect:$version\"\n        const val gradlePlugin = \"org.jetbrains.kotlin:kotlin-gradle-plugin:$version\"\n        const val extensions = \"org.jetbrains.kotlin:kotlin-android-extensions:$version\"\n    }\n\n    object Coroutines {\n        private const val version = \"1.3.2\"\n        const val core = \"org.jetbrains.kotlinx:kotlinx-coroutines-core:$version\"\n        const val rx2 = \"org.jetbrains.kotlinx:kotlinx-coroutines-rx2:$version\"\n        const val android = \"org.jetbrains.kotlinx:kotlinx-coroutines-android:$version\"\n        const val test = \"org.jetbrains.kotlinx:kotlinx-coroutines-test:$version\"\n    }\n\n    object AndroidX {\n        const val appcompat = \"androidx.appcompat:appcompat:1.1.0\"\n        const val browser = \"androidx.browser:browser:1.0.0\"\n        const val collection = \"androidx.collection:collection-ktx:1.1.0\"\n        const val palette = \"androidx.palette:palette:1.0.0\"\n        const val recyclerview = \"androidx.recyclerview:recyclerview:1.1.0\"\n        const val emoji = \"androidx.emoji:emoji:1.0.0\"\n        const val swiperefresh = \"androidx.swiperefreshlayout:swiperefreshlayout:1.1.0-alpha03\"\n\n        object Navigation {\n            private const val version = \"2.2.0-rc02\"\n            const val fragment = \"androidx.navigation:navigation-fragment-ktx:$version\"\n            const val ui = \"androidx.navigation:navigation-ui-ktx:$version\"\n            const val safeArgs = \"androidx.navigation:navigation-safe-args-gradle-plugin:$version\"\n        }\n\n        object Fragment {\n            private const val version = \"1.2.0-rc01\"\n            const val fragment = \"androidx.fragment:fragment:$version\"\n            const val fragmentKtx = \"androidx.fragment:fragment-ktx:$version\"\n        }\n\n        object Test {\n            private const val version = \"1.2.0\"\n            const val core = \"androidx.test:core:$version\"\n            const val runner = \"androidx.test:runner:$version\"\n            const val rules = \"androidx.test:rules:$version\"\n\n            const val espressoCore = \"androidx.test.espresso:espresso-core:3.2.0\"\n        }\n\n        const val archCoreTesting = \"androidx.arch.core:core-testing:2.1.0\"\n\n        object Paging {\n            private const val version = \"2.1.1\"\n            const val common = \"androidx.paging:paging-common-ktx:$version\"\n            const val runtime = \"androidx.paging:paging-runtime-ktx:$version\"\n        }\n\n        const val preference = \"androidx.preference:preference:1.1.0\"\n\n        const val constraintlayout = \"androidx.constraintlayout:constraintlayout:2.0.0-beta4\"\n\n        const val coreKtx = \"androidx.core:core-ktx:1.2.0-rc01\"\n\n        object Lifecycle {\n            private const val version = \"2.2.0\"\n            const val extensions = \"androidx.lifecycle:lifecycle-extensions:$version\"\n            const val viewmodelKtx = \"androidx.lifecycle:lifecycle-viewmodel-ktx:$version\"\n        }\n\n        object Room {\n            private const val version = \"2.2.3\"\n            const val common = \"androidx.room:room-common:$version\"\n            const val runtime = \"androidx.room:room-runtime:$version\"\n            const val compiler = \"androidx.room:room-compiler:$version\"\n            const val ktx = \"androidx.room:room-ktx:$version\"\n            const val testing = \"androidx.room:room-testing:$version\"\n        }\n\n        object Work {\n            private const val version = \"2.3.0\"\n            const val runtimeKtx = \"androidx.work:work-runtime-ktx:$version\"\n        }\n    }\n\n    object RxJava {\n        const val rxJava = \"io.reactivex.rxjava2:rxjava:2.2.11\"\n        const val rxAndroid = \"io.reactivex.rxjava2:rxandroid:2.1.1\"\n    }\n\n    object Dagger {\n        private const val version = \"2.25.4\"\n        const val dagger = \"com.google.dagger:dagger:$version\"\n        const val androidSupport = \"com.google.dagger:dagger-android-support:$version\"\n        const val compiler = \"com.google.dagger:dagger-compiler:$version\"\n        const val androidProcessor = \"com.google.dagger:dagger-android-processor:$version\"\n    }\n\n    object Retrofit {\n        private const val version = \"2.7.1\"\n        const val retrofit = \"com.squareup.retrofit2:retrofit:$version\"\n        const val retrofit_rxjava_adapter = \"com.squareup.retrofit2:adapter-rxjava2:$version\"\n        const val gsonConverter = \"com.squareup.retrofit2:converter-gson:$version\"\n    }\n\n    object OkHttp {\n        private const val version = \"4.3.1\"\n        const val okhttp = \"com.squareup.okhttp3:okhttp:$version\"\n        const val loggingInterceptor = \"com.squareup.okhttp3:logging-interceptor:$version\"\n    }\n\n    object Epoxy {\n        private const val version = \"3.9.0\"\n        const val epoxy = \"com.airbnb.android:epoxy:$version\"\n        const val paging = \"com.airbnb.android:epoxy-paging:$version\"\n        const val dataBinding = \"com.airbnb.android:epoxy-databinding:$version\"\n        const val processor = \"com.airbnb.android:epoxy-processor:$version\"\n    }\n\n    object Coil {\n        private const val version = \"0.9.2\"\n        const val coil = \"io.coil-kt:coil:$version\"\n    }\n\n    object AssistedInject {\n        private const val version = \"0.5.2\"\n        const val annotationDagger2 = \"com.squareup.inject:assisted-inject-annotations-dagger2:$version\"\n        const val processorDagger2 = \"com.squareup.inject:assisted-inject-processor-dagger2:$version\"\n    }\n\n    object Roomigrant {\n        private const val version = \"0.1.7\"\n        const val library = \"com.github.MatrixDev.Roomigrant:RoomigrantLib:$version\"\n        const val compiler = \"com.github.MatrixDev.Roomigrant:RoomigrantCompiler:$version\"\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.recommended\n\nimport android.os.Bundle\nimport android.view.ActionMode\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.View\nimport androidx.core.net.toUri\nimport androidx.navigation.fragment.findNavController\nimport app.tivi.SharedElementHelper\nimport app.tivi.common.entrygrid.databinding.FragmentEntryGridBinding\nimport app.tivi.common.layouts.PosterGridItemBindingModel_\nimport app.tivi.data.entities.findHighestRatedPoster\nimport app.tivi.data.resultentities.RecommendedEntryWithShow\nimport app.tivi.extensions.toActivityNavigatorExtras\nimport app.tivi.util.EntryGridEpoxyController\nimport app.tivi.util.EntryGridFragment\nimport com.airbnb.epoxy.EpoxyModel\nimport com.airbnb.mvrx.fragmentViewModel\nimport javax.inject.Inject\n\nclass RecommendedShowsFragment : EntryGridFragment<RecommendedEntryWithShow, RecommendedShowsViewModel>() {\n    override val viewModel: RecommendedShowsViewModel by fragmentViewModel()\n    @Inject lateinit var recommendedShowsViewModelFactory: RecommendedShowsViewModel.Factory\n\n    override fun onViewCreated(binding: FragmentEntryGridBinding, savedInstanceState: Bundle?) {\n        super.onViewCreated(binding, savedInstanceState)\n\n        binding.gridToolbar.apply {\n            setTitle(R.string.discover_recommended_title)\n        }\n    }\n\n    override fun createController(): EntryGridEpoxyController<RecommendedEntryWithShow> {\n        return object : EntryGridEpoxyController<RecommendedEntryWithShow>() {\n            override fun buildItemModel(item: RecommendedEntryWithShow): EpoxyModel<*> {\n                return PosterGridItemBindingModel_()\n                    .id(item.generateStableId())\n                    .posterImage(item.images.findHighestRatedPoster())\n                    .tiviShow(item.show)\n                    .transitionName(item.show.homepage)\n                    .selected(item.show.id in state.selectedShowIds)\n                    .clickListener(View.OnClickListener {\n                        if (viewModel.onItemClick(item.show)) {\n                            return@OnClickListener\n                        }\n                        onItemClicked(item)\n                    })\n                    .longClickListener(View.OnLongClickListener {\n                        viewModel.onItemLongClick(item.show)\n                    })\n            }\n        }\n    }\n\n    internal fun onItemClicked(item: RecommendedEntryWithShow) {\n        val sharedElements = SharedElementHelper()\n        requireBinding().gridRecyclerview.findViewHolderForItemId(item.generateStableId())?.let {\n            sharedElements.addSharedElement(it.itemView, \"poster\")\n        }\n\n        findNavController().navigate(\n            \"app.tivi://show/${item.show.id}\".toUri(),\n            null,\n            sharedElements.toActivityNavigatorExtras(requireActivity())\n        )\n    }\n\n    override fun startSelectionActionMode(): ActionMode? {\n        return requireActivity().startActionMode(object : ActionMode.Callback {\n            override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {\n                when (item.itemId) {\n                    R.id.menu_follow -> viewModel.followSelectedShows()\n                }\n                return true\n            }\n\n            override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {\n                mode.menuInflater.inflate(R.menu.action_mode_entry, menu)\n                return true\n            }\n\n            override fun onPrepareActionMode(mode: ActionMode, menu: Menu) = true\n\n            override fun onDestroyActionMode(mode: ActionMode) {\n                viewModel.clearSelection()\n            }\n        })\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.recommended\n\nimport app.tivi.data.resultentities.RecommendedEntryWithShow\nimport app.tivi.domain.interactors.ChangeShowFollowStatus\nimport app.tivi.domain.interactors.UpdateRecommendedShows\nimport app.tivi.domain.interactors.UpdateRecommendedShows.Page.NEXT_PAGE\nimport app.tivi.domain.interactors.UpdateRecommendedShows.Page.REFRESH\nimport app.tivi.domain.observers.ObservePagedRecommendedShows\nimport app.tivi.util.AppCoroutineDispatchers\nimport app.tivi.util.EntryViewModel\nimport app.tivi.util.EntryViewState\nimport app.tivi.util.Logger\nimport com.airbnb.mvrx.FragmentViewModelContext\nimport com.airbnb.mvrx.MvRxViewModelFactory\nimport com.airbnb.mvrx.ViewModelContext\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\n\nclass RecommendedShowsViewModel @AssistedInject constructor(\n    @Assisted initialState: EntryViewState,\n    override val dispatchers: AppCoroutineDispatchers,\n    override val pagingInteractor: ObservePagedRecommendedShows,\n    private val interactor: UpdateRecommendedShows,\n    override val logger: Logger,\n    override val changeShowFollowStatus: ChangeShowFollowStatus\n) : EntryViewModel<RecommendedEntryWithShow, ObservePagedRecommendedShows>(initialState) {\n    init {\n        pagingInteractor(ObservePagedRecommendedShows.Params(pageListConfig, boundaryCallback))\n\n        launchObserves()\n\n        refresh(false)\n    }\n\n    override fun callLoadMore() = interactor(UpdateRecommendedShows.Params(NEXT_PAGE, true))\n\n    override fun callRefresh(fromUser: Boolean) = interactor(UpdateRecommendedShows.Params(REFRESH, fromUser))\n\n    @AssistedInject.Factory\n    interface Factory {\n        fun create(initialState: EntryViewState): RecommendedShowsViewModel\n    }\n\n    companion object : MvRxViewModelFactory<RecommendedShowsViewModel, EntryViewState> {\n        override fun create(\n            viewModelContext: ViewModelContext,\n            state: EntryViewState\n        ): RecommendedShowsViewModel? {\n            val fragment: RecommendedShowsFragment = (viewModelContext as FragmentViewModelContext).fragment()\n            return fragment.recommendedShowsViewModelFactory.create(state)\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.recommended\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\nabstract class RecommendedBuilder {\n    @ContributesAndroidInjector(modules = [\n        RecommendedAssistedModule::class\n    ])\n    internal abstract fun RecommendedShowsFragment(): RecommendedShowsFragment\n}\n\n@Module(includes = [AssistedInject_RecommendedAssistedModule::class])\n@AssistedModule\ninterface RecommendedAssistedModule",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.imageloading\n\nimport android.app.Application\nimport app.tivi.appinitializers.AppInitializer\nimport coil.Coil\nimport coil.ImageLoader\nimport javax.inject.Inject\n\nclass CoilAppInitializer @Inject constructor(\n    private val tmdbImageEntityMapper: TmdbImageEntityCoilMapper\n) : AppInitializer {\n    override fun init(application: Application) {\n        Coil.setDefaultImageLoader {\n            ImageLoader(application) {\n                // Hardware bitmaps break with our transitions, disable them for now\n                allowHardware(false)\n                // Since we don't use hardware bitmaps, we can pool bitmaps and use a higher\n                // ratio of memory\n                bitmapPoolPercentage(0.5)\n\n                componentRegistry {\n                    add(tmdbImageEntityMapper)\n                }\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.imageloading\n\nimport app.tivi.appinitializers.AppInitializer\nimport dagger.Binds\nimport dagger.Module\nimport dagger.multibindings.IntoSet\n\n@Module\nabstract class ImageLoadingModule {\n    @Binds\n    @IntoSet\n    abstract fun provideCoilInitializer(bind: CoilAppInitializer): AppInitializer\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.imageloading\n\nimport android.content.Context\nimport android.view.MenuItem\nimport app.tivi.extensions.resolveThemeDimensionPixelSize\nimport coil.Coil\nimport coil.api.load\nimport coil.size.PixelSize\nimport coil.size.Size\nimport coil.size.SizeResolver\nimport coil.transform.CircleCropTransformation\n\nfun MenuItem.loadImageUrl(context: Context, url: String, circleCrop: Boolean = true) {\n    Coil.load(context, url) {\n        if (circleCrop) {\n            transformations(CircleCropTransformation())\n        }\n        size(object : SizeResolver {\n            override suspend fun size(): Size {\n                val height = context.resolveThemeDimensionPixelSize(android.R.attr.actionBarSize)\n                return PixelSize(height, height)\n            }\n        })\n        target { icon = it }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.imageloading\n\nimport android.widget.ImageView\nimport androidx.databinding.BindingAdapter\nimport app.tivi.data.entities.ImageType\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TmdbImageEntity\nimport coil.annotation.ExperimentalCoil\nimport coil.api.loadAny\nimport coil.transform.RoundedCornersTransformation\nimport coil.transform.Transformation\n\n@BindingAdapter(\n    \"tmdbBackdropPath\",\n    \"imageSaturateOnLoad\",\n    requireAll = false\n)\nfun ImageView.loadBackdrop(\n    oldPath: String?,\n    oldSaturateOnLoad: Boolean?,\n    path: String?,\n    saturateOnLoad: Boolean?\n) {\n    if (oldPath != path || oldSaturateOnLoad != saturateOnLoad) {\n        loadImage(\n            null,\n            oldSaturateOnLoad,\n            0f,\n            path?.let { ShowTmdbImage(path = path, type = ImageType.BACKDROP, showId = 0) },\n            saturateOnLoad,\n            0f\n        )\n    }\n}\n\n@BindingAdapter(\n    \"tmdbLogoPath\",\n    \"imageSaturateOnLoad\",\n    requireAll = false\n)\nfun ImageView.loadLogo(\n    oldPath: String?,\n    oldSaturateOnLoad: Boolean?,\n    path: String?,\n    saturateOnLoad: Boolean?\n) {\n    if (oldPath != path || oldSaturateOnLoad != saturateOnLoad) {\n        loadImage(\n            null,\n            oldSaturateOnLoad,\n            0f,\n            path?.let { ShowTmdbImage(path = path, type = ImageType.LOGO, showId = 0) },\n            saturateOnLoad,\n            0f\n        )\n    }\n}\n\n@BindingAdapter(\n    \"image\",\n    \"imageSaturateOnLoad\",\n    \"imageCornerRadius\",\n    requireAll = false\n)\n@UseExperimental(ExperimentalCoil::class)\nfun ImageView.loadImage(\n    oldImage: TmdbImageEntity?,\n    oldSaturateOnLoad: Boolean?,\n    oldCornerRadius: Float,\n    image: TmdbImageEntity?,\n    saturateOnLoad: Boolean?,\n    cornerRadius: Float\n) {\n    if (oldImage == image &&\n        oldSaturateOnLoad == saturateOnLoad &&\n        oldCornerRadius == cornerRadius) return\n\n    loadAny(image) {\n        transition(SaturatingTransformation())\n\n        val transformations = ArrayList<Transformation>()\n        if (cornerRadius > 0) {\n            transformations += RoundedCornersTransformation(cornerRadius)\n        }\n        if (image?.type == ImageType.LOGO) {\n            transformations += TrimTransparentEdgesTransformation\n        }\n        transformations(transformations)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.imageloading\n\nimport app.tivi.data.entities.ImageType\nimport app.tivi.data.entities.TmdbImageEntity\nimport app.tivi.tmdb.TmdbImageUrlProvider\nimport coil.map.MeasuredMapper\nimport coil.size.PixelSize\nimport coil.size.Size\nimport javax.inject.Inject\nimport javax.inject.Provider\nimport okhttp3.HttpUrl\nimport okhttp3.HttpUrl.Companion.toHttpUrl\n\nclass TmdbImageEntityCoilMapper @Inject constructor(\n    private val tmdbImageUrlProvider: Provider<TmdbImageUrlProvider>\n) : MeasuredMapper<TmdbImageEntity, HttpUrl> {\n\n    override fun handles(data: TmdbImageEntity): Boolean = true\n\n    override fun map(data: TmdbImageEntity, size: Size): HttpUrl {\n        val width = if (size is PixelSize) size.width else 0\n\n        val urlProvider = tmdbImageUrlProvider.get()\n        return when (data.type) {\n            ImageType.BACKDROP -> urlProvider.getBackdropUrl(data.path, width).toHttpUrl()\n            ImageType.POSTER -> urlProvider.getPosterUrl(data.path, width).toHttpUrl()\n            ImageType.LOGO -> urlProvider.getLogoUrl(data.path, width).toHttpUrl()\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.imageloading\n\nimport androidx.core.animation.doOnEnd\nimport app.tivi.ui.animations.SATURATION_ANIMATION_DURATION\nimport app.tivi.ui.animations.saturateDrawableAnimator\nimport coil.annotation.ExperimentalCoil\nimport coil.transition.Transition\nimport coil.transition.TransitionResult\nimport coil.transition.TransitionTarget\nimport kotlinx.coroutines.suspendCancellableCoroutine\n\n/** A [Transition] that saturates and fades in the new drawable on load */\n@ExperimentalCoil\nclass SaturatingTransformation(\n    private val durationMillis: Long = SATURATION_ANIMATION_DURATION\n) : Transition {\n    init {\n        require(durationMillis > 0) { \"durationMillis must be > 0.\" }\n    }\n\n    override suspend fun transition(\n        target: TransitionTarget<*>,\n        result: TransitionResult\n    ) {\n        // Don't animate if the request was fulfilled by the memory cache.\n        if (result is TransitionResult.Success && result.isMemoryCache) {\n            target.onSuccess(result.drawable)\n            return\n        }\n\n        // Animate the drawable and suspend until the animation is completes.\n        suspendCancellableCoroutine<Unit> { continuation ->\n            when (result) {\n                is TransitionResult.Success -> {\n                    val animator = saturateDrawableAnimator(result.drawable,\n                        durationMillis, target.view)\n                    animator.doOnEnd {\n                        continuation.resume(Unit) { animator.cancel() }\n                    }\n                    animator.start()\n\n                    continuation.invokeOnCancellation { animator.cancel() }\n                    target.onSuccess(result.drawable)\n                }\n                is TransitionResult.Error -> target.onError(result.drawable)\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.imageloading\n\nimport android.graphics.Bitmap\nimport android.graphics.Canvas\nimport android.graphics.Rect\nimport androidx.core.graphics.alpha\nimport coil.bitmappool.BitmapPool\nimport coil.size.Size\nimport coil.transform.Transformation\n\n/**\n * A [Transformation] that trims transparent edges from an image.\n */\nobject TrimTransparentEdgesTransformation : Transformation {\n    override fun key(): String = TrimTransparentEdgesTransformation::class.java.name\n\n    override suspend fun transform(pool: BitmapPool, input: Bitmap, size: Size): Bitmap {\n        val inputWidth = input.width\n        val inputHeight = input.height\n\n        var firstX = 0\n        var firstY = 0\n        var lastX = inputWidth\n        var lastY = inputHeight\n\n        val pixels = IntArray(inputWidth * inputHeight)\n        input.getPixels(pixels, 0, inputWidth, 0, 0, inputWidth, inputHeight)\n\n        loop@\n        for (x in 0 until inputWidth) {\n            for (y in 0 until inputHeight) {\n                if (pixels[x + y * inputWidth].alpha > 0) {\n                    firstX = x\n                    break@loop\n                }\n            }\n        }\n\n        loop@\n        for (y in 0 until inputHeight) {\n            for (x in firstX until inputWidth) {\n                if (pixels[x + y * inputWidth].alpha > 0) {\n                    firstY = y\n                    break@loop\n                }\n            }\n        }\n\n        loop@\n        for (x in inputWidth - 1 downTo firstX) {\n            for (y in inputHeight - 1 downTo firstY) {\n                if (pixels[x + y * inputWidth].alpha > 0) {\n                    lastX = x\n                    break@loop\n                }\n            }\n        }\n\n        loop@\n        for (y in inputHeight - 1 downTo firstY) {\n            for (x in inputWidth - 1 downTo firstX) {\n                if (pixels[x + y * inputWidth].alpha > 0) {\n                    lastY = y\n                    break@loop\n                }\n            }\n        }\n\n        if (firstX == 0 && firstY == 0 && lastX == inputWidth && lastY == inputHeight) {\n            return input\n        }\n\n        val output = pool.get(1 + lastX - firstX, 1 + lastY - firstY, Bitmap.Config.ARGB_8888)\n        val canvas = Canvas(output)\n\n        val src = Rect(firstX, firstY, firstX + output.width, firstY + output.height)\n        val dst = Rect(0, 0, output.width, output.height)\n\n        canvas.drawBitmap(input, src, dst, null)\n\n        // Put the original bitmap in the pool\n        pool.put(input)\n\n        return output\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi\n\nimport android.view.View\nimport androidx.collection.ArrayMap\n\nclass SharedElementHelper {\n    private val _sharedElements = ArrayMap<View, String?>()\n\n    val sharedElements: Map<View, String?>\n        get() = _sharedElements\n\n    fun addSharedElement(view: View, transitionName: String? = view.transitionName) {\n        _sharedElements[view] = transitionName ?: view.transitionName\n    }\n\n    fun isEmpty(): Boolean = _sharedElements.isEmpty\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\nimport android.text.format.DateUtils\nimport app.tivi.inject.MediumDate\nimport app.tivi.inject.MediumDateTime\nimport app.tivi.inject.ShortDate\nimport app.tivi.inject.ShortTime\nimport javax.inject.Inject\nimport javax.inject.Singleton\nimport org.threeten.bp.LocalTime\nimport org.threeten.bp.OffsetDateTime\nimport org.threeten.bp.format.DateTimeFormatter\nimport org.threeten.bp.temporal.Temporal\n\n@Singleton\nclass TiviDateFormatter @Inject constructor(\n    @ShortTime private val shortTimeFormatter: DateTimeFormatter,\n    @ShortDate private val shortDateFormatter: DateTimeFormatter,\n    @MediumDate private val mediumDateFormatter: DateTimeFormatter,\n    @MediumDateTime private val mediumDateTimeFormatter: DateTimeFormatter\n) {\n    fun formatShortDate(temporalAmount: Temporal): String = shortDateFormatter.format(temporalAmount)\n\n    fun formatMediumDate(temporalAmount: Temporal): String = mediumDateFormatter.format(temporalAmount)\n\n    fun formatMediumDateTime(temporalAmount: Temporal): String = mediumDateTimeFormatter.format(temporalAmount)\n\n    fun formatShortTime(localTime: LocalTime): String = shortTimeFormatter.format(localTime)\n\n    fun formatShortRelativeTime(dateTime: OffsetDateTime?): CharSequence? {\n        if (dateTime == null) {\n            return null\n        }\n\n        val now = OffsetDateTime.now()\n\n        return if (dateTime.isBefore(now)) {\n            if (dateTime.year == now.year || dateTime.isAfter(now.minusDays(7))) {\n                // Within the past week\n                DateUtils.getRelativeTimeSpanString(\n                    dateTime.toInstant().toEpochMilli(),\n                    System.currentTimeMillis(),\n                    DateUtils.MINUTE_IN_MILLIS,\n                    DateUtils.FORMAT_SHOW_DATE)\n            } else {\n                // More than 7 days ago\n                formatShortDate(dateTime)\n            }\n        } else {\n            if (dateTime.year == now.year || dateTime.isBefore(now.plusDays(14))) {\n                // In the near future (next 2 weeks)\n                DateUtils.getRelativeTimeSpanString(\n                    dateTime.toInstant().toEpochMilli(),\n                    System.currentTimeMillis(),\n                    DateUtils.MINUTE_IN_MILLIS,\n                    DateUtils.FORMAT_SHOW_DATE)\n            } else {\n                // In the far future\n                formatShortDate(dateTime)\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\nimport androidx.lifecycle.LifecycleOwner\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.Observer\n\n/**\n * Used as a wrapper for data that is exposed via a LiveData that represents an event.\n */\nopen class Event<out T>(private val content: T) {\n    var hasBeenHandled = false\n        private set // Allow external read but not write\n\n    /**\n     * Returns the content and prevents its use again.\n     */\n    fun getContentIfNotHandled(): T? {\n        return if (hasBeenHandled) {\n            null\n        } else {\n            hasBeenHandled = true\n            content\n        }\n    }\n\n    /**\n     * Returns the content, even if it's already been handled.\n     */\n    fun peekContent(): T = content\n}\n\n/**\n * An [Observer] for [Event]s, simplifying the pattern of checking if the [Event]'s content has\n * already been handled.\n *\n * [onEventUnhandledContent] is *only* called if the [Event]'s contents has not been handled.\n */\nclass EventObserver<T>(private val onEventUnhandledContent: (T) -> Unit) : Observer<Event<T>> {\n    override fun onChanged(event: Event<T>?) {\n        event?.getContentIfNotHandled()?.let { value ->\n            onEventUnhandledContent(value)\n        }\n    }\n}\n\ninline fun <T> LiveData<Event<T>>.observeEvent(\n    owner: LifecycleOwner,\n    crossinline observer: (T) -> Unit\n) {\n    observe(owner, EventObserver { observer(it) })\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\nimport android.os.Build\nimport android.util.Log\nimport com.crashlytics.android.Crashlytics\nimport java.util.regex.Pattern\nimport javax.inject.Inject\nimport timber.log.Timber\n\nclass TiviLogger @Inject constructor() : Logger {\n    fun setup(debugMode: Boolean) {\n        if (debugMode) {\n            Timber.plant(TiviDebugTree())\n        }\n        Timber.plant(CrashlyticsTree())\n    }\n\n    override fun v(message: String, vararg args: Any?) {\n        Timber.v(message, *args)\n    }\n\n    override fun v(t: Throwable, message: String, vararg args: Any?) {\n        Timber.v(t, message, *args)\n    }\n\n    override fun v(t: Throwable) {\n        Timber.v(t)\n    }\n\n    override fun d(message: String, vararg args: Any?) {\n        Timber.d(message, *args)\n    }\n\n    override fun d(t: Throwable, message: String, vararg args: Any?) {\n        Timber.d(t, message, *args)\n    }\n\n    override fun d(t: Throwable) {\n        Timber.d(t)\n    }\n\n    override fun i(message: String, vararg args: Any?) {\n        Timber.i(message, *args)\n    }\n\n    override fun i(t: Throwable, message: String, vararg args: Any?) {\n        Timber.i(t, message, *args)\n    }\n\n    override fun i(t: Throwable) {\n        Timber.i(t)\n    }\n\n    override fun w(message: String, vararg args: Any?) {\n        Timber.w(message, *args)\n    }\n\n    override fun w(t: Throwable, message: String, vararg args: Any?) {\n        Timber.w(t, message, *args)\n    }\n\n    override fun w(t: Throwable) {\n        Timber.w(t)\n    }\n\n    override fun e(message: String, vararg args: Any?) {\n        Timber.e(message, *args)\n    }\n\n    override fun e(t: Throwable, message: String, vararg args: Any?) {\n        Timber.e(t, message, *args)\n    }\n\n    override fun e(t: Throwable) {\n        Timber.e(t)\n    }\n\n    override fun wtf(message: String, vararg args: Any?) {\n        Timber.wtf(message, *args)\n    }\n\n    override fun wtf(t: Throwable, message: String, vararg args: Any?) {\n        Timber.wtf(t, message, *args)\n    }\n\n    override fun wtf(t: Throwable) {\n        Timber.wtf(t)\n    }\n}\n\n/**\n * Special version of [Timber.DebugTree] which is tailored for Timber being wrapped\n * within another class.\n */\nprivate class TiviDebugTree : Timber.DebugTree() {\n    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {\n        super.log(priority, createClassTag(), message, t)\n    }\n\n    private fun createClassTag(): String {\n        val stackTrace = Throwable().stackTrace\n        if (stackTrace.size <= CALL_STACK_INDEX) {\n            throw IllegalStateException(\"Synthetic stacktrace didn't have enough elements: are you using proguard?\")\n        }\n        var tag = stackTrace[CALL_STACK_INDEX].className\n        val m = ANONYMOUS_CLASS.matcher(tag)\n        if (m.find()) {\n            tag = m.replaceAll(\"\")\n        }\n        tag = tag.substring(tag.lastIndexOf('.') + 1)\n        // Tag length limit was removed in API 24.\n        return if (tag.length <= MAX_TAG_LENGTH || Build.VERSION.SDK_INT >= 24) {\n            tag\n        } else tag.substring(0, MAX_TAG_LENGTH)\n    }\n\n    companion object {\n        private const val MAX_TAG_LENGTH = 23\n        private const val CALL_STACK_INDEX = 7\n        private val ANONYMOUS_CLASS = Pattern.compile(\"(\\\\$\\\\d+)+$\")\n    }\n}\n\nprivate class CrashlyticsTree : Timber.Tree() {\n    override fun isLoggable(tag: String?, priority: Int): Boolean {\n        return priority >= Log.DEBUG\n    }\n\n    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {\n        Crashlytics.log(message)\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.appinitializers\n\nimport android.app.Application\n\ninterface AppInitializer {\n    fun init(application: Application)\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport androidx.lifecycle.LifecycleOwner\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.Observer\nimport kotlinx.coroutines.channels.awaitClose\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.channelFlow\n\ninline fun <T> LiveData<T>.observeK(owner: LifecycleOwner, crossinline observer: (T?) -> Unit) {\n    this.observe(owner, Observer { observer(it) })\n}\n\ninline fun <T> LiveData<T>.observeNotNull(\n    owner: LifecycleOwner,\n    crossinline observer: (T) -> Unit\n) {\n    this.observe(owner, Observer { it?.run(observer) })\n}\n\nfun <T> LiveData<T>.asFlow(): Flow<T> {\n    return channelFlow {\n        value?.also { send(it) }\n        val observer = Observer<T> { v -> offer(v) }\n        observeForever(observer)\n        awaitClose {\n            removeObserver(observer)\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport android.app.Activity\nimport android.content.Context\nimport android.content.ContextWrapper\nimport android.view.inputmethod.InputMethodManager\nimport androidx.core.content.getSystemService\nimport androidx.fragment.app.Fragment\n\ninline fun <reified T : Context> Context.findBaseContext(): T? {\n    var ctx: Context? = this\n    do {\n        if (ctx is T) {\n            return ctx\n        }\n        if (ctx is ContextWrapper) {\n            ctx = ctx.baseContext\n        }\n    } while (ctx != null)\n\n    // If we reach here, there's not an Context of type T in our Context hierarchy\n    return null\n}\n\nfun Activity.hideSoftInput() {\n    val imm: InputMethodManager? = getSystemService()\n    val currentFocus = currentFocus\n    if (currentFocus != null && imm != null) {\n        imm.hideSoftInputFromWindow(currentFocus.windowToken, 0)\n    }\n}\n\nfun Fragment.hideSoftInput() = requireActivity().hideSoftInput()",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport java.text.SimpleDateFormat\nimport org.threeten.bp.format.DateTimeFormatter\n\nfun SimpleDateFormat.toThreeTenDateTimeFormatter(): DateTimeFormatter {\n    return DateTimeFormatter.ofPattern(toPattern())\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport android.view.MenuItem\n\nfun MenuItem.setActionViewExpanded(expanded: Boolean) {\n    if (expanded != isActionViewExpanded) {\n        if (expanded) expandActionView() else collapseActionView()\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi\n\nimport android.app.PendingIntent\n\ninterface AppNavigator {\n    fun provideAuthHandleResponseIntent(requestCode: Int): PendingIntent\n    fun startLogin()\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.followed\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\nabstract class FollowedBuilder {\n    @ContributesAndroidInjector(modules = [\n        FollowedAssistedModule::class\n    ])\n    abstract fun followedFragment(): FollowedFragment\n}\n\n@Module(includes = [AssistedInject_FollowedAssistedModule::class])\n@AssistedModule\ninterface FollowedAssistedModule",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.followed\n\nimport androidx.lifecycle.viewModelScope\nimport androidx.paging.PagedList\nimport app.tivi.AppNavigator\nimport app.tivi.TiviMvRxViewModel\nimport app.tivi.data.entities.RefreshType\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.resultentities.FollowedShowEntryWithShow\nimport app.tivi.domain.interactors.ChangeShowFollowStatus\nimport app.tivi.domain.interactors.UpdateFollowedShows\nimport app.tivi.domain.invoke\nimport app.tivi.domain.launchObserve\nimport app.tivi.domain.observers.ObservePagedFollowedShows\nimport app.tivi.domain.observers.ObserveTraktAuthState\nimport app.tivi.domain.observers.ObserveUserDetails\nimport app.tivi.trakt.TraktAuthState\nimport app.tivi.util.ObservableLoadingCounter\nimport app.tivi.util.ShowStateSelector\nimport app.tivi.util.collectFrom\nimport com.airbnb.mvrx.FragmentViewModelContext\nimport com.airbnb.mvrx.MvRxViewModelFactory\nimport com.airbnb.mvrx.ViewModelContext\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.debounce\nimport kotlinx.coroutines.flow.distinctUntilChanged\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.flow.onEach\nimport kotlinx.coroutines.launch\n\ninternal class FollowedViewModel @AssistedInject constructor(\n    @Assisted initialState: FollowedViewState,\n    private val updateFollowedShows: UpdateFollowedShows,\n    private val observePagedFollowedShows: ObservePagedFollowedShows,\n    private val observeTraktAuthState: ObserveTraktAuthState,\n    private val changeShowFollowStatus: ChangeShowFollowStatus,\n    private val observeUserDetails: ObserveUserDetails,\n    private val appNavigator: AppNavigator\n) : TiviMvRxViewModel<FollowedViewState>(initialState) {\n    private val boundaryCallback = object : PagedList.BoundaryCallback<FollowedShowEntryWithShow>() {\n        override fun onZeroItemsLoaded() {\n            setState { copy(isEmpty = filter.isNullOrEmpty()) }\n        }\n\n        override fun onItemAtEndLoaded(itemAtEnd: FollowedShowEntryWithShow) {\n            setState { copy(isEmpty = false) }\n        }\n\n        override fun onItemAtFrontLoaded(itemAtFront: FollowedShowEntryWithShow) {\n            setState { copy(isEmpty = false) }\n        }\n    }\n\n    private val loadingState = ObservableLoadingCounter()\n    private val showSelection = ShowStateSelector()\n\n    val pagedList: Flow<PagedList<FollowedShowEntryWithShow>>\n        get() = observePagedFollowedShows.observe()\n\n    init {\n        viewModelScope.launch {\n            loadingState.observable\n                .distinctUntilChanged()\n                .debounce(2000)\n                .execute {\n                    copy(isLoading = it() ?: false)\n                }\n        }\n\n        viewModelScope.launch {\n            showSelection.observeSelectedShowIds().collect {\n                setState { copy(selectedShowIds = it) }\n            }\n        }\n\n        viewModelScope.launch {\n            showSelection.observeIsSelectionOpen().collect {\n                setState { copy(selectionOpen = it) }\n            }\n        }\n\n        viewModelScope.launchObserve(observeTraktAuthState) { flow ->\n            flow.distinctUntilChanged().onEach {\n                if (it == TraktAuthState.LOGGED_IN) {\n                    refreshFollowed(false)\n                }\n            }.execute { copy(authState = it() ?: TraktAuthState.LOGGED_OUT) }\n        }\n        observeTraktAuthState()\n\n        viewModelScope.launchObserve(observeUserDetails) {\n            it.execute { copy(user = it()) }\n        }\n        observeUserDetails(ObserveUserDetails.Params(\"me\"))\n\n        // Set the available sorting options\n        setState {\n            copy(availableSorts = listOf(\n                SortOption.SUPER_SORT,\n                SortOption.LAST_WATCHED,\n                SortOption.ALPHABETICAL,\n                SortOption.DATE_ADDED\n            ))\n        }\n\n        // Subscribe to state changes, so update the observed data source\n        subscribe(::updateDataSource)\n\n        refresh(false)\n    }\n\n    private fun updateDataSource(state: FollowedViewState) {\n        observePagedFollowedShows(\n            ObservePagedFollowedShows.Parameters(\n                sort = state.sort,\n                filter = state.filter,\n                pagingConfig = PAGING_CONFIG,\n                boundaryCallback = boundaryCallback\n            )\n        )\n    }\n\n    fun refresh() = refresh(true)\n\n    private fun refresh(fromUser: Boolean) {\n        viewModelScope.launch {\n            observeTraktAuthState.observe()\n                .first { it == TraktAuthState.LOGGED_IN }\n                .also { refreshFollowed(fromUser) }\n        }\n    }\n\n    fun setFilter(filter: String) {\n        setState { copy(filter = filter, filterActive = filter.isNotEmpty()) }\n    }\n\n    fun setSort(sort: SortOption) = setState {\n        require(availableSorts.contains(sort))\n        copy(sort = sort)\n    }\n\n    fun clearSelection() {\n        showSelection.clearSelection()\n    }\n\n    fun onItemClick(show: TiviShow): Boolean {\n        return showSelection.onItemClick(show)\n    }\n\n    fun onItemLongClick(show: TiviShow): Boolean {\n        return showSelection.onItemLongClick(show)\n    }\n\n    fun unfollowSelectedShows() {\n        changeShowFollowStatus(\n            ChangeShowFollowStatus.Params(\n                showSelection.getSelectedShowIds(),\n                ChangeShowFollowStatus.Action.UNFOLLOW)\n        )\n        showSelection.clearSelection()\n    }\n\n    fun onLoginClicked() {\n        appNavigator.startLogin()\n    }\n\n    private fun refreshFollowed(fromInteraction: Boolean) {\n        updateFollowedShows(UpdateFollowedShows.Params(fromInteraction, RefreshType.QUICK)).also {\n            viewModelScope.launch {\n                loadingState.collectFrom(it)\n            }\n        }\n    }\n\n    @AssistedInject.Factory\n    interface Factory {\n        fun create(initialState: FollowedViewState): FollowedViewModel\n    }\n\n    companion object : MvRxViewModelFactory<FollowedViewModel, FollowedViewState> {\n        private val PAGING_CONFIG = PagedList.Config.Builder()\n            .setPageSize(60)\n            .setPrefetchDistance(20)\n            .setEnablePlaceholders(false)\n            .build()\n\n        override fun create(\n            viewModelContext: ViewModelContext,\n            state: FollowedViewState\n        ): FollowedViewModel? {\n            val fragment: FollowedFragment = (viewModelContext as FragmentViewModelContext).fragment()\n            return fragment.followedViewModelFactory.create(state)\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.followed\n\nimport android.os.Bundle\nimport android.view.ActionMode\nimport android.view.LayoutInflater\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.ViewGroup\nimport androidx.core.net.toUri\nimport androidx.core.view.updatePadding\nimport androidx.lifecycle.lifecycleScope\nimport androidx.navigation.fragment.findNavController\nimport app.tivi.TiviFragmentWithBinding\nimport app.tivi.common.imageloading.loadImageUrl\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.resultentities.FollowedShowEntryWithShow\nimport app.tivi.extensions.doOnSizeChange\nimport app.tivi.extensions.navigateToNavDestination\nimport app.tivi.extensions.postponeEnterTransitionWithTimeout\nimport app.tivi.extensions.scheduleStartPostponedTransitions\nimport app.tivi.extensions.toActivityNavigatorExtras\nimport app.tivi.home.followed.databinding.FragmentFollowedBinding\nimport app.tivi.ui.AuthStateMenuItemBinder\nimport app.tivi.ui.SpacingItemDecorator\nimport app.tivi.ui.authStateToolbarMenuBinder\nimport app.tivi.ui.createSharedElementHelperForItem\nimport app.tivi.ui.recyclerview.HideImeOnScrollListener\nimport com.airbnb.mvrx.fragmentViewModel\nimport com.airbnb.mvrx.withState\nimport javax.inject.Inject\nimport kotlinx.coroutines.flow.collect\n\nclass FollowedFragment : TiviFragmentWithBinding<FragmentFollowedBinding>() {\n    private val viewModel: FollowedViewModel by fragmentViewModel()\n\n    @Inject internal lateinit var followedViewModelFactory: FollowedViewModel.Factory\n    @Inject internal lateinit var controller: FollowedEpoxyController\n\n    private var currentActionMode: ActionMode? = null\n\n    private var authStateMenuItemBinder: AuthStateMenuItemBinder? = null\n\n    override fun createBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): FragmentFollowedBinding {\n        return FragmentFollowedBinding.inflate(inflater, container, false)\n    }\n\n    override fun onViewCreated(binding: FragmentFollowedBinding, savedInstanceState: Bundle?) {\n        postponeEnterTransitionWithTimeout()\n\n        authStateMenuItemBinder = authStateToolbarMenuBinder(\n            binding.followedToolbar,\n            R.id.home_menu_user_avatar,\n            R.id.home_menu_user_login\n        ) { menuItem, url -> menuItem.loadImageUrl(requireContext(), url) }\n\n        binding.followedToolbar.setOnMenuItemClickListener {\n            when (it.itemId) {\n                R.id.home_menu_user_login -> {\n                    viewModel.onLoginClicked()\n                }\n                R.id.home_menu_user_avatar -> {\n                    findNavController().navigateToNavDestination(R.id.navigation_settings)\n                }\n            }\n            true\n        }\n\n        binding.followedAppBar.doOnSizeChange {\n            binding.followedRv.updatePadding(top = it.height)\n            binding.followedSwipeRefresh.setProgressViewOffset(true, 0,\n                it.height + binding.followedSwipeRefresh.progressCircleDiameter / 2)\n            true\n        }\n\n        controller.callbacks = object : FollowedEpoxyController.Callbacks {\n            override fun onItemClicked(item: FollowedShowEntryWithShow) {\n                // Let the ViewModel have the first go\n                if (viewModel.onItemClick(item.show)) {\n                    return\n                }\n\n                val extras = binding.followedRv.createSharedElementHelperForItem(item, \"poster\") {\n                    it.findViewById(R.id.show_poster)\n                }\n\n                findNavController().navigate(\n                    \"app.tivi://show/${item.show.id}\".toUri(),\n                    null,\n                    extras.toActivityNavigatorExtras(requireActivity())\n                )\n            }\n\n            override fun onItemLongClicked(item: FollowedShowEntryWithShow): Boolean {\n                return viewModel.onItemLongClick(item.show)\n            }\n\n            override fun onFilterChanged(filter: String) = viewModel.setFilter(filter)\n\n            override fun onSortSelected(sort: SortOption) = viewModel.setSort(sort)\n        }\n\n        binding.followedRv.apply {\n            addItemDecoration(SpacingItemDecorator(paddingLeft))\n            addOnScrollListener(HideImeOnScrollListener())\n            setController(controller)\n        }\n\n        binding.followedSwipeRefresh.setOnRefreshListener(viewModel::refresh)\n\n        lifecycleScope.launchWhenStarted {\n            viewModel.pagedList.collect {\n                controller.submitList(it)\n            }\n        }\n    }\n\n    override fun invalidate(binding: FragmentFollowedBinding) = withState(viewModel) { state ->\n        if (binding.state == null) {\n            // First time we've had state, start any postponed transitions\n            scheduleStartPostponedTransitions()\n        }\n\n        if (state.selectionOpen && currentActionMode == null) {\n            startSelectionActionMode()\n        } else if (!state.selectionOpen && currentActionMode != null) {\n            currentActionMode?.finish()\n        }\n\n        currentActionMode?.title = getString(R.string.selection_title, state.selectedShowIds.size)\n\n        authStateMenuItemBinder?.bind(state.authState, state.user)\n\n        binding.state = state\n        controller.state = state\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        currentActionMode?.finish()\n        controller.clear()\n        authStateMenuItemBinder = null\n    }\n\n    private fun startSelectionActionMode() {\n        currentActionMode = requireActivity().startActionMode(object : ActionMode.Callback {\n            override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {\n                when (item.itemId) {\n                    R.id.menu_unfollow -> viewModel.unfollowSelectedShows()\n                }\n                return true\n            }\n\n            override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {\n                mode.menuInflater.inflate(R.menu.action_mode_followed, menu)\n                return true\n            }\n\n            override fun onPrepareActionMode(mode: ActionMode, menu: Menu) = true\n\n            override fun onDestroyActionMode(mode: ActionMode) {\n                viewModel.clearSelection()\n\n                if (mode == currentActionMode) {\n                    currentActionMode = null\n                }\n            }\n        })\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.followed\n\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.entities.TraktUser\nimport app.tivi.trakt.TraktAuthState\nimport com.airbnb.mvrx.MvRxState\n\ndata class FollowedViewState(\n    val user: TraktUser? = null,\n    val authState: TraktAuthState = TraktAuthState.LOGGED_OUT,\n    val isLoading: Boolean = false,\n    val isEmpty: Boolean = false,\n    val selectionOpen: Boolean = false,\n    val selectedShowIds: Set<Long> = emptySet(),\n    val filterActive: Boolean = false,\n    val filter: String? = null,\n    val availableSorts: List<SortOption> = emptyList(),\n    val sort: SortOption = SortOption.SUPER_SORT\n) : MvRxState",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.followed\n\nimport android.text.Editable\nimport android.text.TextWatcher\nimport app.tivi.common.epoxy.TotalSpanOverride\nimport app.tivi.common.layouts.emptyState\nimport app.tivi.common.layouts.filter\nimport app.tivi.common.layouts.vertSpacerNormal\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.entities.findHighestRatedPoster\nimport app.tivi.data.resultentities.FollowedShowEntryWithShow\nimport app.tivi.extensions.observable\nimport app.tivi.home.HomeTextCreator\nimport app.tivi.ui.SortPopupMenuListener\nimport app.tivi.ui.popupMenuItemIdToSortOption\nimport com.airbnb.epoxy.EpoxyModel\nimport com.airbnb.epoxy.paging.PagedListEpoxyController\nimport javax.inject.Inject\n\ninternal class FollowedEpoxyController @Inject constructor(\n    private val textCreator: HomeTextCreator\n) : PagedListEpoxyController<FollowedShowEntryWithShow>() {\n    var state by observable(FollowedViewState(), ::requestModelBuild)\n    var callbacks: Callbacks? by observable(null, ::requestModelBuild)\n\n    override fun addModels(models: List<EpoxyModel<*>>) {\n        if (state.isEmpty) {\n            emptyState {\n                id(\"empty\")\n                spanSizeOverride(TotalSpanOverride)\n            }\n        } else {\n            vertSpacerNormal {\n                id(\"top_spacer\")\n            }\n            filter {\n                id(\"filters\")\n                filter(state.filter)\n                numberShows(models.size)\n                watcher(object : TextWatcher {\n                    override fun afterTextChanged(s: Editable?) {\n                        callbacks?.onFilterChanged(s?.toString() ?: \"\")\n                    }\n\n                    override fun beforeTextChanged(\n                        s: CharSequence?,\n                        start: Int,\n                        count: Int,\n                        after: Int\n                    ) = Unit\n\n                    override fun onTextChanged(\n                        s: CharSequence?,\n                        start: Int,\n                        before: Int,\n                        count: Int\n                    ) = Unit\n                })\n\n                popupMenuListener(SortPopupMenuListener(state.sort, state.availableSorts))\n                popupMenuClickListener {\n                    val option = popupMenuItemIdToSortOption(it.itemId)\n                        ?: throw IllegalArgumentException(\"Selected sort option is null\")\n                    callbacks?.onSortSelected(option)\n                    true\n                }\n            }\n\n            super.addModels(models)\n\n            vertSpacerNormal {\n                id(\"bottom_spacer\")\n            }\n        }\n    }\n\n    override fun buildItemModel(\n        currentPosition: Int,\n        item: FollowedShowEntryWithShow?\n    ): EpoxyModel<*> {\n        return LibraryFollowedItemBindingModel_().apply {\n            if (item != null) {\n                id(item.generateStableId())\n                tiviShow(item.show)\n                posterImage(item.images.findHighestRatedPoster())\n                posterTransitionName(\"show_${item.show.homepage}\")\n                selected(item.show.id in state.selectedShowIds)\n                clickListener { _ -> callbacks?.onItemClicked(item) }\n                longClickListener { _ -> callbacks?.onItemLongClicked(item) ?: false }\n            } else {\n                id(\"item_placeholder_$currentPosition\")\n            }\n            followedEntry(item?.entry)\n            stats(item?.stats)\n            textCreator(textCreator)\n        }\n    }\n\n    fun clear() {\n        callbacks = null\n    }\n\n    interface Callbacks {\n        fun onItemClicked(item: FollowedShowEntryWithShow)\n        fun onItemLongClicked(item: FollowedShowEntryWithShow): Boolean\n        fun onFilterChanged(filter: String)\n        fun onSortSelected(sort: SortOption)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails.details\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\nabstract class ShowDetailsFragmentBuilder {\n    @ContributesAndroidInjector(modules = [\n        ShowDetailsAssistedModule::class\n    ])\n    abstract fun showDetailsFragment(): ShowDetailsFragment\n}\n\n@Module(includes = [AssistedInject_ShowDetailsAssistedModule::class])\n@AssistedModule\ninterface ShowDetailsAssistedModule",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails.details\n\nimport app.tivi.data.entities.ActionDate\n\ninternal sealed class ShowDetailsAction\ninternal object RefreshAction : ShowDetailsAction()\ninternal object FollowShowToggleAction : ShowDetailsAction()\ninternal data class MarkSeasonWatchedAction(\n    val seasonId: Long,\n    val onlyAired: Boolean,\n    val date: ActionDate\n) : ShowDetailsAction()\n\ninternal data class MarkSeasonUnwatchedAction(val seasonId: Long) : ShowDetailsAction()\ninternal data class ChangeSeasonFollowedAction(\n    val seasonId: Long,\n    val followed: Boolean\n) : ShowDetailsAction()\n\ninternal data class UnfollowPreviousSeasonsFollowedAction(val seasonId: Long) : ShowDetailsAction()\ninternal data class ChangeSeasonExpandedAction(\n    val seasonId: Long,\n    val expanded: Boolean\n) : ShowDetailsAction()\n\ninternal data class OpenEpisodeDetails(val episodeId: Long) : ShowDetailsAction()",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails.details\n\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.resultentities.EpisodeWithSeason\nimport app.tivi.data.resultentities.RelatedShowEntryWithShow\nimport app.tivi.data.resultentities.SeasonWithEpisodesAndWatches\nimport app.tivi.data.views.FollowedShowsWatchStats\nimport com.airbnb.mvrx.Async\nimport com.airbnb.mvrx.MvRxState\nimport com.airbnb.mvrx.Uninitialized\n\ndata class ShowDetailsViewState(\n    val showId: Long = 0,\n    val isFollowed: Boolean = false,\n    val show: TiviShow = TiviShow.EMPTY_SHOW,\n    val posterImage: ShowTmdbImage? = null,\n    val backdropImage: ShowTmdbImage? = null,\n    val relatedShows: Async<List<RelatedShowEntryWithShow>> = Uninitialized,\n    val nextEpisodeToWatch: Async<EpisodeWithSeason?> = Uninitialized,\n    val viewStats: Async<FollowedShowsWatchStats> = Uninitialized,\n    val seasons: Async<List<SeasonWithEpisodesAndWatches>> = Uninitialized,\n    val expandedSeasonIds: Set<Long> = emptySet(),\n    val focusedSeason: FocusSeasonUiEffect? = null,\n    val openEpisodeUiEffect: OpenEpisodeUiEffect? = null,\n    val refreshing: Boolean = false\n) : MvRxState\n\ndata class FocusSeasonUiEffect(val seasonId: Long)\n\nsealed class OpenEpisodeUiEffect\ndata class PendingOpenEpisodeUiEffect(val episodeId: Long) : OpenEpisodeUiEffect()\ndata class ExecutableOpenEpisodeUiEffect(\n    val episodeId: Long,\n    val seasonId: Long\n) : OpenEpisodeUiEffect()",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails.details\n\nimport androidx.lifecycle.viewModelScope\nimport app.tivi.TiviMvRxViewModel\nimport app.tivi.domain.interactors.ChangeSeasonFollowStatus\nimport app.tivi.domain.interactors.ChangeSeasonWatchedStatus\nimport app.tivi.domain.interactors.ChangeSeasonWatchedStatus.Action\nimport app.tivi.domain.interactors.ChangeSeasonWatchedStatus.Params\nimport app.tivi.domain.interactors.ChangeShowFollowStatus\nimport app.tivi.domain.interactors.ChangeShowFollowStatus.Action.TOGGLE\nimport app.tivi.domain.interactors.GetEpisodeDetails\nimport app.tivi.domain.interactors.UpdateRelatedShows\nimport app.tivi.domain.interactors.UpdateShowDetails\nimport app.tivi.domain.interactors.UpdateShowImages\nimport app.tivi.domain.interactors.UpdateShowSeasonData\nimport app.tivi.domain.launchObserve\nimport app.tivi.domain.observers.ObserveRelatedShows\nimport app.tivi.domain.observers.ObserveShowDetails\nimport app.tivi.domain.observers.ObserveShowFollowStatus\nimport app.tivi.domain.observers.ObserveShowImages\nimport app.tivi.domain.observers.ObserveShowNextEpisodeToWatch\nimport app.tivi.domain.observers.ObserveShowSeasonData\nimport app.tivi.domain.observers.ObserveShowViewStats\nimport app.tivi.util.ObservableLoadingCounter\nimport app.tivi.util.collectFrom\nimport com.airbnb.mvrx.FragmentViewModelContext\nimport com.airbnb.mvrx.MvRxViewModelFactory\nimport com.airbnb.mvrx.Success\nimport com.airbnb.mvrx.ViewModelContext\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\nimport kotlinx.coroutines.channels.Channel\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.distinctUntilChanged\nimport kotlinx.coroutines.launch\n\ninternal class ShowDetailsFragmentViewModel @AssistedInject constructor(\n    @Assisted initialState: ShowDetailsViewState,\n    private val updateShowDetails: UpdateShowDetails,\n    observeShowDetails: ObserveShowDetails,\n    observeShowImages: ObserveShowImages,\n    private val updateShowImages: UpdateShowImages,\n    private val updateRelatedShows: UpdateRelatedShows,\n    observeRelatedShows: ObserveRelatedShows,\n    private val updateShowSeasons: UpdateShowSeasonData,\n    observeShowSeasons: ObserveShowSeasonData,\n    private val changeSeasonWatchedStatus: ChangeSeasonWatchedStatus,\n    observeShowFollowStatus: ObserveShowFollowStatus,\n    observeNextEpisodeToWatch: ObserveShowNextEpisodeToWatch,\n    observeShowViewStats: ObserveShowViewStats,\n    private val changeShowFollowStatus: ChangeShowFollowStatus,\n    private val changeSeasonFollowStatus: ChangeSeasonFollowStatus,\n    private val getEpisode: GetEpisodeDetails\n) : TiviMvRxViewModel<ShowDetailsViewState>(initialState) {\n\n    private val loadingState = ObservableLoadingCounter()\n\n    private val pendingActions = Channel<ShowDetailsAction>(Channel.BUFFERED)\n\n    init {\n        viewModelScope.launchObserve(observeShowFollowStatus) { flow ->\n            flow.distinctUntilChanged().execute {\n                copy(isFollowed = if (it is Success) it() else false)\n            }\n        }\n\n        viewModelScope.launchObserve(observeShowDetails) { flow ->\n            flow.distinctUntilChanged().execute {\n                if (it is Success) {\n                    copy(show = it())\n                } else {\n                    this\n                }\n            }\n        }\n\n        viewModelScope.launchObserve(observeShowImages) { flow ->\n            flow.distinctUntilChanged().execute { images ->\n                if (images is Success) {\n                    copy(backdropImage = images().backdrop, posterImage = images().poster)\n                } else {\n                    this\n                }\n            }\n        }\n\n        viewModelScope.launch {\n            loadingState.observable.collect { setState { copy(refreshing = it) } }\n        }\n\n        viewModelScope.launchObserve(observeRelatedShows) { flow ->\n            flow.distinctUntilChanged().execute { copy(relatedShows = it) }\n        }\n\n        viewModelScope.launchObserve(observeNextEpisodeToWatch) { flow ->\n            flow.distinctUntilChanged().execute { copy(nextEpisodeToWatch = it) }\n        }\n\n        viewModelScope.launchObserve(observeShowSeasons) { flow ->\n            flow.distinctUntilChanged().execute { copy(seasons = it) }\n        }\n\n        viewModelScope.launchObserve(observeShowViewStats) { flow ->\n            flow.distinctUntilChanged().execute { copy(viewStats = it) }\n        }\n\n        viewModelScope.launch {\n            for (action in pendingActions) when (action) {\n                is RefreshAction -> refresh(true)\n                FollowShowToggleAction -> onToggleMyShowsButtonClicked()\n                is MarkSeasonWatchedAction -> onMarkSeasonWatched(action)\n                is MarkSeasonUnwatchedAction -> onMarkSeasonUnwatched(action)\n                is ChangeSeasonFollowedAction -> onChangeSeasonFollowState(action)\n                is ChangeSeasonExpandedAction -> onChangeSeasonExpandState(action)\n                is UnfollowPreviousSeasonsFollowedAction -> onUnfollowPreviousSeasonsFollowState(action)\n                is OpenEpisodeDetails -> openEpisodeDetails(action)\n            }\n        }\n\n        withState { state ->\n            observeShowFollowStatus(ObserveShowFollowStatus.Params(state.showId))\n            observeShowDetails(ObserveShowDetails.Params(state.showId))\n            observeShowImages(ObserveShowImages.Params(state.showId))\n            observeRelatedShows(ObserveRelatedShows.Params(state.showId))\n            observeShowSeasons(ObserveShowSeasonData.Params(state.showId))\n            observeNextEpisodeToWatch(ObserveShowNextEpisodeToWatch.Params(state.showId))\n            observeShowViewStats(ObserveShowViewStats.Params(state.showId))\n\n            if (state.openEpisodeUiEffect is PendingOpenEpisodeUiEffect) {\n                openEpisodeDetails(OpenEpisodeDetails(state.openEpisodeUiEffect.episodeId))\n            }\n        }\n\n        refresh(false)\n    }\n\n    private fun refresh(fromUserInteraction: Boolean) = withState {\n        updateShowDetails(UpdateShowDetails.Params(it.showId, fromUserInteraction)).also {\n            viewModelScope.launch {\n                loadingState.collectFrom(it)\n            }\n        }\n        updateShowImages(UpdateShowImages.Params(it.showId, fromUserInteraction)).also {\n            viewModelScope.launch {\n                loadingState.collectFrom(it)\n            }\n        }\n        updateRelatedShows(UpdateRelatedShows.Params(it.showId, fromUserInteraction)).also {\n            viewModelScope.launch {\n                loadingState.collectFrom(it)\n            }\n        }\n        updateShowSeasons(UpdateShowSeasonData.Params(it.showId, fromUserInteraction)).also {\n            viewModelScope.launch {\n                loadingState.collectFrom(it)\n            }\n        }\n    }\n\n    fun submitAction(action: ShowDetailsAction) {\n        viewModelScope.launch { pendingActions.send(action) }\n    }\n\n    private fun onToggleMyShowsButtonClicked() = withState {\n        changeShowFollowStatus(ChangeShowFollowStatus.Params(it.showId, TOGGLE)).also {\n            viewModelScope.launch {\n                loadingState.collectFrom(it)\n            }\n        }\n    }\n\n    private fun openEpisodeDetails(action: OpenEpisodeDetails) {\n        viewModelScope.launch {\n            val episode = getEpisode(GetEpisodeDetails.Params(action.episodeId))\n            if (episode != null) {\n                setState {\n                    copy(expandedSeasonIds = expandedSeasonIds + episode.seasonId,\n                        openEpisodeUiEffect = ExecutableOpenEpisodeUiEffect(action.episodeId, episode.seasonId))\n                }\n            }\n        }\n    }\n\n    fun clearExpandedEpisode() {\n        setState { copy(openEpisodeUiEffect = null) }\n    }\n\n    private fun onMarkSeasonWatched(action: MarkSeasonWatchedAction) {\n        changeSeasonWatchedStatus(Params(action.seasonId, Action.WATCHED, action.onlyAired, action.date))\n    }\n\n    private fun onMarkSeasonUnwatched(action: MarkSeasonUnwatchedAction) {\n        changeSeasonWatchedStatus(Params(action.seasonId, Action.UNWATCH))\n    }\n\n    private fun onChangeSeasonExpandState(action: ChangeSeasonExpandedAction) {\n        if (action.expanded) {\n            setState {\n                copy(focusedSeason = FocusSeasonUiEffect(action.seasonId),\n                    expandedSeasonIds = expandedSeasonIds + action.seasonId)\n            }\n        } else {\n            setState {\n                copy(expandedSeasonIds = expandedSeasonIds - action.seasonId)\n            }\n        }\n    }\n\n    fun clearFocusedSeason() {\n        setState { copy(focusedSeason = null) }\n    }\n\n    private fun onChangeSeasonFollowState(action: ChangeSeasonFollowedAction) {\n        changeSeasonFollowStatus(ChangeSeasonFollowStatus.Params(\n            action.seasonId,\n            when {\n                action.followed -> ChangeSeasonFollowStatus.Action.FOLLOW\n                else -> ChangeSeasonFollowStatus.Action.IGNORE\n            }\n        ))\n    }\n\n    private fun onUnfollowPreviousSeasonsFollowState(action: UnfollowPreviousSeasonsFollowedAction) {\n        changeSeasonFollowStatus(\n            ChangeSeasonFollowStatus.Params(action.seasonId,\n                ChangeSeasonFollowStatus.Action.IGNORE_PREVIOUS)\n        )\n    }\n\n    @AssistedInject.Factory\n    interface Factory {\n        fun create(initialState: ShowDetailsViewState): ShowDetailsFragmentViewModel\n    }\n\n    companion object : MvRxViewModelFactory<ShowDetailsFragmentViewModel, ShowDetailsViewState> {\n        override fun create(\n            viewModelContext: ViewModelContext,\n            state: ShowDetailsViewState\n        ): ShowDetailsFragmentViewModel? {\n            val f: ShowDetailsFragment = (viewModelContext as FragmentViewModelContext).fragment()\n            return f.showDetailsViewModelFactory.create(state).apply {\n                val args = f.requireArguments()\n\n                // If the fragment arguments contain an episode id, deep link into it\n                if (args.containsKey(\"episode_id\")) {\n                    submitAction(OpenEpisodeDetails(args.getLong(\"episode_id\")))\n                }\n            }\n        }\n\n        override fun initialState(\n            viewModelContext: ViewModelContext\n        ): ShowDetailsViewState? {\n            val f: ShowDetailsFragment = (viewModelContext as FragmentViewModelContext).fragment()\n            val args = f.requireArguments()\n            return ShowDetailsViewState(showId = args.getLong(\"show_id\"))\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails.details\n\nimport android.content.Context\nimport android.graphics.Color\nimport androidx.core.text.buildSpannedString\nimport androidx.core.text.color\nimport androidx.core.text.parseAsHtml\nimport androidx.emoji.text.EmojiCompat\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Genre\nimport app.tivi.data.entities.Season\nimport app.tivi.data.entities.ShowStatus\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.resultentities.SeasonWithEpisodesAndWatches\nimport app.tivi.data.views.FollowedShowsWatchStats\nimport app.tivi.inject.PerActivity\nimport app.tivi.ui.GenreStringer\nimport app.tivi.util.TiviDateFormatter\nimport java.util.Locale\nimport javax.inject.Inject\nimport org.threeten.bp.OffsetDateTime\nimport org.threeten.bp.ZoneId\nimport org.threeten.bp.ZonedDateTime\nimport org.threeten.bp.format.TextStyle\n\ninternal class ShowDetailsTextCreator @Inject constructor(\n    @PerActivity private val context: Context,\n    private val tiviDateFormatter: TiviDateFormatter\n) {\n    fun seasonSummaryText(season: SeasonWithEpisodesAndWatches): CharSequence {\n        val toWatch = season.numberAiredToWatch\n        val toAir = season.numberToAir\n        val watched = season.numberWatched\n\n        val text = StringBuilder()\n        if (watched > 0) {\n            text.append(context.getString(R.string.season_summary_watched, watched))\n        }\n        if (toWatch > 0) {\n            if (text.isNotEmpty()) {\n                text.append(\" \\u2022 \")\n            }\n            text.append(context.getString(R.string.season_summary_to_watch, toWatch))\n        }\n        if (toAir > 0) {\n            if (text.isNotEmpty()) {\n                text.append(\" \\u2022 \")\n            }\n            text.append(context.getString(R.string.season_summary_to_air, toAir))\n\n            val nextToAir = season.nextToAir\n            if (nextToAir != null) {\n                text.append(\". \")\n                text.append(context.getString(\n                    R.string.next_prefix,\n                    tiviDateFormatter.formatShortRelativeTime(nextToAir.firstAired)\n                ))\n            }\n        }\n        return text\n    }\n\n    fun seasonEpisodeTitleText(season: Season, episode: Episode): String {\n        return context.getString(R.string.season_episode_number, season.number, episode.number)\n    }\n\n    fun episodeNumberText(episode: Episode): CharSequence? {\n        val text = StringBuilder()\n        text.append(context.getString(R.string.episode_number, episode.number))\n        if (episode.firstAired?.isAfter(OffsetDateTime.now()) == true) {\n            text.append(\" \\u2022 \")\n            text.append(tiviDateFormatter.formatShortRelativeTime(episode.firstAired!!))\n        }\n        return text\n    }\n\n    fun genreString(genres: List<Genre>?): CharSequence? {\n        if (genres != null && genres.isNotEmpty()) {\n            val spanned = buildSpannedString {\n                for (i in genres.indices) {\n                    val genre = genres[i]\n                    append(context.getString(GenreStringer.getLabel(genre)))\n                    append(\"\\u00A0\") // nbsp\n                    color(Color.BLACK) {\n                        append(GenreStringer.getEmoji(genre))\n                    }\n                    if (i < genres.size - 1) append(\" \\u2022 \")\n                }\n            }\n\n            val emojiCompat = EmojiCompat.get()\n            return when {\n                emojiCompat.loadState == EmojiCompat.LOAD_STATE_SUCCEEDED -> emojiCompat.process(spanned)\n                else -> spanned\n            }\n        }\n        return null\n    }\n\n    fun genreContentDescription(genres: List<Genre>?): CharSequence? {\n        return genres?.joinToString(\", \") { context.getString(GenreStringer.getLabel(it)) }\n    }\n\n    fun followedShowEpisodeWatchStatus(stats: FollowedShowsWatchStats?): CharSequence {\n        return if (stats != null && stats.watchedEpisodeCount < stats.episodeCount) {\n            context.getString(R.string.followed_watch_stats_to_watch,\n                stats.episodeCount - stats.watchedEpisodeCount).parseAsHtml()\n        } else if (stats != null && stats.watchedEpisodeCount > 0) {\n            context.getString(R.string.followed_watch_stats_complete)\n        } else {\n            return \"\"\n        }\n    }\n\n    fun airsText(show: TiviShow): CharSequence? {\n        val airTime = show.airsTime\n        val airTz = show.airsTimeZone\n        val airDay = show.airsDay\n\n        if (airTime == null || airTz == null || airDay == null) {\n            // If we don't have all the necessary info, return null\n            return null\n        }\n\n        val local = ZonedDateTime.now()\n            .withZoneSameLocal(airTz)\n            .with(show.airsDay)\n            .with(airTime)\n            .withZoneSameInstant(ZoneId.systemDefault())\n\n        return context.getString(\n            R.string.airs_text,\n            local.dayOfWeek.getDisplayName(TextStyle.SHORT, Locale.getDefault()),\n            tiviDateFormatter.formatShortTime(local.toLocalTime())\n        )\n    }\n\n    fun showStatusText(status: ShowStatus): CharSequence = when (status) {\n        ShowStatus.CANCELED, ShowStatus.ENDED -> context.getString(R.string.status_ended)\n        ShowStatus.RETURNING -> context.getString(R.string.status_active)\n        ShowStatus.IN_PRODUCTION -> context.getString(R.string.status_in_production)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails.details\n\nimport android.content.Context\nimport android.view.MenuItem\nimport android.view.View\nimport androidx.appcompat.widget.PopupMenu\nimport androidx.core.view.forEach\nimport app.tivi.common.epoxy.HalfSpanOverride\nimport app.tivi.common.epoxy.TotalSpanOverride\nimport app.tivi.common.epoxy.tiviCarousel\nimport app.tivi.common.epoxy.withModelsFrom\nimport app.tivi.common.layouts.header\nimport app.tivi.common.layouts.vertSpacerSmall\nimport app.tivi.data.entities.ActionDate\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport app.tivi.data.entities.ShowStatus\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.entities.findHighestRatedPoster\nimport app.tivi.data.resultentities.RelatedShowEntryWithShow\nimport app.tivi.data.resultentities.SeasonWithEpisodesAndWatches\nimport app.tivi.data.views.FollowedShowsWatchStats\nimport app.tivi.extensions.observable\nimport app.tivi.inject.PerActivity\nimport app.tivi.showdetails.details.databinding.ViewHolderDetailsSeasonBinding\nimport app.tivi.ui.widget.PopupMenuButton\nimport com.airbnb.epoxy.Carousel\nimport com.airbnb.epoxy.EpoxyController\nimport com.airbnb.epoxy.EpoxyModel\nimport com.airbnb.epoxy.EpoxyModelGroup\nimport com.airbnb.mvrx.Async\nimport com.airbnb.mvrx.Success\nimport javax.inject.Inject\n\ninternal class ShowDetailsEpoxyController @Inject constructor(\n    @PerActivity private val context: Context,\n    private val textCreator: ShowDetailsTextCreator\n) : EpoxyController() {\n    var state by observable(ShowDetailsViewState(), ::requestModelBuild)\n    var callbacks: Callbacks? by observable(null, ::requestModelBuild)\n\n    interface Callbacks {\n        fun onRelatedShowClicked(show: TiviShow, itemView: View)\n        fun onEpisodeClicked(episode: Episode, itemView: View)\n        fun onMarkSeasonWatched(season: Season, onlyAired: Boolean, date: ActionDate)\n        fun onMarkSeasonUnwatched(season: Season)\n        fun onCollapseSeason(season: Season, itemView: View)\n        fun onExpandSeason(season: Season, itemView: View)\n        fun onMarkSeasonFollowed(season: Season)\n        fun onMarkSeasonIgnored(season: Season)\n        fun onMarkPreviousSeasonsIgnored(season: Season)\n    }\n\n    override fun buildModels() {\n        buildShowModels(state)\n\n        val episodeWithSeason = state.nextEpisodeToWatch()\n        if (episodeWithSeason?.episode != null) {\n            vertSpacerSmall {\n                id(\"next_episode_spacer\")\n                spanSizeOverride(TotalSpanOverride)\n            }\n            header {\n                id(\"next_episode_header\")\n                title(R.string.details_next_episode_to_watch)\n                spanSizeOverride(TotalSpanOverride)\n            }\n            detailsNextEpisodeToWatch {\n                id(\"next_episode_${episodeWithSeason.episode!!.id}\")\n                spanSizeOverride(TotalSpanOverride)\n                season(episodeWithSeason.season)\n                episode(episodeWithSeason.episode)\n                textCreator(textCreator)\n                clickListener { view ->\n                    callbacks?.onEpisodeClicked(episodeWithSeason.episode!!, view)\n                }\n            }\n        }\n\n        buildRelatedShowsModels(state.relatedShows)\n\n        buildSeasonsModels(state.viewStats, state.seasons, state.expandedSeasonIds)\n    }\n\n    private fun buildShowModels(state: ShowDetailsViewState) {\n        detailsPosterItem {\n            id(\"poster\")\n            posterImage(state.posterImage)\n            spanSizeOverride(HalfSpanOverride)\n        }\n\n        val show = state.show\n        val badges = ArrayList<EpoxyModel<*>>()\n        badges += DetailsInfoRatingBindingModel_().apply {\n            id(\"rating\")\n            tiviShow(show)\n        }\n        if (show.network != null) {\n            badges += DetailsInfoNetworkBindingModel_().apply {\n                id(\"network\")\n                tiviShow(show)\n            }\n        }\n        if (show.certification != null) {\n            badges += DetailsInfoCertBindingModel_().apply {\n                id(\"cert\")\n                tiviShow(show)\n            }\n        }\n        if (show.runtime != null) {\n            badges += DetailsInfoRuntimeBindingModel_().apply {\n                id(\"runtime\")\n                tiviShow(show)\n            }\n        }\n        if (show.status != null && show.status != ShowStatus.RETURNING) {\n            badges += DetailsInfoStatusBindingModel_().apply {\n                id(\"status\")\n                tiviShow(show)\n                textCreator(textCreator)\n            }\n        }\n        if (show.airsTime != null && show.airsDay != null && show.airsTimeZone != null &&\n            (show.status == null || show.status == ShowStatus.RETURNING)) {\n            badges += DetailsInfoAirsBindingModel_().apply {\n                id(\"airs\")\n                tiviShow(show)\n                textCreator(textCreator)\n            }\n        }\n        if (badges.isNotEmpty()) {\n            EpoxyModelGroup(R.layout.layout_show_details_info_holder, badges)\n                .addTo(this)\n        }\n\n        vertSpacerSmall {\n            id(\"about_show_spacer\")\n            spanSizeOverride(TotalSpanOverride)\n        }\n        header {\n            id(\"about_show_header\")\n            title(R.string.details_about)\n            spanSizeOverride(TotalSpanOverride)\n        }\n        detailsSummary {\n            id(\"summary\")\n            entity(show)\n            spanSizeOverride(TotalSpanOverride)\n        }\n        if (show.genres.isNotEmpty()) {\n            detailsGenres {\n                id(\"genres\")\n                tiviShow(show)\n                textCreator(textCreator)\n                spanSizeOverride(TotalSpanOverride)\n            }\n        }\n    }\n\n    private fun buildRelatedShowsModels(relatedShows: Async<List<RelatedShowEntryWithShow>>) {\n        if (relatedShows is Success) {\n            val related = relatedShows()\n            if (related.isNotEmpty()) {\n                vertSpacerSmall {\n                    id(\"related_spacer\")\n                    spanSizeOverride(TotalSpanOverride)\n                }\n                header {\n                    id(\"related_header\")\n                    title(R.string.details_related)\n                    spanSizeOverride(TotalSpanOverride)\n                }\n                tiviCarousel {\n                    id(\"related_shows\")\n                    itemWidth(context.resources.getDimensionPixelSize(R.dimen.related_shows_item_width))\n                    hasFixedSize(true)\n                    spanSizeOverride(TotalSpanOverride)\n\n                    val vert = context.resources.getDimensionPixelSize(R.dimen.spacing_small)\n                    val horiz = context.resources.getDimensionPixelSize(R.dimen.spacing_normal)\n                    val itemSpacing = context.resources.getDimensionPixelSize(R.dimen.spacing_micro)\n                    padding(Carousel.Padding(horiz, vert, horiz, vert, itemSpacing))\n\n                    withModelsFrom(related) { relatedEntry ->\n                        val relatedShow = relatedEntry.show\n                        DetailsRelatedItemBindingModel_()\n                            .id(\"related_${relatedShow.id}\")\n                            .tiviShow(relatedShow)\n                            .posterImage(relatedEntry.images.findHighestRatedPoster())\n                            .clickListener { view -> callbacks?.onRelatedShowClicked(relatedShow, view) }\n                    }\n                }\n            }\n        }\n    }\n\n    private fun buildSeasonsModels(\n        asyncStats: Async<FollowedShowsWatchStats>,\n        asyncSeasons: Async<List<SeasonWithEpisodesAndWatches>>,\n        expandedSeasonIds: Set<Long>\n    ) {\n        val stats = asyncStats()\n        if (stats != null) {\n            vertSpacerSmall {\n                id(\"view_stats_spacer\")\n                spanSizeOverride(TotalSpanOverride)\n            }\n            header {\n                id(\"view_stats_header\")\n                title(R.string.details_view_stats)\n                spanSizeOverride(TotalSpanOverride)\n            }\n            detailsStats {\n                id(\"view_stats\")\n                stats(stats)\n                textCreator(textCreator)\n                spanSizeOverride(TotalSpanOverride)\n            }\n        }\n\n        if (asyncSeasons is Success) {\n            val seasons = asyncSeasons()\n            if (seasons.isNotEmpty()) {\n                vertSpacerSmall {\n                    id(\"seasons_spacer\")\n                    spanSizeOverride(TotalSpanOverride)\n                }\n                header {\n                    id(\"seasons_header\")\n                    title(R.string.show_details_seasons)\n                    spanSizeOverride(TotalSpanOverride)\n                }\n\n                for (season in seasons) {\n                    val expanded = expandedSeasonIds.contains(season.season.id)\n\n                    detailsSeason {\n                        id(generateSeasonItemId(season.season.id))\n                        season(season)\n                        spanSizeOverride(TotalSpanOverride)\n                        textCreator(textCreator)\n                        expanded(expanded)\n                        clickListener { model, _, clickedView, _ ->\n                            if (model.expanded()) {\n                                callbacks?.onCollapseSeason(season.season, clickedView)\n                            } else {\n                                callbacks?.onExpandSeason(season.season, clickedView)\n                            }\n                        }\n                        popupMenuListener(SeasonPopupMenuListener(season))\n                        popupMenuClickListener(SeasonPopupClickListener(season.season))\n\n                        onBind { _, view, _ ->\n                            val binding = view.dataBinding as ViewHolderDetailsSeasonBinding\n                            val listener = binding.popupMenuListener as SeasonPopupMenuListener\n                            listener.season = binding.season!!\n                        }\n                    }\n\n                    if (expanded) {\n                        season.episodes.forEach { episodeWithWatches ->\n                            detailsSeasonEpisode {\n                                val episode = episodeWithWatches.episode!!\n                                id(generateEpisodeItemId(episode.id))\n                                textCreator(textCreator)\n                                episodeWithWatches(episodeWithWatches)\n                                expanded(true)\n                                spanSizeOverride(TotalSpanOverride)\n                                clickListener { view -> callbacks?.onEpisodeClicked(episode, view) }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private class SeasonPopupMenuListener(\n        var season: SeasonWithEpisodesAndWatches\n    ) : PopupMenuButton.PopupMenuListener {\n        override fun onPreparePopupMenu(popupMenu: PopupMenu) {\n            popupMenu.menu.forEach { item ->\n                when (item.itemId) {\n                    R.id.season_stats_ignore -> {\n                        item.isVisible = !season.season.ignored\n                    }\n                    R.id.season_stats_ignore_previous -> {\n                        item.isVisible = (season.season.number ?: -1) >= 2\n                    }\n                    R.id.season_stats_include -> {\n                        item.isVisible = season.season.ignored\n                    }\n                    R.id.season_mark_all_unwatched -> {\n                        item.isVisible = season.numberWatched > 0\n                    }\n                    R.id.season_mark_watched_all -> {\n                        item.isVisible = season.numberWatched < season.numberEpisodes\n                    }\n                    R.id.season_mark_watched_aired -> {\n                        item.isVisible = season.numberWatched < season.numberAired &&\n                            season.numberAired < season.numberEpisodes\n                    }\n                }\n            }\n        }\n    }\n\n    private inner class SeasonPopupClickListener(\n        var season: Season\n    ) : PopupMenu.OnMenuItemClickListener {\n        override fun onMenuItemClick(item: MenuItem): Boolean {\n            when (item.itemId) {\n                R.id.season_mark_all_watched_now -> {\n                    callbacks?.onMarkSeasonWatched(season, false, ActionDate.NOW)\n                }\n                R.id.season_mark_all_watched_air_date -> {\n                    callbacks?.onMarkSeasonWatched(season, false, ActionDate.AIR_DATE)\n                }\n                R.id.season_mark_aired_watched_now -> {\n                    callbacks?.onMarkSeasonWatched(season, true, ActionDate.NOW)\n                }\n                R.id.season_mark_aired_watched_air_date -> {\n                    callbacks?.onMarkSeasonWatched(season, true, ActionDate.AIR_DATE)\n                }\n                R.id.season_mark_all_unwatched -> {\n                    callbacks?.onMarkSeasonUnwatched(season)\n                }\n                R.id.season_stats_ignore -> {\n                    callbacks?.onMarkSeasonIgnored(season)\n                }\n                R.id.season_stats_include -> {\n                    callbacks?.onMarkSeasonFollowed(season)\n                }\n                R.id.season_stats_ignore_previous -> {\n                    callbacks?.onMarkPreviousSeasonsIgnored(season)\n                }\n            }\n            return true\n        }\n    }\n\n    fun clear() {\n        callbacks = null\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails.details\n\nimport com.airbnb.epoxy.IdUtils\n\ninternal fun generateSeasonItemId(seasonId: Long): Long = IdUtils.hashString64Bit(\"season_$seasonId\")\ninternal fun generateEpisodeItemId(episodeId: Long): Long = IdUtils.hashString64Bit(\"episode_$episodeId\")",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.showdetails.details\n\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.activity.OnBackPressedCallback\nimport androidx.constraintlayout.motion.widget.MotionLayout\nimport androidx.core.net.toUri\nimport androidx.fragment.app.FragmentTransaction\nimport androidx.fragment.app.commit\nimport androidx.fragment.app.commitNow\nimport androidx.lifecycle.lifecycleScope\nimport androidx.navigation.fragment.findNavController\nimport app.tivi.TiviFragmentWithBinding\nimport app.tivi.common.epoxy.syncSpanSizes\nimport app.tivi.data.entities.ActionDate\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.episodedetails.EpisodeDetailsFragment\nimport app.tivi.extensions.awaitItemIdExists\nimport app.tivi.extensions.awaitLayout\nimport app.tivi.extensions.awaitScrollEnd\nimport app.tivi.extensions.awaitTransitionComplete\nimport app.tivi.extensions.findItemIdPosition\nimport app.tivi.extensions.resolveThemeColor\nimport app.tivi.extensions.scheduleStartPostponedTransitions\nimport app.tivi.extensions.sharedElementHelperOf\nimport app.tivi.extensions.smoothScrollToItemPosition\nimport app.tivi.extensions.toActivityNavigatorExtras\nimport app.tivi.extensions.updateConstraintSets\nimport app.tivi.showdetails.details.databinding.FragmentShowDetailsBinding\nimport com.airbnb.mvrx.fragmentViewModel\nimport com.airbnb.mvrx.withState\nimport dev.chrisbanes.insetter.doOnApplyWindowInsets\nimport javax.inject.Inject\nimport kotlinx.coroutines.launch\nimport me.saket.inboxrecyclerview.dimming.TintPainter\nimport me.saket.inboxrecyclerview.page.PageStateChangeCallbacks\n\nclass ShowDetailsFragment : TiviFragmentWithBinding<FragmentShowDetailsBinding>() {\n    private val viewModel: ShowDetailsFragmentViewModel by fragmentViewModel()\n\n    @Inject internal lateinit var showDetailsViewModelFactory: ShowDetailsFragmentViewModel.Factory\n    @Inject internal lateinit var controller: ShowDetailsEpoxyController\n    @Inject internal lateinit var textCreator: ShowDetailsTextCreator\n\n    private val backPressedCallback = object : OnBackPressedCallback(false) {\n        override fun handleOnBackPressed() {\n            requireBinding().detailsRv.collapse()\n        }\n    }\n\n    override fun createBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): FragmentShowDetailsBinding {\n        return FragmentShowDetailsBinding.inflate(inflater, container, false)\n    }\n\n    override fun onViewCreated(binding: FragmentShowDetailsBinding, savedInstanceState: Bundle?) {\n        binding.textCreator = textCreator\n\n        binding.detailsMotion.doOnApplyWindowInsets { v, insets, _ ->\n            (v as MotionLayout).updateConstraintSets {\n                constrainHeight(R.id.details_status_bar_anchor, insets.systemWindowInsetTop)\n            }\n        }\n\n        binding.detailsFollowFab.setOnClickListener {\n            viewModel.submitAction(FollowShowToggleAction)\n        }\n\n        binding.detailsToolbar.setNavigationOnClickListener {\n            findNavController().navigateUp() || requireActivity().onNavigateUp()\n        }\n\n        binding.detailsToolbar.setOnMenuItemClickListener {\n            when (it.itemId) {\n                R.id.menu_refresh -> {\n                    viewModel.submitAction(RefreshAction)\n                    true\n                }\n                else -> false\n            }\n        }\n\n        viewModel.selectSubscribe(\n            viewLifecycleOwner,\n            ShowDetailsViewState::focusedSeason,\n            deliveryMode = uniqueOnly()\n        ) { focusedSeason ->\n            if (focusedSeason != null) {\n                viewLifecycleOwner.lifecycleScope.launch {\n                    val seasonItemId = generateSeasonItemId(focusedSeason.seasonId)\n                    val seasonItemPosition = controller.adapter.awaitItemIdExists(seasonItemId)\n                    binding.detailsRv.smoothScrollToItemPosition(seasonItemPosition)\n                }\n                viewModel.clearFocusedSeason()\n            }\n        }\n\n        viewModel.selectSubscribe(\n            viewLifecycleOwner,\n            ShowDetailsViewState::openEpisodeUiEffect,\n            deliveryMode = uniqueOnly()\n        ) { expandedEpisode ->\n            if (expandedEpisode is ExecutableOpenEpisodeUiEffect) {\n                // We can add the fragment to the pane now while waiting for any animations/\n                // scrolling to happen\n                val episodeFragment = EpisodeDetailsFragment.create(expandedEpisode.episodeId)\n                childFragmentManager.commitNow {\n                    setTransition(FragmentTransaction.TRANSIT_NONE)\n                    replace(R.id.details_expanded_pane, episodeFragment)\n                }\n\n                viewLifecycleOwner.lifecycleScope.launch {\n                    val seasonItemId = generateSeasonItemId(expandedEpisode.seasonId)\n                    val episodeItemId = generateEpisodeItemId(expandedEpisode.episodeId)\n\n                    binding.detailsMotion.transitionToState(R.id.show_details_closed)\n                    binding.detailsMotion.awaitTransitionComplete(R.id.show_details_closed)\n\n                    controller.adapter.awaitItemIdExists(episodeItemId)\n                    val seasonItemPosition = controller.adapter.findItemIdPosition(seasonItemId)\n\n                    binding.detailsRv.smoothScrollToItemPosition(seasonItemPosition)\n                    binding.detailsRv.awaitScrollEnd()\n\n                    episodeFragment.requireView().awaitLayout()\n                    binding.detailsRv.expandItem(episodeItemId)\n                }\n\n                viewModel.clearExpandedEpisode()\n            }\n        }\n\n        controller.callbacks = object : ShowDetailsEpoxyController.Callbacks {\n            override fun onRelatedShowClicked(show: TiviShow, itemView: View) {\n                findNavController().navigate(\n                    \"app.tivi://show/${show.id}\".toUri(),\n                    null,\n                    sharedElementHelperOf(itemView to \"poster\")\n                        .toActivityNavigatorExtras(requireActivity()))\n            }\n\n            override fun onEpisodeClicked(episode: Episode, itemView: View) {\n                viewModel.submitAction(OpenEpisodeDetails(episode.id))\n            }\n\n            override fun onMarkSeasonUnwatched(season: Season) {\n                viewModel.submitAction(MarkSeasonUnwatchedAction(season.id))\n            }\n\n            override fun onMarkSeasonWatched(season: Season, onlyAired: Boolean, date: ActionDate) {\n                viewModel.submitAction(MarkSeasonWatchedAction(season.id, onlyAired, date))\n            }\n\n            override fun onExpandSeason(season: Season, itemView: View) {\n                viewModel.submitAction(ChangeSeasonExpandedAction(season.id, true))\n            }\n\n            override fun onCollapseSeason(season: Season, itemView: View) {\n                viewModel.submitAction(ChangeSeasonExpandedAction(season.id, false))\n            }\n\n            override fun onMarkSeasonFollowed(season: Season) {\n                viewModel.submitAction(ChangeSeasonFollowedAction(season.id, true))\n            }\n\n            override fun onMarkSeasonIgnored(season: Season) {\n                viewModel.submitAction(ChangeSeasonFollowedAction(season.id, false))\n            }\n\n            override fun onMarkPreviousSeasonsIgnored(season: Season) {\n                viewModel.submitAction(UnfollowPreviousSeasonsFollowedAction(season.id))\n            }\n        }\n\n        binding.detailsRv.apply {\n            adapter = controller.adapter\n            syncSpanSizes(controller)\n            setHasFixedSize(true)\n\n            tintPainter = TintPainter.completeList(\n                context.resolveThemeColor(R.attr.colorSurface),\n                opacity = 0.7f\n            )\n            expandablePage = binding.detailsExpandedPane\n        }\n\n        // Add a listener to enabled/disable the back press callback, depending on the expanded\n        // pane state\n        binding.detailsExpandedPane.addStateChangeCallbacks(object : PageStateChangeCallbacks {\n            override fun onPageAboutToCollapse(collapseAnimDuration: Long) {}\n\n            override fun onPageAboutToExpand(expandAnimDuration: Long) {}\n\n            override fun onPageCollapsed() {\n                backPressedCallback.isEnabled = false\n\n                // Remove the episode details fragment to free-up resources\n                val episodeFrag = childFragmentManager.findFragmentById(R.id.details_expanded_pane)\n                if (episodeFrag != null) {\n                    childFragmentManager.commit {\n                        setTransition(FragmentTransaction.TRANSIT_NONE)\n                        remove(episodeFrag)\n                    }\n                }\n\n                // Re-enable MotionLayout's motion handling\n                binding.detailsMotion.isInteractionEnabled = true\n            }\n\n            override fun onPageExpanded() {\n                backPressedCallback.isEnabled = true\n                // Disable MotionLayout's motion handling while the pane is expanded\n                binding.detailsMotion.isInteractionEnabled = false\n                binding.detailsMotion.requestLayout()\n            }\n        })\n\n        requireActivity().onBackPressedDispatcher.addCallback(this, backPressedCallback)\n    }\n\n    override fun invalidate(binding: FragmentShowDetailsBinding) = withState(viewModel) { state ->\n        if (binding.state == null) {\n            // First time we've had state, start any postponed transitions\n            scheduleStartPostponedTransitions()\n        }\n        binding.state = state\n        controller.state = state\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        controller.clear()\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\nimport android.annotation.SuppressLint\nimport android.os.Bundle\nimport android.view.ActionMode\nimport android.view.LayoutInflater\nimport android.view.ViewGroup\nimport androidx.core.view.updatePadding\nimport androidx.lifecycle.lifecycleScope\nimport androidx.navigation.fragment.findNavController\nimport androidx.navigation.ui.AppBarConfiguration\nimport androidx.recyclerview.widget.DefaultItemAnimator\nimport app.tivi.TiviFragmentWithBinding\nimport app.tivi.api.UiError\nimport app.tivi.api.UiLoading\nimport app.tivi.common.entrygrid.R\nimport app.tivi.common.entrygrid.databinding.FragmentEntryGridBinding\nimport app.tivi.data.Entry\nimport app.tivi.data.resultentities.EntryWithShow\nimport app.tivi.extensions.doOnSizeChange\nimport app.tivi.extensions.postponeEnterTransitionWithTimeout\nimport app.tivi.extensions.scheduleStartPostponedTransitions\nimport app.tivi.ui.ProgressTimeLatch\nimport app.tivi.ui.SpacingItemDecorator\nimport app.tivi.ui.transitions.GridToGridTransitioner\nimport com.airbnb.mvrx.withState\nimport com.google.android.material.snackbar.Snackbar\nimport javax.inject.Inject\nimport kotlinx.coroutines.flow.collect\n\n@SuppressLint(\"ValidFragment\")\nabstract class EntryGridFragment<LI, VM> : TiviFragmentWithBinding<FragmentEntryGridBinding>()\n    where LI : EntryWithShow<out Entry>, VM : EntryViewModel<LI, *> {\n    protected abstract val viewModel: VM\n\n    private lateinit var swipeRefreshLatch: ProgressTimeLatch\n    private lateinit var controller: EntryGridEpoxyController<LI>\n\n    @Inject lateinit var appBarConfiguration: AppBarConfiguration\n\n    private var currentActionMode: ActionMode? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        controller = createController()\n\n        GridToGridTransitioner.setupSecondFragment(this, R.id.grid_appbar) {\n            requireBinding().gridRecyclerview.itemAnimator = DefaultItemAnimator()\n        }\n    }\n\n    override fun createBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): FragmentEntryGridBinding {\n        return FragmentEntryGridBinding.inflate(inflater, container, false)\n    }\n\n    override fun onViewCreated(binding: FragmentEntryGridBinding, savedInstanceState: Bundle?) {\n        postponeEnterTransitionWithTimeout()\n\n        swipeRefreshLatch = ProgressTimeLatch(minShowTime = 1350) {\n            binding.gridSwipeRefresh.isRefreshing = it\n        }\n\n        binding.gridToolbar.setNavigationOnClickListener {\n            findNavController().navigateUp()\n        }\n\n        binding.gridAppbar.doOnSizeChange {\n            binding.gridRecyclerview.updatePadding(top = it.height)\n            binding.gridSwipeRefresh.setProgressViewOffset(true, 0,\n                it.height + binding.gridSwipeRefresh.progressCircleDiameter / 2)\n            true\n        }\n\n        binding.gridRecyclerview.apply {\n            // We set the item animator to null since it can interfere with the enter/shared element\n            // transitions\n            itemAnimator = null\n\n            setController(controller)\n            addItemDecoration(SpacingItemDecorator(paddingLeft))\n        }\n\n        binding.gridSwipeRefresh.setOnRefreshListener(viewModel::refresh)\n\n        lifecycleScope.launchWhenStarted {\n            viewModel.pagedList.collect { controller.submitList(it) }\n        }\n    }\n\n    override fun invalidate(binding: FragmentEntryGridBinding) = withState(viewModel) { state ->\n        controller.state = state\n\n        when (val status = state.status) {\n            is UiError -> {\n                swipeRefreshLatch.refreshing = false\n                Snackbar.make(requireView(),\n                    status.exception?.localizedMessage\n                        ?: getString(R.string.error_generic),\n                    Snackbar.LENGTH_SHORT\n                ).show()\n            }\n            is UiLoading -> swipeRefreshLatch.refreshing = status.fullRefresh\n            else -> swipeRefreshLatch.refreshing = false\n        }\n\n        if (state.selectionOpen && currentActionMode == null) {\n            currentActionMode = startSelectionActionMode()\n        } else if (!state.selectionOpen) {\n            currentActionMode?.finish()\n            currentActionMode = null\n        }\n\n        if (currentActionMode != null) {\n            currentActionMode?.title = getString(R.string.selection_title,\n                state.selectedShowIds.size)\n        }\n\n        if (state.isLoaded) {\n            // First time we've had state, start any postponed transitions\n            scheduleStartPostponedTransitions()\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n\n        currentActionMode?.finish()\n        currentActionMode = null\n    }\n\n    abstract fun startSelectionActionMode(): ActionMode?\n\n    abstract fun createController(): EntryGridEpoxyController<LI>\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\nimport androidx.lifecycle.viewModelScope\nimport androidx.paging.PagedList\nimport app.tivi.TiviMvRxViewModel\nimport app.tivi.api.UiError\nimport app.tivi.api.UiIdle\nimport app.tivi.api.UiLoading\nimport app.tivi.api.UiStatus\nimport app.tivi.api.UiSuccess\nimport app.tivi.base.InvokeError\nimport app.tivi.base.InvokeStarted\nimport app.tivi.base.InvokeStatus\nimport app.tivi.base.InvokeSuccess\nimport app.tivi.base.InvokeTimeout\nimport app.tivi.data.Entry\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.resultentities.EntryWithShow\nimport app.tivi.domain.PagingInteractor\nimport app.tivi.domain.interactors.ChangeShowFollowStatus\nimport kotlinx.coroutines.channels.ConflatedBroadcastChannel\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.asFlow\nimport kotlinx.coroutines.flow.catch\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.map\nimport kotlinx.coroutines.launch\n\nabstract class EntryViewModel<LI : EntryWithShow<out Entry>, PI : PagingInteractor<*, LI>>(\n    initialState: EntryViewState,\n    private val pageSize: Int = 21\n) : TiviMvRxViewModel<EntryViewState>(initialState) {\n    protected abstract val dispatchers: AppCoroutineDispatchers\n    protected abstract val pagingInteractor: PI\n    protected abstract val logger: Logger\n    protected abstract val changeShowFollowStatus: ChangeShowFollowStatus\n\n    private val messages = ConflatedBroadcastChannel<UiStatus>(UiIdle)\n    private val loaded = ConflatedBroadcastChannel(false)\n\n    val pagedList: Flow<PagedList<LI>>\n        get() = pagingInteractor.observe()\n\n    private val showSelection = ShowStateSelector()\n\n    protected val pageListConfig = PagedList.Config.Builder().run {\n        setPageSize(pageSize * 3)\n        setPrefetchDistance(pageSize)\n        setEnablePlaceholders(false)\n        build()\n    }\n\n    protected val boundaryCallback = object : PagedList.BoundaryCallback<LI>() {\n        override fun onItemAtEndLoaded(itemAtEnd: LI) = onListScrolledToEnd()\n\n        override fun onItemAtFrontLoaded(itemAtFront: LI) {\n            loaded.offer(true)\n        }\n\n        override fun onZeroItemsLoaded() {\n            loaded.offer(true)\n        }\n    }\n\n    protected fun launchObserves() {\n        viewModelScope.launch {\n            messages.asFlow().execute {\n                copy(status = it() ?: UiSuccess)\n            }\n        }\n\n        viewModelScope.launch {\n            loaded.asFlow().execute {\n                copy(isLoaded = it() ?: false)\n            }\n        }\n\n        viewModelScope.launch {\n            showSelection.observeIsSelectionOpen().execute {\n                copy(selectionOpen = it() ?: false)\n            }\n        }\n\n        viewModelScope.launch {\n            showSelection.observeSelectedShowIds().execute {\n                copy(selectedShowIds = it() ?: emptySet())\n            }\n        }\n    }\n\n    fun onListScrolledToEnd() {\n        callLoadMore().also {\n            viewModelScope.launch {\n                it.catch {\n                    messages.send(UiError(it))\n                }.map {\n                    when (it) {\n                        InvokeSuccess -> UiSuccess\n                        InvokeStarted -> UiLoading(false)\n                        is InvokeError -> UiError(it.throwable)\n                        InvokeTimeout -> UiError()\n                        else -> UiIdle\n                    }\n                }.collect {\n                    messages.send(it)\n                }\n            }\n        }\n    }\n\n    fun refresh() = refresh(true)\n\n    fun clearSelection() {\n        showSelection.clearSelection()\n    }\n\n    fun onItemClick(show: TiviShow): Boolean {\n        return showSelection.onItemClick(show)\n    }\n\n    fun onItemLongClick(show: TiviShow): Boolean {\n        return showSelection.onItemLongClick(show)\n    }\n\n    fun followSelectedShows() {\n        changeShowFollowStatus(\n            ChangeShowFollowStatus.Params(\n                showSelection.getSelectedShowIds(),\n                ChangeShowFollowStatus.Action.FOLLOW,\n                deferDataFetch = true\n            )\n        )\n        showSelection.clearSelection()\n    }\n\n    protected fun refresh(fromUser: Boolean) {\n        callRefresh(fromUser).also {\n            viewModelScope.launch {\n                it.catch {\n                    messages.send(UiError(it))\n                }.map {\n                    when (it) {\n                        InvokeSuccess -> UiSuccess\n                        InvokeStarted -> UiLoading(true)\n                        InvokeTimeout -> UiError()\n                        else -> UiIdle\n                    }\n                }.collect {\n                    messages.send(it)\n                }\n            }\n        }\n    }\n\n    protected abstract fun callRefresh(fromUser: Boolean): Flow<InvokeStatus>\n\n    protected abstract fun callLoadMore(): Flow<InvokeStatus>\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\nimport app.tivi.api.UiIdle\nimport app.tivi.api.UiStatus\nimport com.airbnb.mvrx.MvRxState\n\ndata class EntryViewState(\n    val status: UiStatus = UiIdle,\n    val isLoaded: Boolean = false,\n    val selectionOpen: Boolean = false,\n    val selectedShowIds: Set<Long> = emptySet()\n) : MvRxState",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\nimport app.tivi.api.UiLoading\nimport app.tivi.common.epoxy.TotalSpanOverride\nimport app.tivi.common.layouts.PosterGridItemBindingModel_\nimport app.tivi.common.layouts.emptyState\nimport app.tivi.common.layouts.infiniteLoading\nimport app.tivi.common.layouts.vertSpacerSmall\nimport app.tivi.data.Entry\nimport app.tivi.data.resultentities.EntryWithShow\nimport app.tivi.extensions.observable\nimport com.airbnb.epoxy.EpoxyModel\nimport com.airbnb.epoxy.paging.PagedListEpoxyController\n\nabstract class EntryGridEpoxyController<LI : EntryWithShow<out Entry>> :\n    PagedListEpoxyController<LI>() {\n    var state: EntryViewState by observable(EntryViewState(), ::requestModelBuild)\n\n    @Suppress(\"UselessCallOnCollection\")\n    override fun addModels(models: List<EpoxyModel<*>>) {\n        if (models.isNotEmpty()) {\n            vertSpacerSmall {\n                id(\"top_spacer\")\n                spanSizeOverride(TotalSpanOverride)\n            }\n\n            super.addModels(models)\n\n            vertSpacerSmall {\n                id(\"bottom_spacer\")\n                spanSizeOverride(TotalSpanOverride)\n            }\n        } else {\n            emptyState {\n                id(\"item_placeholder\")\n                spanSizeOverride(TotalSpanOverride)\n            }\n        }\n\n        val status = state.status\n        if (status is UiLoading && !status.fullRefresh) {\n            infiniteLoading {\n                id(\"loading_view\")\n                spanSizeOverride(TotalSpanOverride)\n            }\n        }\n    }\n\n    override fun buildItemModel(currentPosition: Int, item: LI?): EpoxyModel<*> {\n        return if (item != null) buildItemModel(item) else buildItemPlaceholder(currentPosition)\n    }\n\n    protected abstract fun buildItemModel(item: LI): EpoxyModel<*>\n\n    protected open fun buildItemPlaceholder(index: Int): PosterGridItemBindingModel_ {\n        return PosterGridItemBindingModel_()\n            .id(\"placeholder_$index\")\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.utils\n\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.Success\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.repositories.showimages.ShowImagesDataSource\nimport app.tivi.data.repositories.shows.ShowDataSource\n\nobject SuccessFakeShowDataSource : ShowDataSource {\n    override suspend fun getShow(show: TiviShow): Result<TiviShow> {\n        return Success(show)\n    }\n}\n\nobject SuccessFakeShowImagesDataSource : ShowImagesDataSource {\n    override suspend fun getShowImages(show: TiviShow): Result<List<ShowTmdbImage>> {\n        return Success(listOf(showPoster))\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.utils\n\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\nimport androidx.room.TypeConverters\nimport app.tivi.data.TiviDatabase\nimport app.tivi.data.TiviTypeConverters\nimport app.tivi.data.daos.ShowFtsDao\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.entities.FollowedShowEntry\nimport app.tivi.data.entities.LastRequest\nimport app.tivi.data.entities.PopularShowEntry\nimport app.tivi.data.entities.RecommendedShowEntry\nimport app.tivi.data.entities.RelatedShowEntry\nimport app.tivi.data.entities.Season\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.entities.TraktUser\nimport app.tivi.data.entities.TrendingShowEntry\nimport app.tivi.data.entities.WatchedShowEntry\nimport app.tivi.data.resultentities.ShowDetailed\nimport app.tivi.data.views.FollowedShowsLastWatched\nimport app.tivi.data.views.FollowedShowsNextToWatch\nimport app.tivi.data.views.FollowedShowsWatchStats\n\n@Database(\n    entities = [\n        TiviShow::class,\n        TrendingShowEntry::class,\n        PopularShowEntry::class,\n        TraktUser::class,\n        WatchedShowEntry::class,\n        FollowedShowEntry::class,\n        Season::class,\n        Episode::class,\n        RelatedShowEntry::class,\n        EpisodeWatchEntry::class,\n        LastRequest::class,\n        ShowTmdbImage::class,\n        RecommendedShowEntry::class,\n        FakeTiviShowFts::class\n    ],\n    views = [\n        FollowedShowsWatchStats::class,\n        FollowedShowsLastWatched::class,\n        FollowedShowsNextToWatch::class\n    ],\n    version = 1,\n    exportSchema = false\n)\n@TypeConverters(TiviTypeConverters::class)\nabstract class TiviTestDatabase : RoomDatabase(), TiviDatabase {\n    override fun showFtsDao(): ShowFtsDao = object : ShowFtsDao() {\n        override suspend fun search(filter: String): List<ShowDetailed> {\n            return emptyList()\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.utils\n\nimport app.tivi.data.TiviDatabase\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.entities.FollowedShowEntry\nimport app.tivi.data.entities.ImageType\nimport app.tivi.data.entities.PendingAction\nimport app.tivi.data.entities.Season\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport org.threeten.bp.OffsetDateTime\nimport org.threeten.bp.ZoneOffset\n\nconst val showId = 1L\nval show = TiviShow(id = showId, title = \"Down Under\", traktId = 243)\n\nconst val show2Id = 2L\nval show2 = TiviShow(id = show2Id, title = \"G'day mate\", traktId = 546)\n\ninternal suspend fun insertShow(db: TiviDatabase) = db.showDao().insert(show)\n\ninternal suspend fun deleteShow(db: TiviDatabase) = db.showDao().deleteEntity(show)\n\nconst val s1_id = 1L\nval s1 = Season(\n    id = s1_id,\n    showId = showId,\n    title = \"Season 1\",\n    number = 1,\n    traktId = 5443\n)\n\nconst val s2_id = 2L\nval s2 = Season(\n    id = s2_id,\n    showId = showId,\n    title = \"Season 2\",\n    number = 2,\n    traktId = 5434\n)\n\nconst val s0_id = 3L\nval s0 = Season(\n    id = s0_id,\n    showId = showId,\n    title = \"Specials\",\n    number = Season.NUMBER_SPECIALS,\n    traktId = 7042\n)\n\nprivate val s1e1AirDate = OffsetDateTime.of(2000, 7, 1, 18, 0, 0, 0, ZoneOffset.UTC)\n\nval s1e1 = Episode(id = 1, title = \"Kangaroo Court\", seasonId = s1.id, number = 0, traktId = 59830, firstAired = s1e1AirDate)\nval s1e2 = Episode(id = 2, title = \"Bushtucker\", seasonId = s1.id, number = 1, traktId = 33435, firstAired = s1e1AirDate.plusWeeks(1))\nval s1e3 = Episode(id = 3, title = \"Wallaby Bungee\", seasonId = s1.id, number = 2, traktId = 44542, firstAired = s1e1AirDate.plusWeeks(2))\n\nval s2e1 = Episode(id = 4, title = \"Noosa Pool\", seasonId = s2.id, number = 0, traktId = 5656, firstAired = s1e1AirDate.plusWeeks(3))\nval s2e2 = Episode(id = 5, title = \"Alice Springer\", seasonId = s2.id, number = 1, traktId = 8731, firstAired = s1e1AirDate.plusWeeks(4))\n\nval s1_episodes = listOf(s1e1, s1e2, s1e3)\nval s2_episodes = listOf(s2e1, s2e2)\n\nconst val s1e1w_id = 1L\nval s1e1w = EpisodeWatchEntry(\n    id = s1e1w_id,\n    watchedAt = OffsetDateTime.now(),\n    episodeId = s1e1.id,\n    traktId = 435214\n)\n\nconst val s1e1w2_id = 2L\nval s1e1w2 = s1e1w.copy(id = s1e1w2_id, traktId = 4385783)\n\nval episodeWatch2PendingSend = s1e1w2.copy(pendingAction = PendingAction.UPLOAD)\nval episodeWatch2PendingDelete = s1e1w2.copy(pendingAction = PendingAction.DELETE)\n\ninternal suspend fun insertFollowedShow(db: TiviDatabase) = db.followedShowsDao().insert(followedShow1Local)\n\nconst val followedShowId = 1L\nval followedShow1Network = FollowedShowEntry(0, showId, traktId = 100)\nval followedShow1Local = followedShow1Network.copy(id = followedShowId)\nval followedShow1PendingDelete = followedShow1Local.copy(pendingAction = PendingAction.DELETE)\nval followedShow1PendingUpload = followedShow1Local.copy(pendingAction = PendingAction.UPLOAD)\n\nconst val followedShow2Id = 2L\nval followedShow2Network = FollowedShowEntry(0, show2Id, traktId = 101)\nval followedShow2Local = followedShow2Network.copy(id = followedShow2Id)\n\nval showPoster = ShowTmdbImage(showId = 0, path = \"/folder/fake.jpg\", type = ImageType.POSTER)",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.utils\n\nimport app.tivi.data.DatabaseTransactionRunner\n\ninternal object TestTransactionRunner : DatabaseTransactionRunner {\n    override suspend fun <T> invoke(block: suspend () -> T): T = block()\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.utils\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n/**\n * A fake version of TiviShowFts to model the same entity\n * table, but without actually using FTS. This is because\n * Robolectric's SQL implementation does not support everything\n * needed for Room's FTS support.\n */\n@Entity(tableName = \"shows_fts\")\ninternal data class FakeTiviShowFts(\n    @PrimaryKey @ColumnInfo(name = \"id\") val id: Long? = null,\n    @ColumnInfo(name = \"title\") val title: String? = null,\n    @ColumnInfo(name = \"original_title\") val originalTitle: String? = null,\n    @ColumnInfo(name = \"docid\") val docId: Long? = null\n)",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport android.content.Context\nimport androidx.room.Room\nimport androidx.test.core.app.ApplicationProvider\nimport app.tivi.data.dao.EpisodeWatchEntryTest\nimport app.tivi.data.dao.EpisodesTest\nimport app.tivi.data.dao.SeasonsTest\nimport app.tivi.data.repositories.FollowedShowRepositoryTest\nimport app.tivi.data.repositories.SeasonsEpisodesRepositoryTest\nimport app.tivi.data.repositories.episodes.EpisodeDataSource\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesDataSource\nimport app.tivi.data.repositories.followedshows.TraktFollowedShowsDataSource\nimport app.tivi.data.repositories.showimages.ShowImagesDataSource\nimport app.tivi.data.repositories.showimages.ShowImagesStoreModule\nimport app.tivi.data.repositories.shows.ShowDataSource\nimport app.tivi.data.repositories.shows.ShowStoreModule\nimport app.tivi.inject.ForStore\nimport app.tivi.inject.Trakt\nimport app.tivi.trakt.TraktAuthState\nimport app.tivi.trakt.TraktServiceModule\nimport app.tivi.util.Logger\nimport app.tivi.utils.TestTransactionRunner\nimport app.tivi.utils.TiviTestDatabase\nimport com.uwetrottmann.tmdb2.Tmdb\nimport com.uwetrottmann.trakt5.TraktV2\nimport dagger.Component\nimport dagger.Module\nimport dagger.Provides\nimport io.mockk.mockk\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\n\n@Singleton\n@Component(modules = [\n    TestDataSourceModule::class,\n    TestDatabaseModule::class\n])\ninterface TestComponent {\n    fun inject(test: SeasonsEpisodesRepositoryTest)\n    fun inject(test: FollowedShowRepositoryTest)\n    fun inject(test: EpisodesTest)\n    fun inject(test: EpisodeWatchEntryTest)\n    fun inject(test: SeasonsTest)\n}\n\n@Module\nclass TestDataSourceModule(\n    private val traktFollowedShowsDataSource: TraktFollowedShowsDataSource = mockk(),\n    private val traktEpisodeDataSource: EpisodeDataSource = mockk(),\n    private val tmdbEpisodeDataSource: EpisodeDataSource = mockk(),\n    private val seasonsDataSource: SeasonsEpisodesDataSource = mockk(),\n    private val traktShowDataSource: ShowDataSource = mockk(),\n    private val tmdbShowDataSource: ShowDataSource = mockk(),\n    private val tmdbShowImagesDataSource: ShowImagesDataSource = mockk(),\n    private val storeScope: CoroutineScope\n) {\n    @Provides\n    fun provideTraktFollowedShowsDataSource() = traktFollowedShowsDataSource\n\n    @Provides\n    @Trakt\n    fun provideTraktEpisodeDataSource() = traktEpisodeDataSource\n\n    @Provides\n    @app.tivi.inject.Tmdb\n    fun provideTmdbEpisodeDataSource() = tmdbEpisodeDataSource\n\n    @Provides\n    fun provideSeasonsEpisodesDataSource() = seasonsDataSource\n\n    @Provides\n    @Trakt\n    fun provideTraktShowDataSource(): ShowDataSource = traktShowDataSource\n\n    @Provides\n    @app.tivi.inject.Tmdb\n    fun provideTmdbShowDataSource(): ShowDataSource = tmdbShowDataSource\n\n    @Provides\n    @app.tivi.inject.Tmdb\n    fun provideTmdbShowImagesDataSource(): ShowImagesDataSource = tmdbShowImagesDataSource\n\n    @Provides\n    @ForStore\n    fun provideStoreCoroutineScope(): CoroutineScope = storeScope\n}\n\n@Module(includes = [\n    TestRoomDatabaseModule::class,\n    DatabaseDaoModule::class,\n    TraktServiceModule::class,\n    ShowStoreModule::class,\n    ShowImagesStoreModule::class\n])\nclass TestDatabaseModule {\n    @Provides\n    fun provideTrakt(): TraktV2 = TraktV2(\"fakefakefake\")\n\n    @Provides\n    fun provideTmdb(): Tmdb = Tmdb(\"fakefakefake\")\n\n    @Provides\n    fun provideTraktAuthState() = TraktAuthState.LOGGED_IN\n\n    @Provides\n    fun provideContext(): Context = ApplicationProvider.getApplicationContext()\n\n    @Singleton\n    @Provides\n    fun provideLogger(): Logger = mockk(relaxUnitFun = true)\n}\n\n@Module\nclass TestRoomDatabaseModule {\n    @Singleton\n    @Provides\n    fun provideDatabase(context: Context): TiviDatabase {\n        return Room.inMemoryDatabaseBuilder(context, TiviTestDatabase::class.java)\n            .allowMainThreadQueries()\n            .build()\n    }\n\n    @Singleton\n    @Provides\n    fun provideDatabaseTransactionRunner(): DatabaseTransactionRunner = TestTransactionRunner\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.dao\n\nimport android.database.sqlite.SQLiteConstraintException\nimport androidx.arch.core.executor.testing.InstantTaskExecutorRule\nimport app.tivi.data.DaggerTestComponent\nimport app.tivi.data.TestDataSourceModule\nimport app.tivi.data.TiviDatabase\nimport app.tivi.data.daos.EpisodesDao\nimport app.tivi.data.daos.SeasonsDao\nimport app.tivi.utils.insertShow\nimport app.tivi.utils.s1\nimport app.tivi.utils.s1_episodes\nimport app.tivi.utils.s1e1\nimport app.tivi.utils.s1e2\nimport app.tivi.utils.s1e3\nimport app.tivi.utils.showId\nimport javax.inject.Inject\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.runBlocking\nimport kotlinx.coroutines.test.TestCoroutineScope\nimport kotlinx.coroutines.test.runBlockingTest\nimport org.hamcrest.CoreMatchers.`is`\nimport org.hamcrest.CoreMatchers.nullValue\nimport org.hamcrest.MatcherAssert.assertThat\nimport org.junit.After\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\nclass EpisodesTest {\n    @get:Rule\n    val instantTaskExecutorRule = InstantTaskExecutorRule()\n\n    private val testScope = TestCoroutineScope()\n\n    @Inject lateinit var database: TiviDatabase\n    @Inject lateinit var episodeDao: EpisodesDao\n    @Inject lateinit var seasonsDao: SeasonsDao\n\n    @Before\n    fun setup() {\n        DaggerTestComponent.builder()\n            .testDataSourceModule(TestDataSourceModule(storeScope = testScope))\n            .build()\n            .inject(this)\n\n        runBlocking {\n            // We'll assume that there's a show and season in the db\n            insertShow(database)\n            seasonsDao.insert(s1)\n        }\n    }\n\n    @Test\n    fun insert() = testScope.runBlockingTest {\n        episodeDao.insert(s1e1)\n        assertThat(episodeDao.episodeWithId(s1e1.id), `is`(s1e1))\n    }\n\n    @Test(expected = SQLiteConstraintException::class)\n    fun insert_withSameTraktId() = testScope.runBlockingTest {\n        episodeDao.insert(s1e1)\n        // Make a copy with a 0 id\n        val copy = s1e1.copy(id = 0)\n        episodeDao.insert(copy)\n    }\n\n    @Test\n    fun delete() = testScope.runBlockingTest {\n        episodeDao.insert(s1e1)\n        episodeDao.deleteEntity(s1e1)\n        assertThat(episodeDao.episodeWithId(s1e1.id), `is`(nullValue()))\n    }\n\n    @Test\n    fun deleteSeason_deletesEpisode() = testScope.runBlockingTest {\n        episodeDao.insert(s1e1)\n        // Now delete season\n        seasonsDao.deleteEntity(s1)\n        assertThat(episodeDao.episodeWithId(s1e1.id), `is`(nullValue()))\n    }\n\n    @Test\n    fun showIdForEpisodeId() = testScope.runBlockingTest {\n        episodeDao.insert(s1e1)\n        assertThat(episodeDao.showIdForEpisodeId(s1e1.id), `is`(showId))\n    }\n\n    @Test\n    fun nextAiredEpisodeAfter() = testScope.runBlockingTest {\n        episodeDao.insertAll(s1_episodes)\n\n        assertThat(episodeDao.observeNextEpisodeForShowAfter(showId, 0, 0)\n            .first()?.episode, `is`(s1e1))\n\n        assertThat(episodeDao.observeNextEpisodeForShowAfter(showId, 1, 0)\n            .first()?.episode, `is`(s1e2))\n\n        assertThat(episodeDao.observeNextEpisodeForShowAfter(showId, 1, 1)\n            .first()?.episode, `is`(s1e3))\n\n        assertThat(episodeDao.observeNextEpisodeForShowAfter(showId, 1, 2)\n            .first()?.episode, nullValue())\n    }\n\n    @After\n    fun cleanup() {\n        testScope.cleanupTestCoroutines()\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.dao\n\nimport android.database.sqlite.SQLiteConstraintException\nimport androidx.arch.core.executor.testing.InstantTaskExecutorRule\nimport app.tivi.data.DaggerTestComponent\nimport app.tivi.data.TestDataSourceModule\nimport app.tivi.data.TiviDatabase\nimport app.tivi.data.daos.EpisodeWatchEntryDao\nimport app.tivi.data.daos.EpisodesDao\nimport app.tivi.data.daos.SeasonsDao\nimport app.tivi.utils.episodeWatch2PendingDelete\nimport app.tivi.utils.episodeWatch2PendingSend\nimport app.tivi.utils.insertShow\nimport app.tivi.utils.s1\nimport app.tivi.utils.s1_episodes\nimport app.tivi.utils.s1e1\nimport app.tivi.utils.s1e1w\nimport app.tivi.utils.s1e1w_id\nimport app.tivi.utils.showId\nimport javax.inject.Inject\nimport kotlinx.coroutines.test.TestCoroutineScope\nimport kotlinx.coroutines.test.runBlockingTest\nimport org.hamcrest.CoreMatchers.`is`\nimport org.hamcrest.CoreMatchers.nullValue\nimport org.hamcrest.MatcherAssert.assertThat\nimport org.junit.After\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\nclass EpisodeWatchEntryTest {\n    @get:Rule\n    val instantTaskExecutorRule = InstantTaskExecutorRule()\n\n    @Inject lateinit var database: TiviDatabase\n    @Inject lateinit var episodesDao: EpisodesDao\n    @Inject lateinit var seasonsDao: SeasonsDao\n    @Inject lateinit var episodeWatchEntryDao: EpisodeWatchEntryDao\n\n    private val testScope = TestCoroutineScope()\n\n    @Before\n    fun setup() {\n        DaggerTestComponent.builder()\n            .testDataSourceModule(TestDataSourceModule(storeScope = testScope))\n            .build()\n            .inject(this)\n\n        runBlockingTest {\n            // We'll assume that there's a show, season and s1_episodes in the db\n            insertShow(database)\n            seasonsDao.insert(s1)\n            episodesDao.insertAll(s1_episodes)\n        }\n    }\n\n    @Test\n    fun insert() = testScope.runBlockingTest {\n        episodeWatchEntryDao.insert(s1e1w)\n        assertThat(episodeWatchEntryDao.entryWithId(s1e1w_id), `is`(s1e1w))\n    }\n\n    @Test(expected = SQLiteConstraintException::class)\n    fun insert_withSameTraktId() = testScope.runBlockingTest {\n        episodeWatchEntryDao.insert(s1e1w)\n        // Make a copy with a 0 id\n        val copy = s1e1w.copy(id = 0)\n        episodeWatchEntryDao.insert(copy)\n    }\n\n    @Test\n    fun fetchEntries_WithPendingSendAction() = testScope.runBlockingTest {\n        episodeWatchEntryDao.insertAll(s1e1w, episodeWatch2PendingSend)\n        assertThat(episodeWatchEntryDao.entriesForShowIdWithSendPendingActions(showId),\n            `is`(listOf(episodeWatch2PendingSend))\n        )\n    }\n\n    @Test\n    fun fetchEntries_WithPendingDeleteAction() = testScope.runBlockingTest {\n        episodeWatchEntryDao.insertAll(s1e1w, episodeWatch2PendingDelete)\n        assertThat(episodeWatchEntryDao.entriesForShowIdWithDeletePendingActions(showId),\n            `is`(listOf(episodeWatch2PendingDelete))\n        )\n    }\n\n    @Test\n    fun delete() = testScope.runBlockingTest {\n        episodeWatchEntryDao.insert(s1e1w)\n        episodeWatchEntryDao.deleteEntity(s1e1w)\n        assertThat(episodeWatchEntryDao.entryWithId(s1e1w_id), `is`(nullValue()))\n    }\n\n    @Test\n    fun deleteEpisode_deletesWatch() = testScope.runBlockingTest {\n        episodeWatchEntryDao.insert(s1e1w)\n        // Now delete episode\n        episodesDao.deleteEntity(s1e1)\n        assertThat(episodeWatchEntryDao.entryWithId(s1e1w_id), `is`(nullValue()))\n    }\n\n    @After\n    fun cleanup() {\n        testScope.cleanupTestCoroutines()\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.dao\n\nimport android.database.sqlite.SQLiteConstraintException\nimport androidx.arch.core.executor.testing.InstantTaskExecutorRule\nimport app.tivi.data.DaggerTestComponent\nimport app.tivi.data.TestDataSourceModule\nimport app.tivi.data.TiviDatabase\nimport app.tivi.data.daos.SeasonsDao\nimport app.tivi.utils.deleteShow\nimport app.tivi.utils.insertShow\nimport app.tivi.utils.s0\nimport app.tivi.utils.s1\nimport app.tivi.utils.s1_id\nimport app.tivi.utils.s2\nimport app.tivi.utils.showId\nimport javax.inject.Inject\nimport kotlinx.coroutines.test.TestCoroutineScope\nimport kotlinx.coroutines.test.runBlockingTest\nimport org.hamcrest.CoreMatchers.`is`\nimport org.hamcrest.CoreMatchers.nullValue\nimport org.hamcrest.MatcherAssert.assertThat\nimport org.junit.After\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\nclass SeasonsTest {\n    @get:Rule\n    val instantTaskExecutorRule = InstantTaskExecutorRule()\n\n    private val testScope = TestCoroutineScope()\n\n    @Inject lateinit var database: TiviDatabase\n    @Inject lateinit var seasonsDao: SeasonsDao\n\n    @Before\n    fun setup() {\n        DaggerTestComponent.builder()\n            .testDataSourceModule(TestDataSourceModule(storeScope = testScope))\n            .build()\n            .inject(this)\n\n        runBlockingTest {\n            // We'll assume that there's a show in the db\n            insertShow(database)\n        }\n    }\n\n    @Test\n    fun insertSeason() = testScope.runBlockingTest {\n        seasonsDao.insert(s1)\n\n        assertThat(seasonsDao.seasonWithId(s1_id), `is`(s1))\n    }\n\n    @Test(expected = SQLiteConstraintException::class)\n    fun insert_withSameTraktId() = testScope.runBlockingTest {\n        seasonsDao.insert(s1)\n\n        // Make a copy with a 0 id\n        val copy = s1.copy(id = 0)\n\n        seasonsDao.insert(copy)\n    }\n\n    @Test\n    fun specialsOrder() = testScope.runBlockingTest {\n        seasonsDao.insert(s0)\n        seasonsDao.insert(s1)\n        seasonsDao.insert(s2)\n\n        // Specials should always be last\n        assertThat(seasonsDao.seasonsForShowId(showId),\n            `is`(listOf(s1, s2, s0))\n        )\n    }\n\n    @Test\n    fun deleteSeason() = testScope.runBlockingTest {\n        seasonsDao.insert(s1)\n        seasonsDao.deleteEntity(s1)\n\n        assertThat(seasonsDao.seasonWithId(s1_id), `is`(nullValue()))\n    }\n\n    @Test\n    fun deleteShow_deletesSeason() = testScope.runBlockingTest {\n        seasonsDao.insert(s1)\n        // Now delete show\n        deleteShow(database)\n\n        assertThat(seasonsDao.seasonWithId(s1_id), `is`(nullValue()))\n    }\n\n    @After\n    fun cleanup() {\n        testScope.cleanupTestCoroutines()\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories\n\nimport androidx.arch.core.executor.testing.InstantTaskExecutorRule\nimport app.tivi.data.DaggerTestComponent\nimport app.tivi.data.TestDataSourceModule\nimport app.tivi.data.TiviDatabase\nimport app.tivi.data.daos.EpisodeWatchEntryDao\nimport app.tivi.data.daos.EpisodesDao\nimport app.tivi.data.daos.SeasonsDao\nimport app.tivi.data.entities.Success\nimport app.tivi.data.repositories.episodes.EpisodeWatchStore\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesDataSource\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.utils.insertShow\nimport app.tivi.utils.s1\nimport app.tivi.utils.s1_episodes\nimport app.tivi.utils.s1_id\nimport app.tivi.utils.s1e1\nimport app.tivi.utils.s1e1w\nimport app.tivi.utils.s1e1w2\nimport app.tivi.utils.s1e2\nimport app.tivi.utils.s2\nimport app.tivi.utils.s2_episodes\nimport app.tivi.utils.s2_id\nimport app.tivi.utils.s2e1\nimport app.tivi.utils.showId\nimport io.mockk.coEvery\nimport javax.inject.Inject\nimport kotlinx.coroutines.flow.produceIn\nimport kotlinx.coroutines.runBlocking\nimport kotlinx.coroutines.test.TestCoroutineScope\nimport kotlinx.coroutines.test.runBlockingTest\nimport kotlinx.coroutines.withTimeout\nimport org.hamcrest.MatcherAssert.assertThat\nimport org.hamcrest.Matchers.`is`\nimport org.junit.After\nimport org.junit.Assert.assertEquals\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.robolectric.RobolectricTestRunner\nimport org.threeten.bp.OffsetDateTime\n\n@RunWith(RobolectricTestRunner::class)\nclass SeasonsEpisodesRepositoryTest {\n    @get:Rule\n    val instantTaskExecutorRule = InstantTaskExecutorRule()\n\n    private val testScope = TestCoroutineScope()\n\n    @Inject lateinit var database: TiviDatabase\n    @Inject lateinit var episodeWatchDao: EpisodeWatchEntryDao\n    @Inject lateinit var seasonsDao: SeasonsDao\n    @Inject lateinit var episodesDao: EpisodesDao\n    @Inject lateinit var watchStore: EpisodeWatchStore\n    @Inject lateinit var repository: SeasonsEpisodesRepository\n    @Inject lateinit var seasonsDataSource: SeasonsEpisodesDataSource\n\n    @Before\n    fun setup() {\n        DaggerTestComponent.builder()\n            .testDataSourceModule(TestDataSourceModule(storeScope = testScope))\n            .build()\n            .inject(this)\n\n        runBlocking {\n            // We'll assume that there's a show in the db\n            insertShow(database)\n        }\n    }\n\n    @Test\n    fun testSyncEpisodeWatches() = testScope.runBlockingTest {\n        seasonsDao.insert(s1)\n        episodesDao.insertAll(s1_episodes)\n\n        // Return a response with 2 items\n        coEvery { seasonsDataSource.getShowEpisodeWatches(showId) } returns\n            Success(listOf(s1e1 to s1e1w, s1e1 to s1e1w2))\n        // Sync\n        repository.syncEpisodeWatchesForShow(showId)\n        // Assert that both are in the db\n        assertThat(watchStore.getEpisodeWatchesForShow(showId), `is`(listOf(s1e1w, s1e1w2)))\n    }\n\n    @Test\n    fun testEpisodeWatches_sameEntries() = testScope.runBlockingTest {\n        seasonsDao.insert(s1)\n        episodesDao.insertAll(s1_episodes)\n\n        // Insert both the watches\n        episodeWatchDao.insertAll(s1e1w, s1e1w2)\n        // Return a response with the same items\n        coEvery { seasonsDataSource.getShowEpisodeWatches(showId) } returns\n            Success(listOf(s1e1 to s1e1w, s1e1 to s1e1w2))\n        // Now re-sync with the same response\n        repository.syncEpisodeWatchesForShow(showId)\n        // Assert that both are in the db\n        assertThat(watchStore.getEpisodeWatchesForShow(showId), `is`(listOf(s1e1w, s1e1w2)))\n    }\n\n    @Test\n    fun testEpisodeWatches_deletesMissing() = testScope.runBlockingTest {\n        seasonsDao.insert(s1)\n        episodesDao.insertAll(s1_episodes)\n\n        // Insert both the watches\n        episodeWatchDao.insertAll(s1e1w, s1e1w2)\n        // Return a response with just the second item\n        coEvery { seasonsDataSource.getShowEpisodeWatches(showId) } returns\n            Success(listOf(s1e1 to s1e1w2))\n        // Now re-sync\n        repository.syncEpisodeWatchesForShow(showId)\n        // Assert that only the second is in the db\n        assertThat(watchStore.getEpisodeWatchesForShow(showId), `is`(listOf(s1e1w2)))\n    }\n\n    @Test\n    fun testEpisodeWatches_emptyResponse() = testScope.runBlockingTest {\n        seasonsDao.insert(s1)\n        episodesDao.insertAll(s1_episodes)\n\n        // Insert both the watches\n        episodeWatchDao.insertAll(s1e1w, s1e1w2)\n        // Return a empty response\n        coEvery { seasonsDataSource.getShowEpisodeWatches(showId) } returns\n            Success(emptyList())\n        // Now re-sync\n        repository.syncEpisodeWatchesForShow(showId)\n        // Assert that the database is empty\n        assertThat(watchStore.getEpisodeWatchesForShow(showId), `is`(emptyList()))\n    }\n\n    @Test\n    fun testSyncSeasonsEpisodes() = testScope.runBlockingTest {\n        // Return a response with 2 items\n        coEvery { seasonsDataSource.getSeasonsEpisodes(showId) } returns\n            Success(listOf(s1 to s1_episodes))\n        repository.updateSeasonsEpisodes(showId)\n\n        // Assert that both are in the db\n        assertThat(seasonsDao.seasonsForShowId(showId), `is`(listOf(s1)))\n        assertThat(episodesDao.episodesWithSeasonId(s1_id), `is`(s1_episodes))\n    }\n\n    @Test\n    fun testSyncSeasonsEpisodes_sameEntries() = testScope.runBlockingTest {\n        seasonsDao.insert(s1)\n        episodesDao.insertAll(s1_episodes)\n\n        // Return a response with the same items\n        coEvery { seasonsDataSource.getSeasonsEpisodes(showId) } returns\n            Success(listOf(s1 to s1_episodes))\n        repository.updateSeasonsEpisodes(showId)\n\n        // Assert that both are in the db\n        assertThat(seasonsDao.seasonsForShowId(showId), `is`(listOf(s1)))\n        assertThat(episodesDao.episodesWithSeasonId(s1_id), `is`(s1_episodes))\n    }\n\n    @Test\n    fun testSyncSeasonsEpisodes_emptyResponse() = testScope.runBlockingTest {\n        seasonsDao.insert(s1)\n        episodesDao.insertAll(s1_episodes)\n\n        // Return an empty response\n        coEvery { seasonsDataSource.getSeasonsEpisodes(showId) } returns\n            Success(emptyList())\n        repository.updateSeasonsEpisodes(showId)\n\n        // Assert the database is empty\n        assertThat(seasonsDao.seasonsForShowId(showId), `is`(emptyList()))\n        assertThat(episodesDao.episodesWithSeasonId(s1_id), `is`(emptyList()))\n    }\n\n    @Test\n    fun testSyncSeasonsEpisodes_deletesMissingSeasons() = testScope.runBlockingTest {\n        seasonsDao.insertAll(s1, s2)\n        episodesDao.insertAll(s1_episodes)\n        episodesDao.insertAll(s2_episodes)\n\n        // Return a response with just the first season\n        coEvery { seasonsDataSource.getSeasonsEpisodes(showId) } returns\n            Success(listOf(s1 to s1_episodes))\n        repository.updateSeasonsEpisodes(showId)\n\n        // Assert that both are in the db\n        assertThat(seasonsDao.seasonsForShowId(showId), `is`(listOf(s1)))\n        assertThat(episodesDao.episodesWithSeasonId(s1_id), `is`(s1_episodes))\n    }\n\n    @Test\n    fun testSyncSeasonsEpisodes_deletesMissingEpisodes() = testScope.runBlockingTest {\n        seasonsDao.insertAll(s1, s2)\n        episodesDao.insertAll(s1_episodes)\n        episodesDao.insertAll(s2_episodes)\n\n        // Return a response with both seasons, but just a single episodes in each\n        coEvery { seasonsDataSource.getSeasonsEpisodes(showId) } returns\n            Success(listOf(s1 to listOf(s1e1), s2 to listOf(s2e1)))\n        repository.updateSeasonsEpisodes(showId)\n\n        // Assert that both are in the db\n        assertThat(seasonsDao.seasonsForShowId(showId), `is`(listOf(s1, s2)))\n        assertThat(episodesDao.episodesWithSeasonId(s1_id), `is`(listOf(s1e1)))\n        assertThat(episodesDao.episodesWithSeasonId(s2_id), `is`(listOf(s2e1)))\n    }\n\n    @Test\n    fun testObserveNextEpisodeToWatch_singleFlow() = testScope.runBlockingTest {\n        seasonsDao.insertAll(s1)\n        episodesDao.insertAll(s1_episodes)\n\n        val results = repository.observeNextEpisodeToWatch(showId).produceIn(this)\n\n        // Receive the first emission\n        withTimeout(10_000) {\n            assertEquals(s1e1, results.receive()?.episode)\n        }\n\n        // Now mark s1e1 as watched\n        coEvery { seasonsDataSource.addEpisodeWatches(any()) } returns Success(Unit)\n        coEvery { seasonsDataSource.getEpisodeWatches(s1e1.id, any()) } returns Success(listOf(s1e1w))\n        repository.addEpisodeWatch(s1e1.id, OffsetDateTime.now())\n\n        // Receive the second emission\n        withTimeout(10_000) {\n            assertEquals(s1e2, results.receive()?.episode)\n        }\n\n        results.cancel()\n    }\n\n    @After\n    fun cleanup() {\n        testScope.cleanupTestCoroutines()\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories\n\nimport androidx.arch.core.executor.testing.InstantTaskExecutorRule\nimport app.tivi.data.DaggerTestComponent\nimport app.tivi.data.TestDataSourceModule\nimport app.tivi.data.TiviDatabase\nimport app.tivi.data.daos.FollowedShowsDao\nimport app.tivi.data.entities.ErrorResult\nimport app.tivi.data.entities.Success\nimport app.tivi.data.repositories.followedshows.FollowedShowsRepository\nimport app.tivi.data.repositories.followedshows.TraktFollowedShowsDataSource\nimport app.tivi.utils.SuccessFakeShowDataSource\nimport app.tivi.utils.SuccessFakeShowImagesDataSource\nimport app.tivi.utils.followedShow1Local\nimport app.tivi.utils.followedShow1Network\nimport app.tivi.utils.followedShow1PendingDelete\nimport app.tivi.utils.followedShow1PendingUpload\nimport app.tivi.utils.followedShow2Local\nimport app.tivi.utils.followedShow2Network\nimport app.tivi.utils.insertFollowedShow\nimport app.tivi.utils.insertShow\nimport app.tivi.utils.show\nimport app.tivi.utils.show2\nimport io.mockk.coEvery\nimport javax.inject.Inject\nimport kotlinx.coroutines.runBlocking\nimport kotlinx.coroutines.test.TestCoroutineScope\nimport kotlinx.coroutines.test.runBlockingTest\nimport org.hamcrest.MatcherAssert.assertThat\nimport org.hamcrest.Matchers.`is`\nimport org.junit.After\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\nclass FollowedShowRepositoryTest {\n    @get:Rule\n    val instantTaskExecutorRule = InstantTaskExecutorRule()\n\n    private val testScope = TestCoroutineScope()\n\n    @Inject lateinit var followShowsDao: FollowedShowsDao\n    @Inject lateinit var repository: FollowedShowsRepository\n    @Inject lateinit var database: TiviDatabase\n    @Inject lateinit var traktDataSource: TraktFollowedShowsDataSource\n\n    @Before\n    fun setup() {\n        DaggerTestComponent.builder()\n            .testDataSourceModule(\n                TestDataSourceModule(\n                    traktShowDataSource = SuccessFakeShowDataSource,\n                    tmdbShowDataSource = SuccessFakeShowDataSource,\n                    tmdbShowImagesDataSource = SuccessFakeShowImagesDataSource,\n                    storeScope = testScope\n                )\n            )\n            .build()\n            .inject(this)\n\n        runBlocking {\n            // We'll assume that there's a show in the db\n            insertShow(database)\n        }\n    }\n\n    @Test\n    fun testSync() = testScope.runBlockingTest {\n        coEvery { traktDataSource.getFollowedListId() } returns Success(0)\n        coEvery { traktDataSource.getListShows(0) } returns Success(listOf(followedShow1Network to show))\n\n        repository.syncFollowedShows()\n\n        assertThat(repository.getFollowedShows(),\n            `is`(listOf(followedShow1Local)))\n    }\n\n    @Test\n    fun testSync_emptyResponse() = testScope.runBlockingTest {\n        insertFollowedShow(database)\n\n        coEvery { traktDataSource.getFollowedListId() } returns Success(0)\n        coEvery { traktDataSource.getListShows(0) } returns Success(emptyList())\n\n        repository.syncFollowedShows()\n\n        assertThat(repository.getFollowedShows(),\n            `is`(emptyList()))\n    }\n\n    @Test\n    fun testSync_responseDifferentShow() = testScope.runBlockingTest {\n        insertFollowedShow(database)\n\n        coEvery { traktDataSource.getFollowedListId() } returns Success(0)\n        coEvery { traktDataSource.getListShows(0) } returns Success(listOf(followedShow2Network to show2))\n\n        repository.syncFollowedShows()\n\n        assertThat(repository.getFollowedShows(),\n            `is`(listOf(followedShow2Local)))\n    }\n\n    @Test\n    fun testSync_pendingDelete() = testScope.runBlockingTest {\n        followShowsDao.insert(followedShow1PendingDelete)\n\n        // Return error for the list ID so that we disable syncing\n        coEvery { traktDataSource.getFollowedListId() } returns ErrorResult(IllegalArgumentException())\n\n        repository.syncFollowedShows()\n\n        assertThat(repository.getFollowedShows(),\n            `is`(emptyList()))\n    }\n\n    @Test\n    fun testSync_pendingAdd() = testScope.runBlockingTest {\n        followShowsDao.insert(followedShow1PendingUpload)\n\n        // Return an error for the list ID so that we disable syncing\n        coEvery { traktDataSource.getFollowedListId() } returns ErrorResult(IllegalArgumentException())\n\n        repository.syncFollowedShows()\n\n        assertThat(repository.getFollowedShows(),\n            `is`(listOf(followedShow1Local)))\n    }\n\n    @After\n    fun cleanup() {\n        testScope.cleanupTestCoroutines()\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport androidx.room.withTransaction\nimport javax.inject.Inject\n\nclass RoomTransactionRunner @Inject constructor(\n    private val db: TiviRoomDatabase\n) : DatabaseTransactionRunner {\n    override suspend operator fun <T> invoke(block: suspend () -> T): T {\n        return db.withTransaction {\n            block()\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport androidx.room.TypeConverter\nimport app.tivi.data.entities.ImageType\nimport app.tivi.data.entities.PendingAction\nimport app.tivi.data.entities.Request\nimport app.tivi.data.entities.ShowStatus\nimport org.threeten.bp.DayOfWeek\nimport org.threeten.bp.Instant\nimport org.threeten.bp.LocalTime\nimport org.threeten.bp.OffsetDateTime\nimport org.threeten.bp.ZoneId\nimport org.threeten.bp.format.DateTimeFormatter\n\nobject TiviTypeConverters {\n    private val formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME\n\n    private val requestValues by lazy(LazyThreadSafetyMode.NONE) { Request.values() }\n    private val imageTypeValues by lazy(LazyThreadSafetyMode.NONE) { ImageType.values() }\n    private val pendingActionValues by lazy(LazyThreadSafetyMode.NONE) { PendingAction.values() }\n    private val showStatusValues by lazy(LazyThreadSafetyMode.NONE) { ShowStatus.values() }\n    private val dayOfWeekValues by lazy(LazyThreadSafetyMode.NONE) { DayOfWeek.values() }\n\n    @TypeConverter\n    @JvmStatic\n    fun toOffsetDateTime(value: String?) = value?.let { formatter.parse(value, OffsetDateTime::from) }\n\n    @TypeConverter\n    @JvmStatic\n    fun fromOffsetDateTime(date: OffsetDateTime?): String? = date?.format(formatter)\n\n    @TypeConverter\n    @JvmStatic\n    fun toZoneId(value: String?) = value?.let { ZoneId.of(it) }\n\n    @TypeConverter\n    @JvmStatic\n    fun fromZoneId(value: ZoneId?) = value?.id\n\n    @TypeConverter\n    @JvmStatic\n    fun toLocalTime(value: String?) = value?.let { LocalTime.parse(value) }\n\n    @TypeConverter\n    @JvmStatic\n    fun fromLocalTime(value: LocalTime?) = value?.format(DateTimeFormatter.ISO_LOCAL_TIME)\n\n    @TypeConverter\n    @JvmStatic\n    fun toDayOfWeek(value: Int?): DayOfWeek? {\n        return if (value != null) {\n            dayOfWeekValues.firstOrNull { it.value == value }\n        } else null\n    }\n\n    @TypeConverter\n    @JvmStatic\n    fun fromDayOfWeek(day: DayOfWeek?) = day?.value\n\n    @TypeConverter\n    @JvmStatic\n    fun toInstant(value: Long?) = value?.let { Instant.ofEpochMilli(it) }\n\n    @TypeConverter\n    @JvmStatic\n    fun fromInstant(date: Instant?) = date?.toEpochMilli()\n\n    @TypeConverter\n    @JvmStatic\n    fun fromPendingAction(action: PendingAction): String = action.value\n\n    @TypeConverter\n    @JvmStatic\n    fun toPendingAction(action: String?) = pendingActionValues.firstOrNull { it.value == action }\n\n    @TypeConverter\n    @JvmStatic\n    fun fromRequest(value: Request) = value.tag\n\n    @TypeConverter\n    @JvmStatic\n    fun toRequest(value: String) = requestValues.firstOrNull { it.tag == value }\n\n    @TypeConverter\n    @JvmStatic\n    fun fromImageType(value: ImageType) = value.storageKey\n\n    @TypeConverter\n    @JvmStatic\n    fun toImageType(value: String?) = imageTypeValues.firstOrNull { it.storageKey == value }\n\n    @TypeConverter\n    @JvmStatic\n    fun fromShowStatus(value: ShowStatus?) = value?.storageKey\n\n    @TypeConverter\n    @JvmStatic\n    fun toShowStatus(value: String?) = showStatusValues.firstOrNull { it.storageKey == value }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport android.content.Context\nimport android.os.Debug\nimport androidx.room.Room\nimport dagger.Binds\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\n\n@Module(includes = [\n    RoomDatabaseModule::class,\n    DatabaseModuleBinds::class,\n    DatabaseDaoModule::class\n])\nclass DatabaseModule\n\n@Module\nclass RoomDatabaseModule {\n    @Singleton\n    @Provides\n    fun provideDatabase(context: Context): TiviRoomDatabase {\n        val builder = Room.databaseBuilder(context, TiviRoomDatabase::class.java, \"shows.db\")\n            .addMigrations(*TiviRoomDatabase_Migrations.build())\n            .fallbackToDestructiveMigration()\n        if (Debug.isDebuggerConnected()) {\n            builder.allowMainThreadQueries()\n        }\n        return builder.build()\n    }\n}\n\n@Module\nclass DatabaseDaoModule {\n    @Provides\n    fun provideTiviShowDao(db: TiviDatabase) = db.showDao()\n\n    @Provides\n    fun provideUserDao(db: TiviDatabase) = db.userDao()\n\n    @Provides\n    fun provideTrendingDao(db: TiviDatabase) = db.trendingDao()\n\n    @Provides\n    fun providePopularDao(db: TiviDatabase) = db.popularDao()\n\n    @Provides\n    fun provideWatchedDao(db: TiviDatabase) = db.watchedShowsDao()\n\n    @Provides\n    fun provideFollowedShowsDao(db: TiviDatabase) = db.followedShowsDao()\n\n    @Provides\n    fun provideSeasonsDao(db: TiviDatabase) = db.seasonsDao()\n\n    @Provides\n    fun provideEpisodesDao(db: TiviDatabase) = db.episodesDao()\n\n    @Provides\n    fun provideRelatedShowsDao(db: TiviDatabase) = db.relatedShowsDao()\n\n    @Provides\n    fun provideEpisodeWatchesDao(db: TiviDatabase) = db.episodeWatchesDao()\n\n    @Provides\n    fun provideLastRequestsDao(db: TiviDatabase) = db.lastRequestDao()\n\n    @Provides\n    fun provideShowImagesDao(db: TiviDatabase) = db.showImagesDao()\n\n    @Provides\n    fun provideShowFtsDao(db: TiviDatabase) = db.showFtsDao()\n\n    @Provides\n    fun provideRecommendedShowsDao(db: TiviDatabase) = db.recommendedShowsDao()\n}\n\n@Module\nabstract class DatabaseModuleBinds {\n    @Binds\n    abstract fun bindTiviDatabase(context: TiviRoomDatabase): TiviDatabase\n\n    @Singleton\n    @Binds\n    abstract fun provideDatabaseTransactionRunner(runner: RoomTransactionRunner): DatabaseTransactionRunner\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport android.annotation.SuppressLint\nimport androidx.arch.core.executor.ArchTaskExecutor\nimport androidx.paging.DataSource\nimport androidx.paging.PagedList\nimport java.util.concurrent.Executor\nimport kotlinx.coroutines.asCoroutineDispatcher\nimport kotlinx.coroutines.channels.awaitClose\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.channelFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\n\n/**\n * Builder for `Flow<PagedList>` given a [DataSource.Factory] and a [PagedList.Config].\n *\n * The required parameters are in the constructor, so you can simply construct and build, or\n * optionally enable extra features (such as initial load key, or BoundaryCallback).\n *\n * The returned Flow will already be subscribed on the\n * [fetchExecutor], and will perform all loading on that scheduler. It will\n * already be observed on [notifyExecutor], and will dispatch new PagedLists,\n * as well as their updates to that scheduler.\n *\n * @param <K> Type of input valued used to load data from the DataSource. Must be integer if\n * you're using PositionalDataSource.\n * @param <V> Item type being presented.\n */\nclass FlowPagedListBuilder<K, V>(\n    private val dataSourceFactory: DataSource.Factory<K, V>,\n    private val config: PagedList.Config,\n\n    /**\n     * First loading key passed to the first PagedList/DataSource.\n     * <p>\n     * When a new PagedList/DataSource pair is created after the first, it acquires a load key from\n     * the previous generation so that data is loaded around the position already being observed.\n     *\n     * @param key Initial load key passed to the first PagedList/DataSource.\n     */\n    var initialLoadKey: K? = null,\n\n    /**\n     * Typically used to load additional data from network when paging from local storage.\n     *\n     * Pass a BoundaryCallback to listen to when the PagedList runs out of data to load. If this\n     * method is not called, or `null` is passed, you will not be notified when each\n     * DataSource runs out of data to provide to its PagedList.\n     *\n     * If you are paging from a DataSource.Factory backed by local storage, you can set a\n     * BoundaryCallback to know when there is no more information to page from local storage.\n     * This is useful to page from the network when local storage is a cache of network data.\n     *\n     * Note that when using a BoundaryCallback with a `Flow<PagedList>`, method calls\n     * on the callback may be dispatched multiple times - one for each PagedList/DataSource\n     * pair. If loading network data from a BoundaryCallback, you should prevent multiple\n     * dispatches of the same method from triggering multiple simultaneous network loads.\n     */\n    var boundaryCallback: PagedList.BoundaryCallback<*>? = null,\n\n    private var notifyExecutor: Executor? = null,\n    private var fetchExecutor: Executor? = null\n) {\n    /**\n     * Constructs a `Flow<PagedList>`.\n     *\n     * @return The Flow of PagedLists\n     */\n    @SuppressLint(\"RestrictedApi\")\n    fun buildFlow(): Flow<PagedList<V>> = channelFlow {\n        val nExecutor = notifyExecutor ?: ArchTaskExecutor.getMainThreadExecutor()\n        val fExecutor = fetchExecutor ?: ArchTaskExecutor.getIOThreadExecutor()\n\n        val nDispatcher = nExecutor.asCoroutineDispatcher()\n        val fDispatcher = fExecutor.asCoroutineDispatcher()\n\n        val invalidateCallback = object : ClearableInvalidatedCallback {\n            private var prevList: PagedList<V>? = null\n            private var dataSource: DataSource<K, V>? = null\n\n            override fun onInvalidated() = sendNewList()\n\n            override fun clear() {\n                dataSource?.removeInvalidatedCallback(this)\n            }\n\n            private fun sendNewList() {\n                launch(fDispatcher) {\n                    // Compute on the fetch dispatcher\n                    val list = createPagedList()\n\n                    withContext(nDispatcher) {\n                        // Send on the notify dispatcher\n                        send(list)\n                    }\n                }\n            }\n\n            @Suppress(\"UNCHECKED_CAST\")\n            private fun createPagedList(): PagedList<V> {\n                do {\n                    dataSource?.removeInvalidatedCallback(this)\n\n                    dataSource = dataSourceFactory.create().also {\n                        it.addInvalidatedCallback(this)\n                    }\n\n                    val list = PagedList.Builder(dataSource!!, config)\n                        .setNotifyExecutor(nExecutor)\n                        .setFetchExecutor(fExecutor)\n                        .setBoundaryCallback(boundaryCallback)\n                        .setInitialKey(prevList?.lastKey as? K ?: initialLoadKey)\n                        .build()\n                        .also { prevList = it }\n                } while (list.isDetached)\n\n                return prevList!!\n            }\n        }\n\n        // Do the initial load\n        invalidateCallback.onInvalidated()\n\n        awaitClose {\n            invalidateCallback.clear()\n        }\n    }\n\n    private interface ClearableInvalidatedCallback : DataSource.InvalidatedCallback {\n        fun clear()\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\nimport androidx.room.TypeConverters\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.entities.FollowedShowEntry\nimport app.tivi.data.entities.LastRequest\nimport app.tivi.data.entities.PopularShowEntry\nimport app.tivi.data.entities.RecommendedShowEntry\nimport app.tivi.data.entities.RelatedShowEntry\nimport app.tivi.data.entities.Season\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.entities.TiviShowFts\nimport app.tivi.data.entities.TraktUser\nimport app.tivi.data.entities.TrendingShowEntry\nimport app.tivi.data.entities.WatchedShowEntry\nimport app.tivi.data.views.FollowedShowsLastWatched\nimport app.tivi.data.views.FollowedShowsNextToWatch\nimport app.tivi.data.views.FollowedShowsWatchStats\nimport dev.matrix.roomigrant.GenerateRoomMigrations\n\n@Database(\n    entities = [\n        TiviShow::class,\n        TiviShowFts::class,\n        TrendingShowEntry::class,\n        PopularShowEntry::class,\n        TraktUser::class,\n        WatchedShowEntry::class,\n        FollowedShowEntry::class,\n        Season::class,\n        Episode::class,\n        RelatedShowEntry::class,\n        EpisodeWatchEntry::class,\n        LastRequest::class,\n        ShowTmdbImage::class,\n        RecommendedShowEntry::class\n    ],\n    views = [\n        FollowedShowsWatchStats::class,\n        FollowedShowsLastWatched::class,\n        FollowedShowsNextToWatch::class\n    ],\n    version = 26\n)\n@TypeConverters(TiviTypeConverters::class)\n@GenerateRoomMigrations\nabstract class TiviRoomDatabase : RoomDatabase(), TiviDatabase",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.trending\n\nimport com.squareup.inject.assisted.dagger2.AssistedModule\nimport dagger.Module\nimport dagger.android.ContributesAndroidInjector\n\n@Module\nabstract class TrendingBuilder {\n    @ContributesAndroidInjector(modules = [\n        TrendingAssistedModule::class\n    ])\n    internal abstract fun trendingShowsFragment(): TrendingShowsFragment\n}\n\n@Module(includes = [AssistedInject_TrendingAssistedModule::class])\n@AssistedModule\ninterface TrendingAssistedModule",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.trending\n\nimport android.os.Bundle\nimport android.view.ActionMode\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.View\nimport androidx.core.net.toUri\nimport androidx.navigation.fragment.findNavController\nimport app.tivi.SharedElementHelper\nimport app.tivi.common.entrygrid.databinding.FragmentEntryGridBinding\nimport app.tivi.common.layouts.PosterGridItemBindingModel_\nimport app.tivi.data.entities.findHighestRatedPoster\nimport app.tivi.data.resultentities.TrendingEntryWithShow\nimport app.tivi.extensions.toActivityNavigatorExtras\nimport app.tivi.util.EntryGridEpoxyController\nimport app.tivi.util.EntryGridFragment\nimport com.airbnb.epoxy.EpoxyModel\nimport com.airbnb.mvrx.fragmentViewModel\nimport javax.inject.Inject\n\nclass TrendingShowsFragment : EntryGridFragment<TrendingEntryWithShow, TrendingShowsViewModel>() {\n    override val viewModel: TrendingShowsViewModel by fragmentViewModel()\n    @Inject lateinit var trendingShowsViewModelFactory: TrendingShowsViewModel.Factory\n\n    override fun onViewCreated(binding: FragmentEntryGridBinding, savedInstanceState: Bundle?) {\n        super.onViewCreated(binding, savedInstanceState)\n\n        binding.gridToolbar.apply {\n            setTitle(R.string.discover_trending_title)\n        }\n    }\n\n    override fun createController(): EntryGridEpoxyController<TrendingEntryWithShow> {\n        return object : EntryGridEpoxyController<TrendingEntryWithShow>() {\n            override fun buildItemModel(item: TrendingEntryWithShow): EpoxyModel<*> {\n                return PosterGridItemBindingModel_()\n                    .id(item.generateStableId())\n                    .posterImage(item.images.findHighestRatedPoster())\n                    .tiviShow(item.show)\n                    .transitionName(item.show.homepage)\n                    .selected(item.show.id in state.selectedShowIds)\n                    .clickListener(View.OnClickListener {\n                        if (viewModel.onItemClick(item.show)) {\n                            return@OnClickListener\n                        }\n                        onItemClicked(item)\n                    })\n                    .longClickListener(View.OnLongClickListener {\n                        viewModel.onItemLongClick(item.show)\n                    })\n            }\n        }\n    }\n\n    internal fun onItemClicked(item: TrendingEntryWithShow) {\n        val sharedElements = SharedElementHelper()\n        requireBinding().gridRecyclerview.findViewHolderForItemId(item.generateStableId())?.let {\n            sharedElements.addSharedElement(it.itemView, \"poster\")\n        }\n\n        findNavController().navigate(\n            \"app.tivi://show/${item.show.id}\".toUri(),\n            null,\n            sharedElements.toActivityNavigatorExtras(requireActivity())\n        )\n    }\n\n    override fun startSelectionActionMode(): ActionMode? {\n        return requireActivity().startActionMode(object : ActionMode.Callback {\n            override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {\n                when (item.itemId) {\n                    R.id.menu_follow -> viewModel.followSelectedShows()\n                }\n                return true\n            }\n\n            override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {\n                mode.menuInflater.inflate(R.menu.action_mode_entry, menu)\n                return true\n            }\n\n            override fun onPrepareActionMode(mode: ActionMode, menu: Menu) = true\n\n            override fun onDestroyActionMode(mode: ActionMode) {\n                viewModel.clearSelection()\n            }\n        })\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home.trending\n\nimport app.tivi.data.resultentities.TrendingEntryWithShow\nimport app.tivi.domain.interactors.ChangeShowFollowStatus\nimport app.tivi.domain.interactors.UpdateTrendingShows\nimport app.tivi.domain.interactors.UpdateTrendingShows.Page.NEXT_PAGE\nimport app.tivi.domain.interactors.UpdateTrendingShows.Page.REFRESH\nimport app.tivi.domain.observers.ObservePagedTrendingShows\nimport app.tivi.util.AppCoroutineDispatchers\nimport app.tivi.util.EntryViewModel\nimport app.tivi.util.EntryViewState\nimport app.tivi.util.Logger\nimport com.airbnb.mvrx.FragmentViewModelContext\nimport com.airbnb.mvrx.MvRxViewModelFactory\nimport com.airbnb.mvrx.ViewModelContext\nimport com.squareup.inject.assisted.Assisted\nimport com.squareup.inject.assisted.AssistedInject\n\nclass TrendingShowsViewModel @AssistedInject constructor(\n    @Assisted initialState: EntryViewState,\n    override val dispatchers: AppCoroutineDispatchers,\n    override val pagingInteractor: ObservePagedTrendingShows,\n    private val interactor: UpdateTrendingShows,\n    override val logger: Logger,\n    override val changeShowFollowStatus: ChangeShowFollowStatus\n) : EntryViewModel<TrendingEntryWithShow, ObservePagedTrendingShows>(initialState) {\n    init {\n        pagingInteractor(ObservePagedTrendingShows.Params(pageListConfig, boundaryCallback))\n\n        launchObserves()\n\n        refresh(false)\n    }\n\n    override fun callLoadMore() = interactor(UpdateTrendingShows.Params(NEXT_PAGE, true))\n\n    override fun callRefresh(fromUser: Boolean) = interactor(UpdateTrendingShows.Params(REFRESH, fromUser))\n\n    @AssistedInject.Factory\n    interface Factory {\n        fun create(initialState: EntryViewState): TrendingShowsViewModel\n    }\n\n    companion object : MvRxViewModelFactory<TrendingShowsViewModel, EntryViewState> {\n        override fun create(\n            viewModelContext: ViewModelContext,\n            state: EntryViewState\n        ): TrendingShowsViewModel? {\n            val fragment: TrendingShowsFragment = (viewModelContext as FragmentViewModelContext).fragment()\n            return fragment.trendingShowsViewModelFactory.create(state)\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.epoxy\n\nimport app.tivi.appinitializers.AppInitializer\nimport dagger.Binds\nimport dagger.Module\nimport dagger.multibindings.IntoSet\n\n@Module\nabstract class EpoxyModule {\n    @Binds\n    @IntoSet\n    abstract fun provideEpoxyInitializer(bind: EpoxyInitializer): AppInitializer\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.epoxy\n\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.core.view.isVisible\nimport androidx.recyclerview.widget.RecyclerView\nimport app.tivi.extensions.createAndBind\nimport com.airbnb.epoxy.EpoxyController\nimport com.airbnb.epoxy.EpoxyModel\n\n/**\n * Taken from https://gist.github.com/jonasbark/f1e1373705cfe8f6a7036763f7326f7c\n */\nclass StickyHeaderScrollListener(\n    private val epoxyController: EpoxyController,\n    private val isHeader: (EpoxyModel<*>) -> Boolean,\n    private val headerHolder: ViewGroup\n) : RecyclerView.OnScrollListener() {\n\n    init {\n        syncToHeaderHolder(null)\n    }\n\n    private var currentHeaderItemPosition = RecyclerView.NO_POSITION\n        set(position) {\n            if (field != position) {\n                currentHeaderHolder = null\n                if (position != RecyclerView.NO_POSITION) {\n                    currentHeaderHolder = epoxyController.adapter.createAndBind(headerHolder, position)\n                }\n                field = position\n            }\n        }\n\n    private var currentHeaderHolder: RecyclerView.ViewHolder? = null\n        set(value) {\n            if (field != value) {\n                syncToHeaderHolder(value)\n                field = value\n            }\n        }\n\n    private val currentHeaderHeight: Int\n        get() = headerHolder.height\n\n    override fun onScrolled(parent: RecyclerView, dx: Int, dy: Int) {\n        val topChild = parent.getChildAt(0) ?: return\n\n        val topChildPosition = parent.getChildAdapterPosition(topChild)\n        if (topChildPosition == RecyclerView.NO_POSITION) {\n            return\n        }\n\n        val headerPositionForChild = getHeaderPositionForItem(topChildPosition)\n        currentHeaderItemPosition = when {\n            headerPositionForChild == 0 && topChildPosition == 0 && topChild.top >= 0 -> RecyclerView.NO_POSITION\n            else -> headerPositionForChild\n        }\n\n        if (currentHeaderItemPosition != RecyclerView.NO_POSITION) {\n            val childInContact = getChildInContact(parent, currentHeaderHeight, currentHeaderItemPosition)\n            if (childInContact != null) {\n                val childContactPosition = parent.getChildAdapterPosition(childInContact)\n                if (isHeader(childContactPosition)) {\n                    headerHolder.translationY = (childInContact.top - currentHeaderHeight).toFloat()\n                } else {\n                    headerHolder.translationY = 0f\n                }\n            }\n        }\n    }\n\n    private fun isHeader(itemPosition: Int): Boolean {\n        if (itemPosition != RecyclerView.NO_POSITION) {\n            val model = epoxyController.adapter.getModelAtPosition(itemPosition)\n            return isHeader(model)\n        }\n        return false\n    }\n\n    private fun getChildInContact(\n        parent: RecyclerView,\n        contactPoint: Int,\n        currentHeaderPos: Int\n    ): View? {\n        for (i in 0 until parent.childCount) {\n            var heightTolerance = 0\n            val child = parent.getChildAt(i)\n\n            // measure height tolerance with child if child is another header\n            if (currentHeaderPos != i && isHeader(parent.getChildAdapterPosition(child))) {\n                heightTolerance = currentHeaderHeight - child.height\n            }\n\n            // add heightTolerance if child top be in display area\n            val childBottomPosition = if (child.top > 0) child.bottom + heightTolerance else child.bottom\n\n            if (childBottomPosition > contactPoint) {\n                if (child.top <= contactPoint) {\n                    // This child overlaps the contactPoint\n                    return child\n                }\n                break\n            }\n        }\n        return null\n    }\n\n    /**\n     * This method gets called by [StickyHeaderScrollListener] to fetch the position of the header item in the adapter\n     * that is used for (represents) item at specified position.\n     * @param itemPosition int. Adapter's position of the item for which to do the search of the position of the header item.\n     * @return int. Position of the header item in the adapter.\n     */\n    private fun getHeaderPositionForItem(itemPosition: Int): Int {\n        return (itemPosition downTo 0).firstOrNull(::isHeader) ?: RecyclerView.NO_POSITION\n    }\n\n    private fun syncToHeaderHolder(header: RecyclerView.ViewHolder?) {\n        if (header != null) {\n            if (headerHolder.indexOfChild(header.itemView) < 0) {\n                headerHolder.addView(header.itemView)\n            }\n            headerHolder.isVisible = true\n        } else {\n            if (headerHolder.childCount > 0) {\n                headerHolder.removeAllViews()\n            }\n            headerHolder.isVisible = false\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.epoxy\n\nimport androidx.recyclerview.widget.GridLayoutManager\nimport androidx.recyclerview.widget.RecyclerView\nimport com.airbnb.epoxy.EpoxyController\nimport com.airbnb.epoxy.EpoxyControllerAdapter\nimport com.airbnb.epoxy.EpoxyModel\n\n/** Add models to a CarouselModel_ by transforming a list of items into EpoxyModels.\n *\n * @param items The items to transform to models\n * @param modelBuilder A function that take an item and returns a new EpoxyModel for that item.\n */\ninline fun <T> TiviCarouselModelBuilder.withModelsFrom(\n    items: List<T>,\n    modelBuilder: (T) -> EpoxyModel<*>\n) {\n    models(items.map { modelBuilder(it) })\n}\n\nfun RecyclerView.syncSpanSizes(controller: EpoxyController) {\n    val layout = layoutManager\n    if (layout is GridLayoutManager) {\n        if (controller.spanCount != layout.spanCount ||\n            layout.spanSizeLookup !== controller.spanSizeLookup) {\n            controller.spanCount = layout.spanCount\n            layout.spanSizeLookup = controller.spanSizeLookup\n        }\n    }\n}\n\nfun EpoxyControllerAdapter.findPositionOfItemId(itemId: Long): Int {\n    return (0 until itemCount).firstOrNull { getItemId(it) == itemId }\n        ?: RecyclerView.NO_POSITION\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.epoxy\n\nimport com.airbnb.epoxy.EpoxyController\nimport kotlin.properties.ReadWriteProperty\nimport kotlin.reflect.KProperty\n\nclass EpoxyModelProperty<T>(default: () -> T) : ReadWriteProperty<EpoxyController, T> {\n    private var defaultProvider: (() -> T)? = default\n\n    private object UNASSIGNED\n\n    // backing field so we can distinguish between null and not yet set.\n    // This lets us defer calculating the default value\n    private var _value: Any? = UNASSIGNED\n        set(value) {\n            field = value\n            if (value != UNASSIGNED) {\n                // Clear the reference to the provider so that we don't hold on to it once a value is set\n                defaultProvider = null\n            }\n        }\n\n    private var value: T\n        set(value) {\n            _value = value\n        }\n        get() {\n            if (_value == UNASSIGNED) {\n                _value = defaultProvider?.invoke()\n            }\n\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun getValue(thisRef: EpoxyController, property: KProperty<*>): T = value\n\n    override fun setValue(thisRef: EpoxyController, property: KProperty<*>, value: T) {\n        if (this.value != value) {\n            this.value = value\n            thisRef.requestModelBuild()\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.epoxy\n\nimport com.airbnb.epoxy.EpoxyController\n\nobject EmptyEpoxyController : EpoxyController() {\n    override fun buildModels() {\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.epoxy\n\nimport android.graphics.Canvas\nimport android.graphics.Paint\nimport android.graphics.Rect\nimport android.graphics.RectF\nimport android.graphics.drawable.Drawable\nimport android.view.View\nimport androidx.annotation.ColorInt\nimport app.tivi.ui.animations.lerp\nimport com.airbnb.epoxy.EpoxyModel\nimport com.airbnb.epoxy.EpoxyTouchHelper\nimport kotlin.math.roundToInt\n\nabstract class SwipeAwayCallbacks<T : EpoxyModel<*>>(\n    private val icon: Drawable,\n    private val padding: Int,\n    @ColorInt private val backgroundColor: Int,\n    @ColorInt private val accentColor: Int\n) : EpoxyTouchHelper.SwipeCallbacks<T>() {\n    private val rect = RectF()\n    private val iconBounds = Rect()\n\n    private val iconHeight = icon.intrinsicHeight\n    private val iconWidth = icon.intrinsicWidth\n\n    private val backgroundPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {\n        color = backgroundColor\n    }\n\n    private val foregroundPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {\n        color = accentColor\n    }\n\n    companion object {\n        const val MAX_ICON_SCALE = 1.3f\n        const val MIN_ICON_SCALE = 0.8f\n    }\n\n    override fun onSwipeProgressChanged(\n        model: T,\n        itemView: View,\n        swipeProgress: Float,\n        canvas: Canvas\n    ) {\n        rect.set(itemView.left.toFloat(), itemView.top.toFloat(), itemView.right.toFloat(), itemView.bottom.toFloat())\n        rect.offset(itemView.translationX, itemView.translationY)\n\n        if (rect.left == 0f || rect.right == canvas.width.toFloat()) {\n            return\n        }\n\n        var radius = 0f\n\n        val save = canvas.save()\n\n        if (rect.left > 0) {\n            // Swiping left-to-right\n            rect.right = rect.left\n            rect.left = 0f\n\n            canvas.clipRect(rect)\n\n            val startValue = iconBounds.right + padding / 2\n            val endValue = rect.left + itemView.width / 2\n            if (rect.right >= startValue) {\n                val fraction = ((rect.right - startValue) / (endValue - startValue)).coerceIn(0f, 1f)\n                val maxRadius = Math.hypot(rect.right.toDouble() - iconBounds.centerX(), iconBounds.centerY().toDouble())\n                radius = lerp(0f, maxRadius.toFloat(), fraction)\n            }\n\n            val left = rect.left.roundToInt() + padding\n            val top = (rect.top + (rect.height() - iconHeight) / 2).roundToInt()\n            iconBounds.set(left, top, left + iconWidth, top + iconHeight)\n            icon.bounds = iconBounds\n        } else if (rect.right < canvas.width) {\n            // Swiping right-to-left\n            rect.left = rect.right\n            rect.right = canvas.width.toFloat()\n\n            canvas.clipRect(rect)\n\n            val startValue = iconBounds.left - padding / 2\n            val endValue = rect.right - itemView.width / 2\n            if (rect.left <= startValue) {\n                val fraction = ((rect.left - startValue) / (endValue - startValue)).coerceIn(0f, 1f)\n                val maxRadius = Math.hypot(iconBounds.centerX() - rect.left.toDouble(), iconBounds.centerY().toDouble())\n                radius = lerp(0f, maxRadius.toFloat(), fraction)\n            }\n\n            val right = rect.right.roundToInt() - padding\n            val top = (rect.top + (rect.height() - iconHeight) / 2).roundToInt()\n            iconBounds.set(right - iconWidth, top, right, top + iconHeight)\n            icon.bounds = iconBounds\n        }\n\n        // Draw the background color\n        canvas.drawRect(rect, backgroundPaint)\n\n        if (radius > 0) {\n            canvas.drawCircle(iconBounds.centerX().toFloat(), iconBounds.centerY().toFloat(), radius, foregroundPaint)\n        }\n\n        // Now draw the icon\n        icon.draw(canvas)\n\n        canvas.restoreToCount(save)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.epoxy\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport android.view.View\nimport androidx.annotation.Dimension\nimport com.airbnb.epoxy.Carousel\nimport com.airbnb.epoxy.ModelProp\nimport com.airbnb.epoxy.ModelView\n\n@ModelView(saveViewState = true, autoLayout = ModelView.Size.MATCH_WIDTH_WRAP_HEIGHT)\nclass TiviCarousel @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyle: Int = 0\n) : Carousel(context, attrs, defStyle) {\n\n    @Dimension(unit = Dimension.PX)\n    @set:ModelProp\n    var itemWidth: Int = 0\n\n    override fun onChildAttachedToWindow(child: View) {\n        check(!(itemWidth > 0 && numViewsToShowOnScreen > 0)) {\n            \"Can't use itemWidth and numViewsToShowOnScreen together\"\n        }\n        if (itemWidth > 0) {\n            val childLayoutParams = child.layoutParams\n            childLayoutParams.width = itemWidth\n        }\n        super.onChildAttachedToWindow(child)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.epoxy\n\nimport android.app.Application\nimport android.content.Context\nimport android.view.Gravity\nimport androidx.recyclerview.widget.SnapHelper\nimport app.tivi.appinitializers.AppInitializer\nimport com.airbnb.epoxy.Carousel\nimport com.airbnb.epoxy.EpoxyAsyncUtil\nimport com.airbnb.epoxy.EpoxyController\nimport com.github.rubensousa.gravitysnaphelper.GravitySnapHelper\nimport javax.inject.Inject\n\nclass EpoxyInitializer @Inject constructor() : AppInitializer {\n    override fun init(application: Application) {\n        // Make EpoxyController diffing async by default\n        val asyncHandler = EpoxyAsyncUtil.getAsyncBackgroundHandler()\n        EpoxyController.defaultDiffingHandler = asyncHandler\n\n        // Also setup Carousel to use a more sane snapping behavior\n        Carousel.setDefaultGlobalSnapHelperFactory(object : Carousel.SnapHelperFactory() {\n            override fun buildSnapHelper(context: Context): SnapHelper {\n                return GravitySnapHelper(Gravity.START).apply {\n                    scrollMsPerInch = 70f\n                }\n            }\n        })\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.common.epoxy\n\nimport com.airbnb.epoxy.EpoxyModel\n\nobject TotalSpanOverride : EpoxyModel.SpanSizeOverrideCallback {\n    override fun getSpanSize(totalSpanCount: Int, position: Int, itemCount: Int) = totalSpanCount\n}\n\nobject HalfSpanOverride : EpoxyModel.SpanSizeOverrideCallback {\n    override fun getSpanSize(\n        totalSpanCount: Int,\n        position: Int,\n        itemCount: Int\n    ) = (totalSpanCount / 2).coerceAtLeast(1)\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport app.tivi.data.entities.TiviEntity\n\ninterface Entry : TiviEntity {\n    val showId: Long\n}\n\ninterface MultipleEntry : Entry {\n    val otherShowId: Long\n}\n\ninterface PaginatedEntry : Entry {\n    val page: Int\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport app.tivi.data.repositories.episodes.EpisodesModule\nimport app.tivi.data.repositories.popularshows.PopularShowsModule\nimport app.tivi.data.repositories.recommendedshows.RecommendedShowsModule\nimport app.tivi.data.repositories.relatedshows.RelatedShowsModule\nimport app.tivi.data.repositories.showimages.ShowsImagesModule\nimport app.tivi.data.repositories.shows.ShowsModule\nimport app.tivi.data.repositories.trendingshows.TrendingShowsModule\nimport app.tivi.data.repositories.watchedshows.WatchedShowsModule\nimport app.tivi.inject.ForStore\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\nimport kotlin.coroutines.EmptyCoroutineContext\nimport kotlinx.coroutines.CoroutineScope\n\n@Module(includes = [\n    EpisodesModule::class,\n    ShowsModule::class,\n    ShowsImagesModule::class,\n    TrendingShowsModule::class,\n    WatchedShowsModule::class,\n    RecommendedShowsModule::class,\n    RelatedShowsModule::class,\n    PopularShowsModule::class\n])\nclass DataModule {\n    @ForStore\n    @Singleton\n    @Provides\n    fun providesStoreDispatcher(): CoroutineScope = CoroutineScope(EmptyCoroutineContext)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.syncers\n\nimport app.tivi.data.daos.EntityDao\nimport app.tivi.data.entities.TiviEntity\nimport app.tivi.util.Logger\n\n/**\n * @param NetworkType Network type\n * @param LocalType local entity type\n * @param Key Network ID type\n */\nclass ItemSyncer<LocalType : TiviEntity, NetworkType, Key>(\n    private val insertEntity: suspend (LocalType) -> Long,\n    private val updateEntity: suspend (LocalType) -> Unit,\n    private val deleteEntity: suspend (LocalType) -> Int,\n    private val localEntityToKey: suspend (LocalType) -> Key?,\n    private val networkEntityToKey: suspend (NetworkType) -> Key,\n    private val networkEntityToLocalEntity: suspend (NetworkType, Long?) -> LocalType,\n    private val logger: Logger\n) {\n    suspend fun sync(\n        currentValues: Collection<LocalType>,\n        networkValues: Collection<NetworkType>,\n        removeNotMatched: Boolean = true\n    ): ItemSyncerResult<LocalType> {\n        val currentDbEntities = ArrayList(currentValues)\n\n        val removed = ArrayList<LocalType>()\n        val added = ArrayList<LocalType>()\n        val updated = ArrayList<LocalType>()\n\n        for (networkEntity in networkValues) {\n            logger.v(\"Syncing item from network: %s\", networkEntity)\n\n            val remoteId = networkEntityToKey(networkEntity)\n            logger.v(\"Mapped to remote ID: %s\", remoteId)\n            if (remoteId == null) {\n                break\n            }\n\n            val dbEntityForId = currentDbEntities.find {\n                localEntityToKey(it) == remoteId\n            }\n            logger.v(\"Matched database entity for remote ID %s : %s\", remoteId, dbEntityForId)\n\n            if (dbEntityForId != null) {\n                val entity = networkEntityToLocalEntity(networkEntity, dbEntityForId.id)\n                logger.v(\"Mapped network entity to local entity: %s\", entity)\n                if (dbEntityForId != entity) {\n                    // This is currently in the DB, so lets merge it with the saved version\n                    // and update it\n                    updateEntity(entity)\n                    logger.v(\"Updated entry with remote id: %s\", remoteId)\n                }\n                // Remove it from the list so that it is not deleted\n                currentDbEntities.remove(dbEntityForId)\n                updated += entity\n            } else {\n                // Not currently in the DB, so lets insert\n                added += networkEntityToLocalEntity(networkEntity, null)\n            }\n        }\n\n        if (removeNotMatched) {\n            // Anything left in the set needs to be deleted from the database\n            currentDbEntities.forEach {\n                deleteEntity(it)\n                logger.v(\"Deleted entry: \", it)\n                removed += it\n            }\n        }\n\n        // Finally we can insert all of the new entities\n        added.forEach {\n            insertEntity(it)\n        }\n\n        return ItemSyncerResult(added, removed, updated)\n    }\n}\n\ndata class ItemSyncerResult<ET : TiviEntity>(\n    val added: List<ET> = emptyList(),\n    val deleted: List<ET> = emptyList(),\n    val updated: List<ET> = emptyList()\n)\n\nfun <LocalType : TiviEntity, NetworkType, Key> syncerForEntity(\n    entityDao: EntityDao<LocalType>,\n    localEntityToKey: suspend (LocalType) -> Key?,\n    networkEntityToKey: suspend (NetworkType) -> Key,\n    networkEntityToLocalEntity: suspend (NetworkType, Long?) -> LocalType,\n    logger: Logger\n) = ItemSyncer(\n    entityDao::insert,\n    entityDao::update,\n    entityDao::deleteEntity,\n    localEntityToKey,\n    networkEntityToKey,\n    networkEntityToLocalEntity,\n    logger\n)\n\nfun <Type : TiviEntity, Key> syncerForEntity(\n    entityDao: EntityDao<Type>,\n    entityToKey: suspend (Type) -> Key?,\n    mapper: suspend (Type, Long?) -> Type,\n    logger: Logger\n) = ItemSyncer(\n    entityDao::insert,\n    entityDao::update,\n    entityDao::deleteEntity,\n    entityToKey,\n    entityToKey,\n    mapper,\n    logger\n)",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport app.tivi.data.daos.EpisodeWatchEntryDao\nimport app.tivi.data.daos.EpisodesDao\nimport app.tivi.data.daos.FollowedShowsDao\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.daos.PopularDao\nimport app.tivi.data.daos.RecommendedDao\nimport app.tivi.data.daos.RelatedShowsDao\nimport app.tivi.data.daos.SeasonsDao\nimport app.tivi.data.daos.ShowFtsDao\nimport app.tivi.data.daos.ShowImagesDao\nimport app.tivi.data.daos.TiviShowDao\nimport app.tivi.data.daos.TrendingDao\nimport app.tivi.data.daos.UserDao\nimport app.tivi.data.daos.WatchedShowDao\n\ninterface TiviDatabase {\n    fun showDao(): TiviShowDao\n    fun showFtsDao(): ShowFtsDao\n    fun showImagesDao(): ShowImagesDao\n    fun trendingDao(): TrendingDao\n    fun popularDao(): PopularDao\n    fun userDao(): UserDao\n    fun watchedShowsDao(): WatchedShowDao\n    fun followedShowsDao(): FollowedShowsDao\n    fun seasonsDao(): SeasonsDao\n    fun episodesDao(): EpisodesDao\n    fun relatedShowsDao(): RelatedShowsDao\n    fun episodeWatchesDao(): EpisodeWatchEntryDao\n    fun lastRequestDao(): LastRequestDao\n    fun recommendedShowsDao(): RecommendedDao\n}",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.popularshows\n\nimport app.tivi.data.daos.PopularDao\nimport app.tivi.data.daos.TiviShowDao\nimport app.tivi.data.entities.PopularShowEntry\nimport app.tivi.data.entities.Success\nimport app.tivi.inject.ForStore\nimport com.dropbox.android.external.store4.Store\nimport com.dropbox.android.external.store4.StoreBuilder\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\n\ntypealias PopularShowsStore = Store<Int, List<PopularShowEntry>>\n\n@Module\ninternal class PopularShowsModule {\n    @Provides\n    @Singleton\n    fun providePopularShowsStore(\n        traktPopularShows: TraktPopularShowsDataSource,\n        popularShowsDao: PopularDao,\n        showDao: TiviShowDao,\n        lastRequestStore: PopularShowsLastRequestStore,\n        @ForStore scope: CoroutineScope\n    ): PopularShowsStore {\n        return StoreBuilder.fromNonFlow { page: Int ->\n            val response = traktPopularShows(page, 20)\n            if (page == 0 && response is Success) {\n                lastRequestStore.updateLastRequest()\n            }\n            response.getOrThrow()\n        }.persister(\n            reader = popularShowsDao::entriesObservable,\n            writer = { page, response ->\n                popularShowsDao.withTransaction {\n                    val entries = response.map { (show, entry) ->\n                        entry.copy(showId = showDao.getIdOrSavePlaceholder(show), page = page)\n                    }\n                    if (page == 0) {\n                        // If we've requested page 0, remove any existing entries first\n                        popularShowsDao.deleteAll()\n                        popularShowsDao.insertAll(entries)\n                    } else {\n                        popularShowsDao.updatePage(page, entries)\n                    }\n                }\n            },\n            delete = popularShowsDao::deletePage,\n            deleteAll = popularShowsDao::deleteAll\n        ).scope(scope).build()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.popularshows\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.GroupLastRequestStore\nimport javax.inject.Inject\n\nclass PopularShowsLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : GroupLastRequestStore(Request.POPULAR_SHOWS, dao)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.popularshows\n\nimport app.tivi.data.entities.PopularShowEntry\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.mappers.IndexedMapper\nimport app.tivi.data.mappers.TraktShowToTiviShow\nimport app.tivi.data.mappers.pairMapperOf\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.trakt5.entities.Show\nimport com.uwetrottmann.trakt5.enums.Extended\nimport com.uwetrottmann.trakt5.services.Shows\nimport javax.inject.Inject\nimport javax.inject.Provider\n\ninternal class TraktPopularShowsDataSource @Inject constructor(\n    private val showService: Provider<Shows>,\n    private val showMapper: TraktShowToTiviShow\n) {\n    private val entryMapper = object : IndexedMapper<Show, PopularShowEntry> {\n        override suspend fun map(index: Int, from: Show): PopularShowEntry {\n            return PopularShowEntry(showId = 0, pageOrder = index, page = 0)\n        }\n    }\n\n    private val resultsMapper = pairMapperOf(showMapper, entryMapper)\n\n    suspend operator fun invoke(\n        page: Int,\n        pageSize: Int\n    ): Result<List<Pair<TiviShow, PopularShowEntry>>> {\n        return showService.get().popular(page + 1, pageSize, Extended.NOSEASONS)\n            .executeWithRetry()\n            .toResult(resultsMapper)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.traktusers\n\nimport app.tivi.data.daos.UserDao\nimport app.tivi.data.entities.TraktUser\nimport javax.inject.Inject\n\nclass TraktUsersStore @Inject constructor(\n    private val userDao: UserDao\n) {\n    fun observeUser(username: String) = when (username) {\n        \"me\" -> userDao.observeMe()\n        else -> userDao.observeTraktUser(username)\n    }\n\n    suspend fun getUser(username: String) = when (username) {\n        \"me\" -> userDao.getMe()\n        else -> userDao.getTraktUser(username)\n    }\n\n    suspend fun getIdForUsername(username: String) = when (username) {\n        \"me\" -> userDao.getIdForMe()\n        else -> userDao.getIdForUsername(username)\n    }\n\n    suspend fun save(user: TraktUser) = userDao.insertOrUpdate(user)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.traktusers\n\nimport app.tivi.data.entities.Success\nimport app.tivi.extensions.asyncOrAwait\nimport javax.inject.Inject\nimport javax.inject.Singleton\nimport org.threeten.bp.Instant\nimport org.threeten.bp.Period\n\n@Singleton\nclass TraktUsersRepository @Inject constructor(\n    private val traktUsersStore: TraktUsersStore,\n    private val lastRequestStore: TraktUsersLastRequestStore,\n    private val traktDataSource: TraktUsersDataSource\n) {\n    fun observeUser(username: String) = traktUsersStore.observeUser(username)\n\n    suspend fun updateUser(username: String) {\n        asyncOrAwait(\"update_user_$username\") {\n            when (val response = traktDataSource.getUser(username)) {\n                is Success -> {\n                    var user = response.data\n                    // Tag the user as 'me' if that's what we're requesting\n                    if (username == \"me\") {\n                        user = user.copy(isMe = true)\n                    }\n                    // Make sure we use the current DB id (if present)\n                    val localUser = traktUsersStore.getUser(user.username)\n                    if (localUser != null) {\n                        user = user.copy(id = localUser.id)\n                    }\n                    val id = traktUsersStore.save(user)\n                    lastRequestStore.updateLastRequest(id, Instant.now())\n                }\n            }\n        }\n    }\n\n    suspend fun needUpdate(username: String): Boolean {\n        return traktUsersStore.getIdForUsername(username)?.let {\n            lastRequestStore.isRequestExpired(it, Period.ofDays(7))\n        } ?: true\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.traktusers\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.EntityLastRequestStore\nimport javax.inject.Inject\n\nclass TraktUsersLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : EntityLastRequestStore(Request.USER_PROFILE, dao)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.traktusers\n\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.TraktUser\nimport app.tivi.data.mappers.UserToTraktUser\nimport app.tivi.data.mappers.toLambda\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.trakt5.entities.UserSlug\nimport com.uwetrottmann.trakt5.enums.Extended\nimport com.uwetrottmann.trakt5.services.Users\nimport javax.inject.Inject\nimport javax.inject.Provider\n\nclass TraktUsersDataSource @Inject constructor(\n    private val usersService: Provider<Users>,\n    private val mapper: UserToTraktUser\n) {\n    suspend fun getUser(slug: String): Result<TraktUser> {\n        return usersService.get().profile(UserSlug(slug), Extended.FULL)\n            .executeWithRetry()\n            .toResult(mapper.toLambda())\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.lastrequests\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.LastRequest\nimport app.tivi.data.entities.Request\nimport app.tivi.data.inPast\nimport org.threeten.bp.Instant\nimport org.threeten.bp.temporal.TemporalAmount\n\nopen class GroupLastRequestStore(\n    private val request: Request,\n    private val dao: LastRequestDao\n) {\n    suspend fun getRequestInstant(): Instant? {\n        return dao.lastRequest(request, DEFAULT_ID)?.timestamp\n    }\n\n    suspend fun isRequestExpired(threshold: TemporalAmount): Boolean {\n        return isRequestBefore(threshold.inPast())\n    }\n\n    suspend fun isRequestBefore(instant: Instant): Boolean {\n        return getRequestInstant()?.isBefore(instant) ?: true\n    }\n\n    suspend fun updateLastRequest(timestamp: Instant = Instant.now()) {\n        dao.insert(LastRequest(request = request, entityId = DEFAULT_ID, timestamp = timestamp))\n    }\n\n    suspend fun invalidateLastRequest() = updateLastRequest(Instant.EPOCH)\n\n    companion object {\n        private const val DEFAULT_ID = 0L\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.lastrequests\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.LastRequest\nimport app.tivi.data.entities.Request\nimport app.tivi.data.inPast\nimport org.threeten.bp.Instant\nimport org.threeten.bp.temporal.TemporalAmount\n\nopen class EntityLastRequestStore(\n    private val request: Request,\n    private val dao: LastRequestDao\n) {\n    suspend fun getRequestInstant(entityId: Long): Instant? {\n        return dao.lastRequest(request, entityId)?.timestamp\n    }\n\n    suspend fun isRequestExpired(entityId: Long, threshold: TemporalAmount): Boolean {\n        return isRequestBefore(entityId, threshold.inPast())\n    }\n\n    suspend fun hasBeenRequested(entityId: Long): Boolean = dao.requestCount(request, entityId) > 0\n\n    suspend fun isRequestBefore(entityId: Long, instant: Instant): Boolean {\n        return getRequestInstant(entityId)?.isBefore(instant) ?: true\n    }\n\n    suspend fun updateLastRequest(entityId: Long, timestamp: Instant = Instant.now()) {\n        dao.insert(LastRequest(request = request, entityId = entityId, timestamp = timestamp))\n    }\n\n    suspend fun invalidateLastRequest(entityId: Long) = updateLastRequest(entityId, Instant.EPOCH)\n}",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.recommendedshows\n\nimport app.tivi.data.daos.RecommendedDao\nimport app.tivi.data.daos.TiviShowDao\nimport app.tivi.data.entities.RecommendedShowEntry\nimport app.tivi.data.entities.Success\nimport app.tivi.inject.ForStore\nimport com.dropbox.android.external.store4.Store\nimport com.dropbox.android.external.store4.StoreBuilder\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\n\ntypealias RecommendedShowsStore = Store<Int, List<RecommendedShowEntry>>\n\n@Module\ninternal class RecommendedShowsModule {\n    @Provides\n    @Singleton\n    fun provideRecommendedShowsStore(\n        traktRecommendedShows: TraktRecommendedShowsDataSource,\n        recommendedDao: RecommendedDao,\n        showDao: TiviShowDao,\n        lastRequestStore: RecommendedShowsLastRequestStore,\n        @ForStore scope: CoroutineScope\n    ): RecommendedShowsStore {\n        return StoreBuilder.fromNonFlow { page: Int ->\n            val response = traktRecommendedShows(page, 20)\n            if (page == 0 && response is Success) {\n                lastRequestStore.updateLastRequest()\n            }\n            response.getOrThrow()\n        }.persister(\n            reader = recommendedDao::entriesForPage,\n            writer = { page, response ->\n                recommendedDao.withTransaction {\n                    val entries = response.map { show ->\n                        val showId = showDao.getIdOrSavePlaceholder(show)\n                        RecommendedShowEntry(showId = showId, page = page)\n                    }\n                    if (page == 0) {\n                        // If we've requested page 0, remove any existing entries first\n                        recommendedDao.deleteAll()\n                        recommendedDao.insertAll(entries)\n                    } else {\n                        recommendedDao.updatePage(page, entries)\n                    }\n                }\n            },\n            delete = recommendedDao::deletePage,\n            deleteAll = recommendedDao::deleteAll\n        ).scope(scope).build()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.recommendedshows\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.GroupLastRequestStore\nimport javax.inject.Inject\n\nclass RecommendedShowsLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : GroupLastRequestStore(Request.RECOMMENDED_SHOWS, dao)",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.recommendedshows\n\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.mappers.TraktShowToTiviShow\nimport app.tivi.data.mappers.forLists\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.trakt5.services.Recommendations\nimport javax.inject.Inject\nimport javax.inject.Provider\n\ninternal class TraktRecommendedShowsDataSource @Inject constructor(\n    private val recommendationsService: Provider<Recommendations>,\n    private val showMapper: TraktShowToTiviShow\n) {\n    suspend operator fun invoke(page: Int, pageSize: Int): Result<List<TiviShow>> {\n        // We add 1 because Trakt uses a 1-based index whereas we use a 0-based index\n        return recommendationsService.get().shows(page + 1, pageSize, null)\n            .executeWithRetry()\n            .toResult(showMapper.forLists())\n    }\n}",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.relatedshows\n\nimport app.tivi.data.daos.RelatedShowsDao\nimport app.tivi.data.daos.TiviShowDao\nimport app.tivi.data.entities.RelatedShowEntry\nimport app.tivi.data.entities.Success\nimport app.tivi.inject.ForStore\nimport com.dropbox.android.external.store4.Store\nimport com.dropbox.android.external.store4.StoreBuilder\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\n\ntypealias RelatedShowsStore = Store<Long, List<RelatedShowEntry>>\n\n@Module\ninternal class RelatedShowsModule {\n    @Provides\n    @Singleton\n    fun provideRelatedShowsStore(\n        traktRelatedShows: TraktRelatedShowsDataSource,\n        relatedShowsDao: RelatedShowsDao,\n        showDao: TiviShowDao,\n        lastRequestStore: RelatedShowsLastRequestStore,\n        @ForStore scope: CoroutineScope\n    ): RelatedShowsStore {\n        return StoreBuilder.fromNonFlow { showId: Long ->\n            val response = traktRelatedShows(showId)\n            if (response is Success) {\n                lastRequestStore.updateLastRequest(showId)\n            }\n            response.getOrThrow()\n        }.persister(\n            reader = relatedShowsDao::entriesObservable,\n            writer = { showId, response ->\n                relatedShowsDao.withTransaction {\n                    val entries = response.map { (show, entry) ->\n                        entry.copy(\n                            showId = showId,\n                            otherShowId = showDao.getIdOrSavePlaceholder(show)\n                        )\n                    }\n                    relatedShowsDao.deleteWithShowId(showId)\n                    relatedShowsDao.insertOrUpdate(entries)\n                }\n            },\n            delete = relatedShowsDao::deleteWithShowId,\n            deleteAll = relatedShowsDao::deleteAll\n        ).scope(scope).build()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.relatedshows\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.EntityLastRequestStore\nimport javax.inject.Inject\n\nclass RelatedShowsLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : EntityLastRequestStore(Request.RELATED_SHOWS, dao)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.relatedshows\n\nimport app.tivi.data.entities.ErrorResult\nimport app.tivi.data.entities.RelatedShowEntry\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.mappers.IndexedMapper\nimport app.tivi.data.mappers.ShowIdToTraktIdMapper\nimport app.tivi.data.mappers.TraktShowToTiviShow\nimport app.tivi.data.mappers.pairMapperOf\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.trakt5.entities.Show\nimport com.uwetrottmann.trakt5.enums.Extended\nimport com.uwetrottmann.trakt5.services.Shows\nimport javax.inject.Inject\nimport javax.inject.Provider\n\ninternal class TraktRelatedShowsDataSource @Inject constructor(\n    private val traktIdMapper: ShowIdToTraktIdMapper,\n    private val showService: Provider<Shows>,\n    private val showMapper: TraktShowToTiviShow\n) {\n    private val entryMapper = object : IndexedMapper<Show, RelatedShowEntry> {\n        override suspend fun map(index: Int, from: Show): RelatedShowEntry {\n            return RelatedShowEntry(showId = 0, otherShowId = 0, orderIndex = index)\n        }\n    }\n    private val resultMapper = pairMapperOf(showMapper, entryMapper)\n\n    suspend operator fun invoke(showId: Long): Result<List<Pair<TiviShow, RelatedShowEntry>>> {\n        val traktId = traktIdMapper.map(showId)\n            ?: return ErrorResult(IllegalArgumentException(\"No Trakt ID for show with ID: $showId\"))\n        return showService.get().related(traktId.toString(), 0, 10, Extended.NOSEASONS)\n            .executeWithRetry()\n            .toResult(resultMapper)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.ErrorResult\nimport app.tivi.data.entities.Result\nimport app.tivi.data.mappers.ShowIdToTraktIdMapper\nimport app.tivi.data.mappers.TraktEpisodeToEpisode\nimport app.tivi.data.mappers.toLambda\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.trakt5.enums.Extended\nimport com.uwetrottmann.trakt5.services.Episodes\nimport javax.inject.Inject\nimport javax.inject.Provider\n\nclass TraktEpisodeDataSource @Inject constructor(\n    private val traktIdMapper: ShowIdToTraktIdMapper,\n    private val service: Provider<Episodes>,\n    private val episodeMapper: TraktEpisodeToEpisode\n) : EpisodeDataSource {\n    override suspend fun getEpisode(\n        showId: Long,\n        seasonNumber: Int,\n        episodeNumber: Int\n    ): Result<Episode> {\n        val traktId = traktIdMapper.map(showId)\n            ?: return ErrorResult(IllegalArgumentException(\"No Trakt ID for show with ID: $showId\"))\n\n        return service.get().summary(traktId.toString(), seasonNumber, episodeNumber, Extended.FULL)\n            .executeWithRetry()\n            .toResult(episodeMapper.toLambda())\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.Season\nimport org.threeten.bp.OffsetDateTime\n\ninterface SeasonsEpisodesDataSource {\n    suspend fun getSeasonsEpisodes(showId: Long): Result<List<Pair<Season, List<Episode>>>>\n    suspend fun getShowEpisodeWatches(\n        showId: Long,\n        since: OffsetDateTime? = null\n    ): Result<List<Pair<Episode, EpisodeWatchEntry>>>\n\n    suspend fun getEpisodeWatches(\n        episodeId: Long,\n        since: OffsetDateTime? = null\n    ): Result<List<EpisodeWatchEntry>>\n\n    suspend fun getSeasonWatches(\n        seasonId: Long,\n        since: OffsetDateTime? = null\n    ): Result<List<Pair<Episode, EpisodeWatchEntry>>>\n\n    suspend fun addEpisodeWatches(watches: List<EpisodeWatchEntry>): Result<Unit>\n    suspend fun removeEpisodeWatches(watches: List<EpisodeWatchEntry>): Result<Unit>\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Result\n\ninterface EpisodeDataSource {\n    suspend fun getEpisode(showId: Long, seasonNumber: Int, episodeNumber: Int): Result<Episode>\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.inject.Tmdb\nimport app.tivi.inject.Trakt\nimport dagger.Binds\nimport dagger.Module\n\n@Module\nabstract class EpisodesModule {\n    @Binds\n    @Trakt\n    abstract fun bindTraktEpisodeDataSource(source: TraktEpisodeDataSource): EpisodeDataSource\n\n    @Binds\n    @Tmdb\n    abstract fun bindTmdbEpisodeDataSource(source: TmdbEpisodeDataSource): EpisodeDataSource\n\n    @Binds\n    abstract fun bindSeasonsEpisodesDataSource(source: TraktSeasonsEpisodesDataSource): SeasonsEpisodesDataSource\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.EntityLastRequestStore\nimport javax.inject.Inject\n\nclass SeasonsLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : EntityLastRequestStore(Request.SHOW_SEASONS, dao)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.data.DatabaseTransactionRunner\nimport app.tivi.data.entities.ActionDate\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.entities.PendingAction\nimport app.tivi.data.entities.RefreshType\nimport app.tivi.data.entities.Season\nimport app.tivi.data.entities.Success\nimport app.tivi.data.instantInPast\nimport app.tivi.extensions.asyncOrAwait\nimport app.tivi.inject.Tmdb\nimport app.tivi.inject.Trakt\nimport app.tivi.trakt.TraktAuthState\nimport javax.inject.Inject\nimport javax.inject.Provider\nimport javax.inject.Singleton\nimport kotlinx.coroutines.async\nimport org.threeten.bp.Instant\nimport org.threeten.bp.OffsetDateTime\n\n@Singleton\nclass SeasonsEpisodesRepository @Inject constructor(\n    private val episodeWatchStore: EpisodeWatchStore,\n    private val episodeWatchLastLastRequestStore: EpisodeWatchLastRequestStore,\n    private val seasonsEpisodesStore: SeasonsEpisodesStore,\n    private val seasonsLastRequestStore: SeasonsLastRequestStore,\n    private val traktSeasonsDataSource: SeasonsEpisodesDataSource,\n    @Trakt private val traktEpisodeDataSource: EpisodeDataSource,\n    @Tmdb private val tmdbEpisodeDataSource: EpisodeDataSource,\n    private val traktAuthState: Provider<TraktAuthState>,\n    private val transactionRunner: DatabaseTransactionRunner\n) {\n    fun observeSeasonsForShow(showId: Long) = seasonsEpisodesStore.observeShowSeasonsWithEpisodes(showId)\n\n    fun observeEpisode(episodeId: Long) = seasonsEpisodesStore.observeEpisode(episodeId)\n\n    suspend fun getEpisode(episodeId: Long): Episode? = seasonsEpisodesStore.getEpisode(episodeId)\n\n    fun observeEpisodeWatches(episodeId: Long) = episodeWatchStore.observeEpisodeWatches(episodeId)\n\n    fun observeNextEpisodeToWatch(showId: Long) = seasonsEpisodesStore.observeShowNextEpisodeToWatch(showId)\n\n    suspend fun needShowSeasonsUpdate(\n        showId: Long,\n        expiry: Instant = instantInPast(days = 7)\n    ): Boolean {\n        return seasonsLastRequestStore.isRequestBefore(showId, expiry)\n    }\n\n    suspend fun removeShowSeasonData(showId: Long) {\n        seasonsEpisodesStore.deleteShowSeasonData(showId)\n    }\n\n    suspend fun updateSeasonsEpisodes(showId: Long) {\n        asyncOrAwait(\"update_show_seasons_$showId\") {\n            when (val result = traktSeasonsDataSource.getSeasonsEpisodes(showId)) {\n                is Success -> {\n                    result.data.distinctBy { it.first.number }.associate { (season, episodes) ->\n                        val localSeason = seasonsEpisodesStore.getSeasonWithTraktId(season.traktId!!)\n                            ?: Season(showId = showId)\n                        val mergedSeason = mergeSeason(localSeason, season, Season.EMPTY)\n\n                        val mergedEpisodes = episodes.distinctBy(Episode::number).map {\n                            val localEpisode = seasonsEpisodesStore.getEpisodeWithTraktId(it.traktId!!)\n                                ?: Episode(seasonId = mergedSeason.id)\n                            mergeEpisode(localEpisode, it, Episode.EMPTY)\n                        }\n                        mergedSeason to mergedEpisodes\n                    }.also { seasonsEpisodesStore.save(showId, it) }\n\n                    seasonsLastRequestStore.updateLastRequest(showId)\n                }\n            }\n        }\n    }\n\n    suspend fun updateEpisode(episodeId: Long) {\n        asyncOrAwait(\"update_episode_$episodeId\") {\n            val local = seasonsEpisodesStore.getEpisode(episodeId)!!\n            val season = seasonsEpisodesStore.getSeason(local.seasonId)!!\n            val traktResult = async {\n                traktEpisodeDataSource.getEpisode(season.showId, season.number!!, local.number!!)\n            }\n            val tmdbResult = async {\n                tmdbEpisodeDataSource.getEpisode(season.showId, season.number!!, local.number!!)\n            }\n\n            val trakt = traktResult.await().let {\n                if (it is Success) it.data else Episode.EMPTY\n            }\n            val tmdb = tmdbResult.await().let {\n                if (it is Success) it.data else Episode.EMPTY\n            }\n\n            seasonsEpisodesStore.save(mergeEpisode(local, trakt, tmdb))\n        }\n    }\n\n    suspend fun updateShowEpisodeWatches(\n        showId: Long,\n        refreshType: RefreshType = RefreshType.QUICK,\n        forceRefresh: Boolean = false,\n        lastUpdated: OffsetDateTime? = null\n    ) {\n        if (refreshType == RefreshType.QUICK) {\n            // If we have a lastUpdated time and we've already fetched the watched episodes, we can try\n            // and do a delta fetch\n            if (lastUpdated != null && episodeWatchLastLastRequestStore.hasBeenRequested(showId)) {\n                if (forceRefresh || needShowEpisodeWatchesSync(showId, lastUpdated.toInstant())) {\n                    updateShowEpisodeWatches(showId, lastUpdated.plusSeconds(1))\n                }\n            } else {\n                // We don't have a trakt date/time to use as a delta, so we'll do a full refresh.\n                // If the user hasn't watched the show, this should be empty anyway\n                if (forceRefresh || needShowEpisodeWatchesSync(showId)) {\n                    updateShowEpisodeWatches(showId)\n                }\n            }\n        } else if (refreshType == RefreshType.FULL) {\n            // A full refresh is requested, so we pull down all history\n            if (forceRefresh || needShowEpisodeWatchesSync(showId)) {\n                updateShowEpisodeWatches(showId)\n            }\n        }\n    }\n\n    private suspend fun updateShowEpisodeWatches(showId: Long, since: OffsetDateTime? = null) {\n        if (traktAuthState.get() == TraktAuthState.LOGGED_IN) {\n            fetchShowWatchesFromRemote(showId, since)\n        }\n    }\n\n    suspend fun syncEpisodeWatchesForShow(showId: Long) = asyncOrAwait(\"sync_show_watches_$showId\") {\n        // Process any pending deletes\n        episodeWatchStore.getEntriesWithDeleteAction(showId).also {\n            it.isNotEmpty() && processPendingDeletes(it)\n        }\n\n        // Process any pending adds\n        episodeWatchStore.getEntriesWithAddAction(showId).also {\n            it.isNotEmpty() && processPendingAdditions(it)\n        }\n\n        if (traktAuthState.get() == TraktAuthState.LOGGED_IN) {\n            fetchShowWatchesFromRemote(showId)\n        }\n    }\n\n    suspend fun needShowEpisodeWatchesSync(\n        showId: Long,\n        expiry: Instant = instantInPast(hours = 1)\n    ): Boolean {\n        return episodeWatchLastLastRequestStore.isRequestBefore(showId, expiry)\n    }\n\n    suspend fun markSeasonWatched(seasonId: Long, onlyAired: Boolean, date: ActionDate) {\n        val watchesToSave = seasonsEpisodesStore.getEpisodesInSeason(seasonId).mapNotNull { episode ->\n            if (!onlyAired || episode.firstAired?.isBefore(OffsetDateTime.now()) == true) {\n                if (!episodeWatchStore.hasEpisodeBeenWatched(episode.id)) {\n                    val timestamp = when (date) {\n                        ActionDate.NOW -> OffsetDateTime.now()\n                        ActionDate.AIR_DATE -> episode.firstAired ?: OffsetDateTime.now()\n                    }\n                    return@mapNotNull EpisodeWatchEntry(\n                        episodeId = episode.id,\n                        watchedAt = timestamp,\n                        pendingAction = PendingAction.UPLOAD\n                    )\n                }\n            }\n            null\n        }\n\n        if (watchesToSave.isNotEmpty()) {\n            episodeWatchStore.save(watchesToSave)\n        }\n\n        // Should probably make this more granular\n        val season = seasonsEpisodesStore.getSeason(seasonId)!!\n        syncEpisodeWatchesForShow(season.showId)\n    }\n\n    suspend fun markSeasonUnwatched(seasonId: Long) {\n        val season = seasonsEpisodesStore.getSeason(seasonId)!!\n\n        val watches = ArrayList<EpisodeWatchEntry>()\n        seasonsEpisodesStore.getEpisodesInSeason(seasonId).forEach { episode ->\n            watches += episodeWatchStore.getWatchesForEpisode(episode.id)\n        }\n        if (watches.isNotEmpty()) {\n            episodeWatchStore.updateWatchEntriesWithAction(watches.map { it.id }, PendingAction.DELETE)\n        }\n\n        // Should probably make this more granular\n        syncEpisodeWatchesForShow(season.showId)\n    }\n\n    suspend fun markSeasonFollowed(seasonId: Long) {\n        seasonsEpisodesStore.updateSeasonFollowed(seasonId, true)\n    }\n\n    suspend fun markSeasonIgnored(seasonId: Long) {\n        seasonsEpisodesStore.updateSeasonFollowed(seasonId, false)\n    }\n\n    suspend fun markPreviousSeasonsIgnored(seasonId: Long) {\n        seasonsEpisodesStore.updatePreviousSeasonFollowed(seasonId, false)\n    }\n\n    suspend fun addEpisodeWatch(episodeId: Long, timestamp: OffsetDateTime) {\n        val entry = EpisodeWatchEntry(\n            episodeId = episodeId,\n            watchedAt = timestamp,\n            pendingAction = PendingAction.UPLOAD\n        )\n        episodeWatchStore.save(entry)\n\n        syncEpisodeWatches(episodeId)\n    }\n\n    suspend fun removeEpisodeWatch(episodeWatchId: Long) {\n        val episodeWatch = episodeWatchStore.getEpisodeWatch(episodeWatchId)\n        if (episodeWatch != null && episodeWatch.pendingAction != PendingAction.DELETE) {\n            episodeWatchStore.save(episodeWatch.copy(pendingAction = PendingAction.DELETE))\n            syncEpisodeWatches(episodeWatch.episodeId)\n        }\n    }\n\n    suspend fun removeAllEpisodeWatches(episodeId: Long) {\n        val watchesForEpisode = episodeWatchStore.getWatchesForEpisode(episodeId)\n        if (watchesForEpisode.isNotEmpty()) {\n            // First mark them as pending deletion\n            episodeWatchStore.updateWatchEntriesWithAction(\n                watchesForEpisode.map { it.id }, PendingAction.DELETE)\n            syncEpisodeWatches(episodeId)\n        }\n    }\n\n    private suspend fun syncEpisodeWatches(episodeId: Long) {\n        val watches = episodeWatchStore.getWatchesForEpisode(episodeId)\n        var needUpdate = false\n\n        // Process any deletes first\n        val toDelete = watches.filter { it.pendingAction == PendingAction.DELETE }\n        if (toDelete.isNotEmpty() && processPendingDeletes(toDelete)) {\n            needUpdate = true\n        }\n\n        // Process any uploads\n        val toAdd = watches.filter { it.pendingAction == PendingAction.UPLOAD }\n        if (toAdd.isNotEmpty() && processPendingAdditions(toAdd)) {\n            needUpdate = true\n        }\n\n        if (needUpdate && traktAuthState.get() == TraktAuthState.LOGGED_IN) {\n            fetchEpisodeWatchesFromRemote(episodeId)\n        }\n    }\n\n    private suspend fun fetchShowWatchesFromRemote(showId: Long, since: OffsetDateTime? = null) {\n        when (val response = traktSeasonsDataSource.getShowEpisodeWatches(showId, since)) {\n            is Success -> transactionRunner {\n                val watches = response.data.mapNotNull { (episode, watchEntry) ->\n                    val epId = seasonsEpisodesStore.getEpisodeIdForTraktId(episode.traktId!!)\n                        ?: return@mapNotNull null // We don't have the episode, skip\n                    watchEntry.copy(episodeId = epId)\n                }\n                if (since != null) {\n                    // We did a delta fetch, so just append/update the new watches\n                    if (watches.isNotEmpty()) {\n                        episodeWatchStore.addNewShowWatchEntries(showId, watches)\n                    }\n                } else {\n                    episodeWatchStore.syncShowWatchEntries(showId, watches)\n                }\n                episodeWatchLastLastRequestStore.updateLastRequest(showId)\n            }\n        }\n    }\n\n    private suspend fun fetchEpisodeWatchesFromRemote(episodeId: Long) {\n        when (val response = traktSeasonsDataSource.getEpisodeWatches(episodeId, null)) {\n            is Success -> {\n                val watches = response.data.map { it.copy(episodeId = episodeId) }\n                episodeWatchStore.syncEpisodeWatchEntries(episodeId, watches)\n            }\n        }\n    }\n\n    /**\n     * Process any pending episode watch deletes.\n     *\n     * @return true if a network service was updated\n     */\n    private suspend fun processPendingDeletes(entries: List<EpisodeWatchEntry>): Boolean {\n        if (traktAuthState.get() == TraktAuthState.LOGGED_IN) {\n            val response = traktSeasonsDataSource.removeEpisodeWatches(entries)\n            if (response is Success) {\n                // Now update the database\n                episodeWatchStore.deleteWatchEntriesWithIds(entries.map { it.id })\n                return true\n            }\n        } else {\n            // We're not logged in so just update the database\n            episodeWatchStore.deleteWatchEntriesWithIds(entries.map { it.id })\n        }\n        return false\n    }\n\n    /**\n     * Process any pending episode watch adds.\n     *\n     * @return true if a network service was updated\n     */\n    private suspend fun processPendingAdditions(entries: List<EpisodeWatchEntry>): Boolean {\n        if (traktAuthState.get() == TraktAuthState.LOGGED_IN) {\n            val response = traktSeasonsDataSource.addEpisodeWatches(entries)\n            if (response is Success) {\n                // Now update the database\n                episodeWatchStore.updateWatchEntriesWithAction(entries.map { it.id }, PendingAction.NOTHING)\n                return true\n            }\n        } else {\n            // We're not logged in so just update the database\n            episodeWatchStore.updateWatchEntriesWithAction(entries.map { it.id }, PendingAction.NOTHING)\n        }\n        return false\n    }\n\n    private fun mergeSeason(local: Season, trakt: Season, tmdb: Season) = local.copy(\n        title = trakt.title ?: local.title,\n        summary = trakt.summary ?: local.summary,\n        number = trakt.number ?: local.number,\n\n        network = trakt.network ?: tmdb.network ?: local.network,\n        episodeCount = trakt.episodeCount ?: tmdb.episodeCount ?: local.episodeCount,\n        episodesAired = trakt.episodesAired ?: tmdb.episodesAired ?: local.episodesAired,\n\n        // Trakt specific stuff\n        traktId = trakt.traktId ?: local.traktId,\n        traktRating = trakt.traktRating ?: local.traktRating,\n        traktRatingVotes = trakt.traktRatingVotes ?: local.traktRatingVotes,\n\n        // TMDb specific stuff\n        tmdbId = tmdb.tmdbId ?: trakt.tmdbId ?: local.tmdbId,\n        tmdbPosterPath = tmdb.tmdbPosterPath ?: local.tmdbPosterPath,\n        tmdbBackdropPath = tmdb.tmdbBackdropPath ?: local.tmdbBackdropPath\n    )\n\n    private fun mergeEpisode(local: Episode, trakt: Episode, tmdb: Episode) = local.copy(\n        title = trakt.title ?: tmdb.title ?: local.title,\n        summary = trakt.summary ?: tmdb.summary ?: local.summary,\n        number = trakt.number ?: tmdb.number ?: local.number,\n        firstAired = trakt.firstAired ?: tmdb.firstAired ?: local.firstAired,\n\n        // Trakt specific stuff\n        traktId = trakt.traktId ?: local.traktId,\n        traktRating = trakt.traktRating ?: local.traktRating,\n        traktRatingVotes = trakt.traktRatingVotes ?: local.traktRatingVotes,\n\n        // TMDb specific stuff\n        tmdbId = tmdb.tmdbId ?: trakt.tmdbId ?: local.tmdbId,\n        tmdbBackdropPath = tmdb.tmdbBackdropPath ?: local.tmdbBackdropPath\n    )\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Result\nimport app.tivi.data.mappers.ShowIdToTmdbIdMapper\nimport app.tivi.data.mappers.TmdbEpisodeToEpisode\nimport app.tivi.data.mappers.toLambda\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.tmdb2.Tmdb\nimport javax.inject.Inject\n\nclass TmdbEpisodeDataSource @Inject constructor(\n    private val tmdbIdMapper: ShowIdToTmdbIdMapper,\n    private val tmdb: Tmdb,\n    private val episodeMapper: TmdbEpisodeToEpisode\n) : EpisodeDataSource {\n    override suspend fun getEpisode(\n        showId: Long,\n        seasonNumber: Int,\n        episodeNumber: Int\n    ): Result<Episode> {\n        return tmdb.tvEpisodesService()\n            .episode(tmdbIdMapper.map(showId), seasonNumber, episodeNumber, null)\n            .executeWithRetry()\n            .toResult(episodeMapper.toLambda())\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.EntityLastRequestStore\nimport javax.inject.Inject\n\nclass EpisodeWatchLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : EntityLastRequestStore(Request.SHOW_EPISODE_WATCHES, dao)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.entities.ErrorResult\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.Season\nimport app.tivi.data.mappers.EpisodeIdToTraktIdMapper\nimport app.tivi.data.mappers.SeasonIdToTraktIdMapper\nimport app.tivi.data.mappers.ShowIdToTraktIdMapper\nimport app.tivi.data.mappers.TraktHistoryEntryToEpisode\nimport app.tivi.data.mappers.TraktHistoryItemToEpisodeWatchEntry\nimport app.tivi.data.mappers.TraktSeasonToSeasonWithEpisodes\nimport app.tivi.data.mappers.forLists\nimport app.tivi.data.mappers.pairMapperOf\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport app.tivi.extensions.toResultUnit\nimport com.uwetrottmann.trakt5.entities.EpisodeIds\nimport com.uwetrottmann.trakt5.entities.SyncEpisode\nimport com.uwetrottmann.trakt5.entities.SyncItems\nimport com.uwetrottmann.trakt5.entities.UserSlug\nimport com.uwetrottmann.trakt5.enums.Extended\nimport com.uwetrottmann.trakt5.enums.HistoryType\nimport com.uwetrottmann.trakt5.services.Seasons\nimport com.uwetrottmann.trakt5.services.Sync\nimport com.uwetrottmann.trakt5.services.Users\nimport java.lang.IllegalArgumentException\nimport javax.inject.Inject\nimport javax.inject.Provider\nimport org.threeten.bp.OffsetDateTime\nimport org.threeten.bp.ZoneOffset\n\nclass TraktSeasonsEpisodesDataSource @Inject constructor(\n    private val showIdToTraktIdMapper: ShowIdToTraktIdMapper,\n    private val seasonIdToTraktIdMapper: SeasonIdToTraktIdMapper,\n    private val episodeIdToTraktIdMapper: EpisodeIdToTraktIdMapper,\n    private val seasonsService: Provider<Seasons>,\n    private val usersService: Provider<Users>,\n    private val syncService: Provider<Sync>,\n    private val seasonMapper: TraktSeasonToSeasonWithEpisodes,\n    private val episodeMapper: TraktHistoryEntryToEpisode,\n    private val historyItemMapper: TraktHistoryItemToEpisodeWatchEntry\n) : SeasonsEpisodesDataSource {\n    override suspend fun getSeasonsEpisodes(showId: Long): Result<List<Pair<Season, List<Episode>>>> {\n        return seasonsService.get().summary(showIdToTraktIdMapper.map(showId).toString(), Extended.FULLEPISODES)\n            .executeWithRetry()\n            .toResult(seasonMapper.forLists())\n    }\n\n    override suspend fun getShowEpisodeWatches(\n        showId: Long,\n        since: OffsetDateTime?\n    ): Result<List<Pair<Episode, EpisodeWatchEntry>>> {\n        val showTraktId = showIdToTraktIdMapper.map(showId)\n            ?: return ErrorResult(IllegalArgumentException(\"No Trakt ID for show with ID: $showId\"))\n\n        return usersService.get().history(UserSlug.ME, HistoryType.SHOWS, showTraktId,\n            0, 10000, Extended.NOSEASONS, since, null)\n            .executeWithRetry()\n            .toResult(pairMapperOf(episodeMapper, historyItemMapper))\n    }\n\n    override suspend fun getSeasonWatches(\n        seasonId: Long,\n        since: OffsetDateTime?\n    ): Result<List<Pair<Episode, EpisodeWatchEntry>>> {\n        return usersService.get().history(UserSlug.ME, HistoryType.SEASONS, seasonIdToTraktIdMapper.map(seasonId),\n            0, 10000, Extended.NOSEASONS, since, null)\n            .executeWithRetry()\n            .toResult(pairMapperOf(episodeMapper, historyItemMapper))\n    }\n\n    override suspend fun getEpisodeWatches(\n        episodeId: Long,\n        since: OffsetDateTime?\n    ): Result<List<EpisodeWatchEntry>> {\n        return usersService.get().history(UserSlug.ME, HistoryType.EPISODES, episodeIdToTraktIdMapper.map(episodeId),\n            0, 10000, Extended.NOSEASONS, since, null)\n            .executeWithRetry()\n            .toResult(historyItemMapper.forLists())\n    }\n\n    override suspend fun addEpisodeWatches(watches: List<EpisodeWatchEntry>): Result<Unit> {\n        val items = SyncItems()\n        items.episodes = watches.map {\n            SyncEpisode()\n                .id(EpisodeIds.trakt(episodeIdToTraktIdMapper.map(it.episodeId)))!!\n                .watchedAt(it.watchedAt.withOffsetSameInstant(ZoneOffset.UTC))\n        }\n        return syncService.get().addItemsToWatchedHistory(items)\n            .executeWithRetry()\n            .toResultUnit()\n    }\n\n    override suspend fun removeEpisodeWatches(watches: List<EpisodeWatchEntry>): Result<Unit> {\n        val items = SyncItems()\n        items.ids = watches.mapNotNull { it.traktId }\n        return syncService.get().deleteItemsFromWatchedHistory(items).executeWithRetry()\n            .toResultUnit()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.data.DatabaseTransactionRunner\nimport app.tivi.data.daos.EpisodeWatchEntryDao\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.entities.PendingAction\nimport app.tivi.data.syncers.syncerForEntity\nimport app.tivi.util.Logger\nimport javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass EpisodeWatchStore @Inject constructor(\n    private val transactionRunner: DatabaseTransactionRunner,\n    private val episodeWatchEntryDao: EpisodeWatchEntryDao,\n    private val logger: Logger\n) {\n    private val episodeWatchSyncer = syncerForEntity(\n        episodeWatchEntryDao,\n        { it.traktId },\n        { entity, id -> entity.copy(id = id ?: 0) },\n        logger\n    )\n\n    fun observeEpisodeWatches(episodeId: Long): Flow<List<EpisodeWatchEntry>> {\n        return episodeWatchEntryDao.watchesForEpisodeObservable(episodeId)\n    }\n\n    suspend fun save(watch: EpisodeWatchEntry) = episodeWatchEntryDao.insertOrUpdate(watch)\n\n    suspend fun save(watches: List<EpisodeWatchEntry>) = episodeWatchEntryDao.insertOrUpdate(watches)\n\n    suspend fun getEpisodeWatchesForShow(showId: Long) = episodeWatchEntryDao.entriesForShowId(showId)\n\n    suspend fun getWatchesForEpisode(episodeId: Long) = episodeWatchEntryDao.watchesForEpisode(episodeId)\n\n    suspend fun getEpisodeWatch(watchId: Long) = episodeWatchEntryDao.entryWithId(watchId)\n\n    suspend fun hasEpisodeBeenWatched(episodeId: Long) = episodeWatchEntryDao.watchCountForEpisode(episodeId) > 0\n\n    suspend fun getEntriesWithAddAction(showId: Long) = episodeWatchEntryDao.entriesForShowIdWithSendPendingActions(showId)\n\n    suspend fun getEntriesWithDeleteAction(showId: Long) = episodeWatchEntryDao.entriesForShowIdWithDeletePendingActions(showId)\n\n    suspend fun deleteWatchEntriesWithIds(ids: List<Long>) = episodeWatchEntryDao.deleteWithIds(ids)\n\n    suspend fun updateWatchEntriesWithAction(ids: List<Long>, action: PendingAction): Int {\n        return episodeWatchEntryDao.updateEntriesToPendingAction(ids, action.value)\n    }\n\n    suspend fun addNewShowWatchEntries(\n        showId: Long,\n        watches: List<EpisodeWatchEntry>\n    ) = transactionRunner {\n        val currentWatches = episodeWatchEntryDao.entriesForShowIdWithNoPendingAction(showId)\n        episodeWatchSyncer.sync(currentWatches, watches, removeNotMatched = false)\n    }\n\n    suspend fun syncShowWatchEntries(\n        showId: Long,\n        watches: List<EpisodeWatchEntry>\n    ) = transactionRunner {\n        val currentWatches = episodeWatchEntryDao.entriesForShowIdWithNoPendingAction(showId)\n        episodeWatchSyncer.sync(currentWatches, watches)\n    }\n\n    suspend fun syncEpisodeWatchEntries(\n        episodeId: Long,\n        watches: List<EpisodeWatchEntry>\n    ) = transactionRunner {\n        val currentWatches = episodeWatchEntryDao.watchesForEpisode(episodeId)\n        episodeWatchSyncer.sync(currentWatches, watches)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.episodes\n\nimport app.tivi.data.DatabaseTransactionRunner\nimport app.tivi.data.daos.EpisodesDao\nimport app.tivi.data.daos.SeasonsDao\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport app.tivi.data.resultentities.EpisodeWithSeason\nimport app.tivi.data.resultentities.SeasonWithEpisodesAndWatches\nimport app.tivi.data.syncers.syncerForEntity\nimport app.tivi.util.Logger\nimport javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.flatMapLatest\n\nclass SeasonsEpisodesStore @Inject constructor(\n    private val transactionRunner: DatabaseTransactionRunner,\n    private val seasonsDao: SeasonsDao,\n    private val episodesDao: EpisodesDao,\n    private val logger: Logger\n) {\n    private val seasonSyncer = syncerForEntity(\n        seasonsDao,\n        { it.traktId },\n        { entity, id -> entity.copy(id = id ?: 0) },\n        logger\n    )\n\n    private val episodeSyncer = syncerForEntity(\n        episodesDao,\n        { it.traktId },\n        { entity, id -> entity.copy(id = id ?: 0) },\n        logger\n    )\n\n    fun observeEpisode(episodeId: Long): Flow<EpisodeWithSeason> {\n        return episodesDao.episodeWithIdObservable(episodeId)\n    }\n\n    fun observeShowSeasonsWithEpisodes(showId: Long): Flow<List<SeasonWithEpisodesAndWatches>> {\n        return seasonsDao.seasonsWithEpisodesForShowId(showId)\n    }\n\n    fun observeShowNextEpisodeToWatch(showId: Long): Flow<EpisodeWithSeason?> {\n        return episodesDao.observeLatestWatchedEpisodeForShowId(showId).flatMapLatest {\n            episodesDao.observeNextAiredEpisodeForShowAfter(\n                showId,\n                it?.season?.number ?: 0,\n                it?.episode?.number ?: 0\n            )\n        }\n    }\n\n    /**\n     * Gets the ID for the season with the given trakt Id. If the trakt Id does not exist in the\n     * database, it is inserted and the generated ID is returned.\n     */\n    suspend fun getEpisodeIdForTraktId(traktId: Int): Long? {\n        return episodesDao.episodeIdWithTraktId(traktId)\n    }\n\n    suspend fun getSeason(id: Long) = seasonsDao.seasonWithId(id)\n\n    suspend fun getSeasonWithTraktId(traktId: Int) = seasonsDao.seasonWithTraktId(traktId)\n\n    suspend fun getEpisodesInSeason(seasonId: Long) = episodesDao.episodesWithSeasonId(seasonId)\n\n    suspend fun getEpisode(id: Long) = episodesDao.episodeWithId(id)\n\n    suspend fun getEpisodeWithTraktId(traktId: Int) = episodesDao.episodeWithTraktId(traktId)\n\n    suspend fun updateSeasonFollowed(seasonId: Long, followed: Boolean) {\n        seasonsDao.updateSeasonIgnoreFlag(seasonId, !followed)\n    }\n\n    suspend fun updatePreviousSeasonFollowed(\n        seasonId: Long,\n        followed: Boolean\n    ) = transactionRunner {\n        for (id in seasonsDao.showPreviousSeasonIds(seasonId)) {\n            seasonsDao.updateSeasonIgnoreFlag(id, !followed)\n        }\n    }\n\n    suspend fun save(episode: Episode) = episodesDao.insertOrUpdate(episode)\n\n    suspend fun save(showId: Long, data: Map<Season, List<Episode>>) = transactionRunner {\n        seasonSyncer.sync(seasonsDao.seasonsForShowId(showId), data.keys)\n        data.forEach { (season, episodes) ->\n            val seasonId = seasonsDao.seasonWithTraktId(season.traktId!!)!!.id\n            val updatedEpisodes = episodes.map { if (it.seasonId != seasonId) it.copy(seasonId = seasonId) else it }\n            episodeSyncer.sync(episodesDao.episodesWithSeasonId(seasonId), updatedEpisodes)\n        }\n    }\n\n    suspend fun deleteShowSeasonData(showId: Long) {\n        // Due to foreign keys, this will also delete the episodes and watches\n        seasonsDao.deleteSeasonsForShowId(showId)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.search\n\nimport app.tivi.data.entities.ErrorResult\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.mappers.TmdbShowResultsPageToTiviShows\nimport app.tivi.data.mappers.toLambda\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.tmdb2.Tmdb\nimport javax.inject.Inject\n\nclass TmdbSearchDataSource @Inject constructor(\n    private val tmdb: Tmdb,\n    private val mapper: TmdbShowResultsPageToTiviShows\n) : SearchDataSource {\n    override suspend fun search(query: String): Result<List<Pair<TiviShow, List<ShowTmdbImage>>>> = try {\n        tmdb.searchService().tv(query, 1, null, null)\n            .executeWithRetry()\n            .toResult(mapper.toLambda())\n    } catch (t: Throwable) {\n        ErrorResult(t)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.search\n\nimport androidx.collection.LruCache\nimport javax.inject.Inject\n\nclass SearchStore @Inject constructor() {\n    private val cache = LruCache<String, LongArray>(32)\n\n    fun getResults(query: String) = cache[query]\n\n    fun setResults(query: String, results: LongArray) {\n        cache.put(query, results)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.search\n\nimport app.tivi.data.daos.ShowImagesDao\nimport app.tivi.data.daos.TiviShowDao\nimport app.tivi.data.entities.Success\nimport app.tivi.data.resultentities.ShowDetailed\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass SearchRepository @Inject constructor(\n    private val searchStore: SearchStore,\n    private val showImagesDao: ShowImagesDao,\n    private val showDao: TiviShowDao,\n    private val tmdbDataSource: TmdbSearchDataSource\n) {\n    suspend fun search(query: String): List<ShowDetailed> {\n        if (query.isBlank()) {\n            return emptyList()\n        }\n\n        val cacheValues = searchStore.getResults(query)\n        if (cacheValues != null) {\n            return cacheValues.map { showDao.getShowWithIdDetailed(it)!! }\n        }\n\n        // We need to hit TMDb instead\n        return when (val tmdbResult = tmdbDataSource.search(query)) {\n            is Success -> {\n                tmdbResult.data.map { (show, images) ->\n                    val showId = showDao.getIdOrSavePlaceholder(show)\n                    if (images.isNotEmpty()) {\n                        showImagesDao.saveImagesIfEmpty(showId, images.map { it.copy(showId = showId) })\n                    }\n                    showId\n                }.also { results ->\n                    // We need to save the search results\n                    searchStore.setResults(query, results.toLongArray())\n                }.mapNotNull {\n                    // Finally map back to a TiviShow instance\n                    showDao.getShowWithIdDetailed(it)\n                }\n            }\n            else -> emptyList()\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.search\n\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\n\ninterface SearchDataSource {\n    suspend fun search(query: String): Result<List<Pair<TiviShow, List<ShowTmdbImage>>>>\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.followedshows\n\nimport app.tivi.data.daos.TiviShowDao\nimport app.tivi.data.entities.FollowedShowEntry\nimport app.tivi.data.entities.PendingAction\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.entities.Success\nimport app.tivi.data.instantInPast\nimport app.tivi.data.syncers.ItemSyncerResult\nimport app.tivi.extensions.asyncOrAwait\nimport app.tivi.trakt.TraktAuthState\nimport app.tivi.util.Logger\nimport javax.inject.Inject\nimport javax.inject.Provider\nimport javax.inject.Singleton\nimport org.threeten.bp.Instant\nimport org.threeten.bp.OffsetDateTime\n\n@Singleton\nclass FollowedShowsRepository @Inject constructor(\n    private val followedShowsStore: FollowedShowsStore,\n    private val followedShowsLastRequestStore: FollowedShowsLastRequestStore,\n    private val dataSource: TraktFollowedShowsDataSource,\n    private val traktAuthState: Provider<TraktAuthState>,\n    private val logger: Logger,\n    private val showDao: TiviShowDao\n) {\n    fun observeFollowedShows(\n        sort: SortOption,\n        filter: String? = null\n    ) = followedShowsStore.observeForPaging(sort, filter)\n\n    fun observeShowViewStats(showId: Long) = followedShowsStore.observeShowViewStats(showId)\n\n    fun observeIsShowFollowed(showId: Long) = followedShowsStore.observeIsShowFollowed(showId)\n\n    fun observeNextShowToWatch() = followedShowsStore.observeNextShowToWatch()\n\n    suspend fun isShowFollowed(showId: Long) = followedShowsStore.isShowFollowed(showId)\n\n    suspend fun getFollowedShows(): List<FollowedShowEntry> {\n        return followedShowsStore.getEntries()\n    }\n\n    suspend fun needFollowedShowsSync(expiry: Instant = instantInPast(hours = 1)): Boolean {\n        return followedShowsLastRequestStore.isRequestBefore(expiry)\n    }\n\n    suspend fun addFollowedShow(showId: Long) {\n        val entry = followedShowsStore.getEntryForShowId(showId)\n\n        logger.d(\"addFollowedShow. Current entry: %s\", entry)\n\n        if (entry == null || entry.pendingAction == PendingAction.DELETE) {\n            // If we don't have an entry, or it is marked for deletion, lets update it to be uploaded\n            val newEntry = FollowedShowEntry(\n                id = entry?.id ?: 0,\n                showId = showId,\n                followedAt = entry?.followedAt ?: OffsetDateTime.now(),\n                pendingAction = PendingAction.UPLOAD\n            )\n            val newEntryId = followedShowsStore.save(newEntry)\n\n            logger.v(\"addFollowedShow. Entry saved with ID: %s - %s\", newEntryId, newEntry)\n        }\n    }\n\n    suspend fun removeFollowedShow(showId: Long) {\n        // Update the followed show to be deleted\n        val entry = followedShowsStore.getEntryForShowId(showId)\n        if (entry != null) {\n            // Mark the show as pending deletion\n            followedShowsStore.save(entry.copy(pendingAction = PendingAction.DELETE))\n        }\n    }\n\n    suspend fun syncFollowedShows(): ItemSyncerResult<FollowedShowEntry> {\n        return asyncOrAwait(\"sync_followed_shows\") {\n            val listId = when (TraktAuthState.LOGGED_IN) {\n                traktAuthState.get() -> getFollowedTraktListId()\n                else -> null\n            }\n\n            processPendingAdditions(listId)\n            processPendingDelete(listId)\n\n            when {\n                listId != null -> pullDownTraktFollowedList(listId)\n                else -> ItemSyncerResult()\n            }.also {\n                followedShowsLastRequestStore.updateLastRequest()\n            }\n        }\n    }\n\n    private suspend fun pullDownTraktFollowedList(\n        listId: Int\n    ): ItemSyncerResult<FollowedShowEntry> {\n        val response = dataSource.getListShows(listId)\n        logger.d(\"pullDownTraktFollowedList. Response: %s\", response)\n        return response.getOrThrow().map { (entry, show) ->\n            // Grab the show id if it exists, or save the show and use it's generated ID\n            val showId = showDao.getIdOrSavePlaceholder(show)\n            // Create a followed show entry with the show id\n            entry.copy(showId = showId)\n        }.let { entries ->\n            // Save the show entries\n            followedShowsStore.sync(entries)\n        }\n    }\n\n    private suspend fun processPendingAdditions(listId: Int?) {\n        val pending = followedShowsStore.getEntriesWithAddAction()\n        logger.d(\"processPendingAdditions. listId: %s, Entries: %s\", listId, pending)\n\n        if (pending.isEmpty()) {\n            return\n        }\n\n        if (listId != null && traktAuthState.get() == TraktAuthState.LOGGED_IN) {\n            val shows = pending.mapNotNull { showDao.getShowWithId(it.showId) }\n            logger.v(\"processPendingAdditions. Entries mapped: %s\", shows)\n\n            val response = dataSource.addShowIdsToList(listId, shows)\n            logger.v(\"processPendingAdditions. Trakt response: %s\", response)\n\n            if (response is Success) {\n                // Now update the database\n                followedShowsStore.updateEntriesWithAction(pending.map { it.id }, PendingAction.NOTHING)\n            }\n        } else {\n            // We're not logged in, so just update the database\n            followedShowsStore.updateEntriesWithAction(pending.map { it.id }, PendingAction.NOTHING)\n        }\n    }\n\n    private suspend fun processPendingDelete(listId: Int?) {\n        val pending = followedShowsStore.getEntriesWithDeleteAction()\n        logger.d(\"processPendingDelete. listId: %s, Entries: %s\", listId, pending)\n\n        if (pending.isEmpty()) {\n            return\n        }\n\n        if (listId != null && traktAuthState.get() == TraktAuthState.LOGGED_IN) {\n            val shows = pending.mapNotNull { showDao.getShowWithId(it.showId) }\n            logger.v(\"processPendingDelete. Entries mapped: %s\", shows)\n\n            val response = dataSource.removeShowIdsFromList(listId, shows)\n            logger.v(\"processPendingDelete. Trakt response: %s\", response)\n\n            if (response is Success) {\n                // Now update the database\n                followedShowsStore.deleteEntriesInIds(pending.map { it.id })\n            }\n        } else {\n            // We're not logged in, so just update the database\n            followedShowsStore.deleteEntriesInIds(pending.map { it.id })\n        }\n    }\n\n    private suspend fun getFollowedTraktListId(): Int? {\n        if (followedShowsStore.traktListId == null) {\n            val result = dataSource.getFollowedListId()\n            if (result is Success) {\n                followedShowsStore.traktListId = result.get()\n            }\n        }\n        return followedShowsStore.traktListId\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.followedshows\n\nimport app.tivi.data.entities.ErrorResult\nimport app.tivi.data.entities.FollowedShowEntry\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.Success\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.mappers.TraktListEntryToFollowedShowEntry\nimport app.tivi.data.mappers.TraktListEntryToTiviShow\nimport app.tivi.data.mappers.pairMapperOf\nimport app.tivi.extensions.bodyOrThrow\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport app.tivi.extensions.toResultUnit\nimport com.uwetrottmann.trakt5.entities.ShowIds\nimport com.uwetrottmann.trakt5.entities.SyncItems\nimport com.uwetrottmann.trakt5.entities.SyncShow\nimport com.uwetrottmann.trakt5.entities.TraktList\nimport com.uwetrottmann.trakt5.entities.UserSlug\nimport com.uwetrottmann.trakt5.enums.Extended\nimport com.uwetrottmann.trakt5.enums.ListPrivacy\nimport com.uwetrottmann.trakt5.services.Users\nimport javax.inject.Inject\nimport javax.inject.Provider\n\nclass TraktFollowedShowsDataSource @Inject constructor(\n    private val usersService: Provider<Users>,\n    listEntryToShowMapper: TraktListEntryToTiviShow,\n    listEntryToFollowedEntry: TraktListEntryToFollowedShowEntry\n) : FollowedShowsDataSource {\n    companion object {\n        private val LIST_NAME = \"Following\"\n    }\n\n    private val listShowsMapper = pairMapperOf(listEntryToFollowedEntry, listEntryToShowMapper)\n\n    override suspend fun addShowIdsToList(listId: Int, shows: List<TiviShow>): Result<Unit> {\n        val syncItems = SyncItems()\n        syncItems.shows = shows.map { show ->\n            SyncShow().apply {\n                ids = ShowIds().apply {\n                    trakt = show.traktId\n                    imdb = show.imdbId\n                    tmdb = show.tmdbId\n                }\n            }\n        }\n        return usersService.get().addListItems(UserSlug.ME, listId.toString(), syncItems)\n            .executeWithRetry()\n            .toResultUnit()\n    }\n\n    override suspend fun removeShowIdsFromList(listId: Int, shows: List<TiviShow>): Result<Unit> {\n        val syncItems = SyncItems()\n        syncItems.shows = shows.map { show ->\n            SyncShow().apply {\n                ids = ShowIds().apply {\n                    trakt = show.traktId\n                    imdb = show.imdbId\n                    tmdb = show.tmdbId\n                }\n            }\n        }\n        return usersService.get().deleteListItems(UserSlug.ME, listId.toString(), syncItems)\n            .executeWithRetry()\n            .toResultUnit()\n    }\n\n    override suspend fun getListShows(listId: Int): Result<List<Pair<FollowedShowEntry, TiviShow>>> {\n        return usersService.get().listItems(UserSlug.ME, listId.toString(), Extended.NOSEASONS)\n            .executeWithRetry()\n            .toResult(listShowsMapper)\n    }\n\n    override suspend fun getFollowedListId(): Result<Int> {\n        val fetchResult: Result<Int>? = try {\n            usersService.get().lists(UserSlug.ME)\n                .executeWithRetry()\n                .bodyOrThrow()\n                .firstOrNull { it.name == LIST_NAME }\n                ?.let { Success(it.ids.trakt) }\n        } catch (t: Throwable) {\n            ErrorResult(t)\n        }\n\n        if (fetchResult is Success) {\n            return fetchResult\n        }\n\n        return try {\n            usersService.get().createList(UserSlug.ME,\n                TraktList().name(LIST_NAME).privacy(ListPrivacy.PRIVATE))\n                .executeWithRetry()\n                .bodyOrThrow()\n                .let { Success(it.ids.trakt) }\n        } catch (t: Throwable) {\n            ErrorResult(t)\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.followedshows\n\nimport app.tivi.inject.Trakt\nimport dagger.Binds\nimport dagger.Module\n\n@Module\nabstract class FollowedShowsModule {\n    @Binds\n    @Trakt\n    abstract fun bind(source: TraktFollowedShowsDataSource): FollowedShowsDataSource\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.followedshows\n\nimport app.tivi.data.entities.FollowedShowEntry\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.TiviShow\n\ninterface FollowedShowsDataSource {\n    suspend fun getListShows(listId: Int): Result<List<Pair<FollowedShowEntry, TiviShow>>>\n    suspend fun addShowIdsToList(listId: Int, shows: List<TiviShow>): Result<Unit>\n    suspend fun removeShowIdsFromList(listId: Int, shows: List<TiviShow>): Result<Unit>\n    suspend fun getFollowedListId(): Result<Int>\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.followedshows\n\nimport androidx.paging.DataSource\nimport app.tivi.data.DatabaseTransactionRunner\nimport app.tivi.data.daos.FollowedShowsDao\nimport app.tivi.data.entities.FollowedShowEntry\nimport app.tivi.data.entities.PendingAction\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.resultentities.FollowedShowEntryWithShow\nimport app.tivi.data.syncers.syncerForEntity\nimport app.tivi.data.views.FollowedShowsWatchStats\nimport app.tivi.util.Logger\nimport javax.inject.Inject\nimport javax.inject.Singleton\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map\n\n@Singleton\nclass FollowedShowsStore @Inject constructor(\n    private val transactionRunner: DatabaseTransactionRunner,\n    private val followedShowsDao: FollowedShowsDao,\n    logger: Logger\n) {\n    var traktListId: Int? = null\n\n    private val syncer = syncerForEntity(\n        followedShowsDao,\n        { it.traktId },\n        { entity, id -> entity.copy(id = id ?: 0) },\n        logger\n    )\n\n    suspend fun getEntryForShowId(showId: Long): FollowedShowEntry? = followedShowsDao.entryWithShowId(showId)\n\n    suspend fun getEntries(): List<FollowedShowEntry> = followedShowsDao.entries()\n\n    suspend fun getEntriesWithAddAction() = followedShowsDao.entriesWithSendPendingActions()\n\n    suspend fun getEntriesWithDeleteAction() = followedShowsDao.entriesWithDeletePendingActions()\n\n    suspend fun updateEntriesWithAction(ids: List<Long>, action: PendingAction): Int {\n        return followedShowsDao.updateEntriesToPendingAction(ids, action.value)\n    }\n\n    suspend fun deleteEntriesInIds(ids: List<Long>) = followedShowsDao.deleteWithIds(ids)\n\n    fun observeForPaging(\n        sort: SortOption,\n        filter: String?\n    ): DataSource.Factory<Int, FollowedShowEntryWithShow> {\n        val filtered = filter != null && filter.isNotEmpty()\n        return when (sort) {\n            SortOption.SUPER_SORT -> {\n                if (filtered) {\n                    followedShowsDao.pagedListSuperSortFilter(\"*$filter*\")\n                } else {\n                    followedShowsDao.pagedListSuperSort()\n                }\n            }\n            SortOption.LAST_WATCHED -> {\n                if (filtered) {\n                    followedShowsDao.pagedListLastWatchedFilter(\"*$filter*\")\n                } else {\n                    followedShowsDao.pagedListLastWatched()\n                }\n            }\n            SortOption.ALPHABETICAL -> {\n                if (filtered) {\n                    followedShowsDao.pagedListAlphaFilter(\"*$filter*\")\n                } else {\n                    followedShowsDao.pagedListAlpha()\n                }\n            }\n            SortOption.DATE_ADDED -> {\n                if (filtered) {\n                    followedShowsDao.pagedListAddedFilter(\"*$filter*\")\n                } else {\n                    followedShowsDao.pagedListAdded()\n                }\n            }\n        }\n    }\n\n    fun observeIsShowFollowed(showId: Long): Flow<Boolean> {\n        return followedShowsDao.entryCountWithShowIdNotPendingDeleteObservable(showId)\n            .map { it > 0 }\n    }\n\n    fun observeNextShowToWatch(): Flow<FollowedShowEntryWithShow?> {\n        return followedShowsDao.observeNextShowToWatch()\n    }\n\n    fun observeShowViewStats(showId: Long): Flow<FollowedShowsWatchStats> {\n        return followedShowsDao.entryShowViewStats(showId)\n    }\n\n    suspend fun isShowFollowed(showId: Long) = followedShowsDao.entryCountWithShowId(showId) > 0\n\n    suspend fun sync(entities: List<FollowedShowEntry>) = transactionRunner {\n        syncer.sync(followedShowsDao.entries(), entities)\n    }\n\n    suspend fun save(entry: FollowedShowEntry) = followedShowsDao.insertOrUpdate(entry)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.followedshows\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.GroupLastRequestStore\nimport javax.inject.Inject\n\nclass FollowedShowsLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : GroupLastRequestStore(Request.FOLLOWED_SHOWS, dao)",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.watchedshows\n\nimport app.tivi.data.daos.TiviShowDao\nimport app.tivi.data.daos.WatchedShowDao\nimport app.tivi.data.entities.Success\nimport app.tivi.data.entities.WatchedShowEntry\nimport app.tivi.inject.ForStore\nimport com.dropbox.android.external.store4.Store\nimport com.dropbox.android.external.store4.StoreBuilder\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\n\ntypealias WatchedShowsStore = Store<Unit, List<WatchedShowEntry>>\n\n@Module\ninternal class WatchedShowsModule {\n    @Provides\n    @Singleton\n    fun provideWatchedShowsStore(\n        traktWatchedShows: TraktWatchedShowsDataSource,\n        watchedShowsDao: WatchedShowDao,\n        showDao: TiviShowDao,\n        lastRequestStore: WatchedShowsLastRequestStore,\n        @ForStore scope: CoroutineScope\n    ): WatchedShowsStore {\n        return StoreBuilder.fromNonFlow { _: Unit ->\n            traktWatchedShows().also {\n                if (it is Success) {\n                    lastRequestStore.updateLastRequest()\n                }\n            }.getOrThrow()\n        }.persister(\n            reader = { watchedShowsDao.entriesObservable() },\n            writer = { _, response ->\n                watchedShowsDao.withTransaction {\n                    val entries = response.map { (show, entry) ->\n                        entry.copy(showId = showDao.getIdOrSavePlaceholder(show))\n                    }\n                    watchedShowsDao.deleteAll()\n                    watchedShowsDao.insertAll(entries)\n                }\n            },\n            delete = {\n                // Delete of an entity here means the entire list\n                watchedShowsDao.deleteAll()\n            },\n            deleteAll = watchedShowsDao::deleteAll\n        ).scope(scope).build()\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.watchedshows\n\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.entities.WatchedShowEntry\nimport app.tivi.data.mappers.Mapper\nimport app.tivi.data.mappers.TraktBaseShowToTiviShow\nimport app.tivi.data.mappers.pairMapperOf\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.trakt5.entities.BaseShow\nimport com.uwetrottmann.trakt5.enums.Extended\nimport com.uwetrottmann.trakt5.services.Sync\nimport javax.inject.Inject\nimport javax.inject.Provider\n\ninternal class TraktWatchedShowsDataSource @Inject constructor(\n    private val syncService: Provider<Sync>,\n    showMapper: TraktBaseShowToTiviShow\n) {\n    private val entryMapper = object : Mapper<BaseShow, WatchedShowEntry> {\n        override suspend fun map(from: BaseShow): WatchedShowEntry {\n            return WatchedShowEntry(showId = 0, lastWatched = from.last_watched_at!!)\n        }\n    }\n    private val responseMapper = pairMapperOf(showMapper, entryMapper)\n\n    suspend operator fun invoke(): Result<List<Pair<TiviShow, WatchedShowEntry>>> {\n        return syncService.get().watchedShows(Extended.NOSEASONS)\n            .executeWithRetry()\n            .toResult(responseMapper)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.watchedshows\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.GroupLastRequestStore\nimport javax.inject.Inject\n\nclass WatchedShowsLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : GroupLastRequestStore(Request.WATCHED_SHOWS, dao)",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.showimages\n\nimport app.tivi.data.entities.ErrorResult\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.mappers.TmdbImagesToShowImages\nimport app.tivi.data.mappers.toLambda\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.tmdb2.Tmdb\nimport com.uwetrottmann.tmdb2.entities.AppendToResponse\nimport com.uwetrottmann.tmdb2.enumerations.AppendToResponseItem\nimport javax.inject.Inject\n\ninternal class TmdbShowImagesDataSource @Inject constructor(\n    private val tmdb: Tmdb,\n    private val mapper: TmdbImagesToShowImages\n) : ShowImagesDataSource {\n    override suspend fun getShowImages(show: TiviShow): Result<List<ShowTmdbImage>> {\n        val tmdbId = show.tmdbId\n        return if (tmdbId != null) {\n            tmdb.tvService().tv(tmdbId, null, AppendToResponse(AppendToResponseItem.IMAGES))\n                .executeWithRetry()\n                .toResult(mapper.toLambda())\n        } else {\n            ErrorResult(IllegalArgumentException(\"TmdbId for show does not exist [$show]\"))\n        }\n    }\n}",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.showimages\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.EntityLastRequestStore\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass ShowImagesLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : EntityLastRequestStore(Request.SHOW_IMAGES, dao)",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.showimages\n\nimport androidx.annotation.VisibleForTesting\nimport app.tivi.data.daos.ShowImagesDao\nimport app.tivi.data.daos.TiviShowDao\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.Success\nimport app.tivi.inject.ForStore\nimport app.tivi.inject.Tmdb\nimport com.dropbox.android.external.store4.Store\nimport com.dropbox.android.external.store4.StoreBuilder\nimport dagger.Binds\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\n\n@Module(includes = [ShowImagesModuleBinds::class, ShowImagesStoreModule::class])\nclass ShowsImagesModule\n\ntypealias ShowImagesStore = Store<Long, List<ShowTmdbImage>>\n\n@Module\ninternal abstract class ShowImagesModuleBinds {\n    @Binds\n    @Tmdb\n    abstract fun bindTmdbShowImagesDataSource(source: TmdbShowImagesDataSource): ShowImagesDataSource\n}\n\n@Module\n@VisibleForTesting\nclass ShowImagesStoreModule {\n    @Provides\n    @Singleton\n    fun provideTmdbShowImagesStore(\n        showImagesDao: ShowImagesDao,\n        showDao: TiviShowDao,\n        lastRequestStore: ShowImagesLastRequestStore,\n        @Tmdb tmdbShowImagesDataSource: ShowImagesDataSource,\n        @ForStore scope: CoroutineScope\n    ): ShowImagesStore {\n        return StoreBuilder.fromNonFlow { showId: Long ->\n            val show = showDao.getShowWithId(showId)\n                ?: throw IllegalArgumentException(\"Show with ID $showId does not exist\")\n            val result = tmdbShowImagesDataSource.getShowImages(show)\n\n            if (result is Success) {\n                lastRequestStore.updateLastRequest(showId)\n            }\n\n            result.getOrThrow().map {\n                it.copy(showId = showId)\n            }\n        }.persister(\n            reader = showImagesDao::getImagesForShowId,\n            writer = showImagesDao::saveImages,\n            delete = showImagesDao::deleteForShowId,\n            deleteAll = showImagesDao::deleteAll\n        ).scope(scope).build()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.showimages\n\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\n\ninterface ShowImagesDataSource {\n    suspend fun getShowImages(show: TiviShow): Result<List<ShowTmdbImage>>\n}",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.trendingshows\n\nimport app.tivi.data.daos.TiviShowDao\nimport app.tivi.data.daos.TrendingDao\nimport app.tivi.data.entities.Success\nimport app.tivi.data.entities.TrendingShowEntry\nimport app.tivi.inject.ForStore\nimport com.dropbox.android.external.store4.Store\nimport com.dropbox.android.external.store4.StoreBuilder\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\n\ntypealias TrendingShowsStore = Store<Int, List<TrendingShowEntry>>\n\n@Module\nclass TrendingShowsModule {\n    @Provides\n    @Singleton\n    fun provideTrendingShowsStore(\n        traktTrendingShows: TraktTrendingShowsDataSource,\n        trendingShowsDao: TrendingDao,\n        showDao: TiviShowDao,\n        lastRequestStore: TrendingShowsLastRequestStore,\n        @ForStore scope: CoroutineScope\n    ): TrendingShowsStore {\n        return StoreBuilder.fromNonFlow { page: Int ->\n            val response = traktTrendingShows(page, 20)\n            if (page == 0 && response is Success) {\n                lastRequestStore.updateLastRequest()\n            }\n            response.getOrThrow()\n        }.persister(\n            reader = trendingShowsDao::entriesObservable,\n            writer = { page, response ->\n                trendingShowsDao.withTransaction {\n                    val entries = response.map { (show, entry) ->\n                        entry.copy(showId = showDao.getIdOrSavePlaceholder(show), page = page)\n                    }\n                    if (page == 0) {\n                        // If we've requested page 0, remove any existing entries first\n                        trendingShowsDao.deleteAll()\n                        trendingShowsDao.insertAll(entries)\n                    } else {\n                        trendingShowsDao.updatePage(page, entries)\n                    }\n                }\n            },\n            delete = trendingShowsDao::deletePage,\n            deleteAll = trendingShowsDao::deleteAll\n        ).scope(scope).build()\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.trendingshows\n\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.entities.TrendingShowEntry\nimport app.tivi.data.mappers.TraktTrendingShowToTiviShow\nimport app.tivi.data.mappers.TraktTrendingShowToTrendingShowEntry\nimport app.tivi.data.mappers.pairMapperOf\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.trakt5.enums.Extended\nimport com.uwetrottmann.trakt5.services.Shows\nimport javax.inject.Inject\nimport javax.inject.Provider\n\nclass TraktTrendingShowsDataSource @Inject constructor(\n    private val showService: Provider<Shows>,\n    showMapper: TraktTrendingShowToTiviShow,\n    entryMapper: TraktTrendingShowToTrendingShowEntry\n) {\n    private val responseMapper = pairMapperOf(showMapper, entryMapper)\n\n    suspend operator fun invoke(\n        page: Int,\n        pageSize: Int\n    ): Result<List<Pair<TiviShow, TrendingShowEntry>>> {\n        // We add 1 because Trakt uses a 1-based index whereas we use a 0-based index\n        return showService.get().trending(page + 1, pageSize, Extended.NOSEASONS)\n            .executeWithRetry()\n            .toResult(responseMapper)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.trendingshows\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.GroupLastRequestStore\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TrendingShowsLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : GroupLastRequestStore(Request.TRENDING_SHOWS, dao)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.shows\n\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.TiviShow\n\ninterface ShowDataSource {\n    suspend fun getShow(show: TiviShow): Result<TiviShow>\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.shows\n\nimport androidx.annotation.VisibleForTesting\nimport app.tivi.data.daos.TiviShowDao\nimport app.tivi.data.entities.Success\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.inject.ForStore\nimport app.tivi.inject.Tmdb\nimport app.tivi.inject.Trakt\nimport com.dropbox.android.external.store4.Store\nimport com.dropbox.android.external.store4.StoreBuilder\nimport dagger.Binds\nimport dagger.Module\nimport dagger.Provides\nimport javax.inject.Singleton\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.async\nimport kotlinx.coroutines.coroutineScope\n\n@Module(includes = [ShowsModuleBinds::class, ShowStoreModule::class])\nclass ShowsModule\n\n@Module\ninternal abstract class ShowsModuleBinds {\n    @Binds\n    @Trakt\n    abstract fun bindTraktShowDataSource(source: TraktShowDataSource): ShowDataSource\n\n    @Binds\n    @Tmdb\n    abstract fun bindTmdbShowDataSource(source: TmdbShowDataSource): ShowDataSource\n}\n\ntypealias ShowStore = Store<Long, TiviShow>\n\n@Module\n@VisibleForTesting\nclass ShowStoreModule {\n    private inner class ShowStoreFetcherResponse(val trakt: TiviShow, val tmdb: TiviShow)\n\n    @Provides\n    @Singleton\n    fun provideShowStore(\n        showDao: TiviShowDao,\n        lastRequestStore: ShowLastRequestStore,\n        @Trakt traktShowDataSource: ShowDataSource,\n        @Tmdb tmdbShowDataSource: ShowDataSource,\n        @ForStore scope: CoroutineScope\n    ): ShowStore {\n        return StoreBuilder.fromNonFlow { showId: Long ->\n            val localShow = showDao.getShowWithId(showId)\n                ?: throw IllegalArgumentException(\"No show with id $showId in database\")\n\n            coroutineScope {\n                val traktResult = async {\n                    traktShowDataSource.getShow(localShow)\n                }\n                val tmdbResult = async {\n                    tmdbShowDataSource.getShow(localShow)\n                }\n\n                // Update our last request timestamp\n                if (traktResult is Success<*> && tmdbResult is Success<*>) {\n                    lastRequestStore.updateLastRequest(showId)\n                }\n\n                ShowStoreFetcherResponse(\n                    trakt = traktResult.await().get() ?: TiviShow.EMPTY_SHOW,\n                    tmdb = tmdbResult.await().get() ?: TiviShow.EMPTY_SHOW\n                )\n            }\n        }.persister(\n            reader = showDao::getShowWithIdFlow,\n            writer = { id, response ->\n                showDao.withTransaction {\n                    val local = showDao.getShowWithId(id) ?: TiviShow.EMPTY_SHOW\n                    showDao.insertOrUpdate(mergeShows(local, response.trakt, response.tmdb))\n                }\n            },\n            delete = showDao::delete,\n            deleteAll = showDao::deleteAll\n        ).scope(scope).build()\n    }\n}",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.shows\n\nimport app.tivi.data.entities.TiviShow\n\ninternal fun mergeShows(\n    local: TiviShow = TiviShow.EMPTY_SHOW,\n    trakt: TiviShow = TiviShow.EMPTY_SHOW,\n    tmdb: TiviShow = TiviShow.EMPTY_SHOW\n) = local.copy(\n    title = trakt.title ?: local.title,\n    summary = trakt.summary ?: local.summary,\n    homepage = trakt.homepage ?: local.homepage,\n    certification = trakt.certification ?: local.certification,\n    runtime = trakt.runtime ?: local.runtime,\n    country = trakt.country ?: local.country,\n    firstAired = trakt.firstAired ?: local.firstAired,\n    _genres = trakt._genres ?: local._genres,\n    status = trakt.status ?: local.status,\n    airsDay = trakt.airsDay ?: local.airsDay,\n    airsTimeZone = trakt.airsTimeZone ?: local.airsTimeZone,\n    airsTime = trakt.airsTime ?: local.airsTime,\n\n    // Trakt specific stuff\n    traktId = trakt.traktId ?: local.traktId,\n    traktRating = trakt.traktRating ?: local.traktRating,\n    traktVotes = trakt.traktVotes ?: local.traktVotes,\n    traktDataUpdate = trakt.traktDataUpdate ?: local.traktDataUpdate,\n\n    // TMDb specific stuff\n    tmdbId = tmdb.tmdbId ?: trakt.tmdbId ?: local.tmdbId,\n    network = tmdb.network ?: trakt.network ?: local.network,\n    networkLogoPath = tmdb.networkLogoPath ?: local.networkLogoPath\n)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.shows\n\nimport app.tivi.data.entities.ErrorResult\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.Success\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.mappers.TraktShowToTiviShow\nimport app.tivi.data.mappers.toLambda\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.trakt5.enums.Extended\nimport com.uwetrottmann.trakt5.enums.IdType\nimport com.uwetrottmann.trakt5.enums.Type\nimport com.uwetrottmann.trakt5.services.Search\nimport com.uwetrottmann.trakt5.services.Shows\nimport javax.inject.Inject\nimport javax.inject.Provider\n\ninternal class TraktShowDataSource @Inject constructor(\n    private val showService: Provider<Shows>,\n    private val searchService: Provider<Search>,\n    private val mapper: TraktShowToTiviShow\n) : ShowDataSource {\n    override suspend fun getShow(show: TiviShow): Result<TiviShow> {\n        var traktId = show.traktId\n\n        if (traktId == null && show.tmdbId != null) {\n            // We need to fetch the search for the trakt id\n            val response = searchService.get().idLookup(IdType.TMDB, show.tmdbId.toString(),\n                Type.SHOW, Extended.NOSEASONS, 1, 1)\n                .execute()\n                .toResult { it[0].show?.ids?.trakt }\n            if (response is Success) {\n                traktId = response.get()\n            } else if (response is ErrorResult) {\n                return ErrorResult(response.throwable)\n            }\n        }\n\n        if (traktId == null) {\n            val response = searchService.get().textQueryShow(show.title, null /* years */, null /* genres */,\n                null /* lang */, show.country /* countries */, null /* runtime */, null /* ratings */,\n                null /* certs */, show.network /* networks */, null /* status */,\n                Extended.NOSEASONS, 1, 1)\n                .execute()\n                .toResult { it[0].show?.ids?.trakt }\n            if (response is Success) {\n                traktId = response.get()\n            } else if (response is ErrorResult) {\n                return ErrorResult(response.throwable)\n            }\n        }\n\n        return if (traktId != null) {\n            showService.get().summary(traktId.toString(), Extended.FULL)\n                .execute()\n                .toResult(mapper.toLambda())\n        } else {\n            ErrorResult(IllegalArgumentException(\"Trakt ID for show does not exist: [$show]\"))\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.shows\n\nimport app.tivi.data.entities.ErrorResult\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.mappers.TmdbShowToTiviShow\nimport app.tivi.data.mappers.toLambda\nimport app.tivi.extensions.executeWithRetry\nimport app.tivi.extensions.toResult\nimport com.uwetrottmann.tmdb2.Tmdb\nimport javax.inject.Inject\n\ninternal class TmdbShowDataSource @Inject constructor(\n    private val tmdb: Tmdb,\n    private val mapper: TmdbShowToTiviShow\n) : ShowDataSource {\n    override suspend fun getShow(show: TiviShow): Result<TiviShow> {\n        val tmdbId = show.tmdbId\n        return if (tmdbId != null) {\n            tmdb.tvService().tv(tmdbId, null)\n                .executeWithRetry()\n                .toResult(mapper.toLambda())\n        } else {\n            ErrorResult(IllegalArgumentException(\"TmdbId for show does not exist [$show]\"))\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.repositories.shows\n\nimport app.tivi.data.daos.LastRequestDao\nimport app.tivi.data.entities.Request\nimport app.tivi.data.repositories.lastrequests.EntityLastRequestStore\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass ShowLastRequestStore @Inject constructor(\n    dao: LastRequestDao\n) : EntityLastRequestStore(Request.SHOW_DETAILS, dao)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\ninterface DatabaseTransactionRunner {\n    suspend operator fun <T> invoke(block: suspend () -> T): T\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport org.threeten.bp.Instant\nimport org.threeten.bp.OffsetDateTime\nimport org.threeten.bp.Period\nimport org.threeten.bp.temporal.ChronoUnit\nimport org.threeten.bp.temporal.TemporalAmount\n\nfun TemporalAmount.inPast(): Instant = Instant.now().minus(this)\n\nfun periodOf(years: Int = 0, months: Int = 0, days: Int = 0) = Period.of(years, months, days)\n\nfun instantInPast(days: Int = 0, hours: Int = 0, minutes: Int = 0): Instant {\n    var instant = Instant.now()\n    if (days != 0) {\n        instant = instant.minus(days.toLong(), ChronoUnit.DAYS)\n    }\n    if (hours != 0) {\n        instant = instant.minus(hours.toLong(), ChronoUnit.HOURS)\n    }\n    if (minutes != 0) {\n        instant = instant.minus(minutes.toLong(), ChronoUnit.HOURS)\n    }\n    return instant\n}\n\nfun OffsetDateTime.isBefore(instant: Instant): Boolean = toInstant().isBefore(instant)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.TiviShow\nimport com.uwetrottmann.tmdb2.entities.TvShow\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TmdbShowToTiviShow @Inject constructor() : Mapper<TvShow, TiviShow> {\n    override suspend fun map(from: TvShow) = TiviShow(\n        tmdbId = from.id,\n        imdbId = from.external_ids?.imdb_id,\n        title = from.name,\n        summary = from.overview,\n        homepage = from.homepage,\n        network = from.networks?.firstOrNull()?.name,\n        networkLogoPath = from.networks?.firstOrNull()?.logo_path\n    )\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport com.uwetrottmann.trakt5.entities.HistoryEntry\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktHistoryItemToEpisodeWatchEntry @Inject constructor() : Mapper<HistoryEntry, EpisodeWatchEntry> {\n    override suspend fun map(from: HistoryEntry) = EpisodeWatchEntry(\n        episodeId = 0,\n        traktId = from.id,\n        watchedAt = from.watched_at\n    )\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport com.uwetrottmann.tmdb2.entities.BaseTvShow\nimport com.uwetrottmann.tmdb2.entities.TvShowResultsPage\n\nfun <F, T> Mapper<F, T>.forLists(): suspend (List<F>) -> List<T> {\n    return { list -> list.map { item -> map(item) } }\n}\n\nfun <F, T> IndexedMapper<F, T>.forLists(): suspend (List<F>) -> List<T> {\n    return { list -> list.mapIndexed { index, item -> map(index, item) } }\n}\n\nfun <F, T1, T2> pairMapperOf(\n    firstMapper: Mapper<F, T1>,\n    secondMapper: Mapper<F, T2>\n): suspend (List<F>) -> List<Pair<T1, T2>> {\n    return { from ->\n        from.map { firstMapper.map(it) to secondMapper.map(it) }\n    }\n}\n\nfun <F, T1, T2> pairMapperOf(\n    firstMapper: Mapper<F, T1>,\n    secondMapper: IndexedMapper<F, T2>\n): suspend (List<F>) -> List<Pair<T1, T2>> {\n    return { from ->\n        from.mapIndexed { index, value ->\n            firstMapper.map(value) to secondMapper.map(index, value)\n        }\n    }\n}\n\nfun <F, T> Mapper<F, T>.toLambda(): suspend (F) -> T {\n    return { map(it) }\n}\n\nfun <T> unwrapTmdbShowResults(\n    f: suspend (List<BaseTvShow>) -> List<T>\n): suspend (TvShowResultsPage) -> List<T> = {\n    f(it.results ?: emptyList())\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.TiviShow\nimport com.uwetrottmann.trakt5.entities.ListEntry\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktListEntryToTiviShow @Inject constructor(\n    private val showMapper: TraktShowToTiviShow\n) : Mapper<ListEntry, TiviShow> {\n    override suspend fun map(from: ListEntry) = showMapper.map(from.show)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.ImageType\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport com.uwetrottmann.tmdb2.entities.TvShowResultsPage\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TmdbShowResultsPageToTiviShows @Inject constructor(\n    private val tmdbShowMapper: TmdbBaseShowToTiviShow\n) : Mapper<TvShowResultsPage, List<Pair<TiviShow, List<ShowTmdbImage>>>> {\n    override suspend fun map(from: TvShowResultsPage): List<Pair<TiviShow, List<ShowTmdbImage>>> {\n        return from.results.map {\n            val show = tmdbShowMapper.map(it)\n\n            val images = ArrayList<ShowTmdbImage>()\n            if (it.poster_path != null) {\n                images += ShowTmdbImage(\n                    showId = 0,\n                    path = it.poster_path,\n                    isPrimary = true,\n                    type = ImageType.POSTER\n                )\n            }\n            if (it.backdrop_path != null) {\n                images += ShowTmdbImage(\n                    showId = 0,\n                    path = it.backdrop_path,\n                    isPrimary = true,\n                    type = ImageType.BACKDROP\n                )\n            }\n            show to images\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.daos.TiviShowDao\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass ShowIdToTraktIdMapper @Inject constructor(\n    private val showDao: TiviShowDao\n) : Mapper<Long, Int?> {\n    override suspend fun map(from: Long): Int? {\n        return showDao.getTraktIdForShowId(from)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport com.uwetrottmann.trakt5.entities.Season as TraktSeason\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktSeasonToSeasonWithEpisodes @Inject constructor(\n    private val seasonMapper: TraktSeasonToSeason,\n    private val episoderMapper: TraktEpisodeToEpisode\n) : Mapper<TraktSeason, Pair<Season, List<Episode>>> {\n    override suspend fun map(from: TraktSeason): Pair<Season, List<Episode>> {\n        return seasonMapper.map(from) to from.episodes.map { episoderMapper.map(it) }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.TiviShow\nimport com.uwetrottmann.trakt5.entities.Show\nimport java.util.Locale\nimport javax.inject.Inject\nimport javax.inject.Singleton\nimport org.threeten.bp.DayOfWeek\nimport org.threeten.bp.LocalTime\nimport org.threeten.bp.ZoneId\nimport org.threeten.bp.format.TextStyle\n\n@Singleton\nclass TraktShowToTiviShow @Inject constructor(\n    private val statusMapper: TraktStatusToShowStatus\n) : Mapper<Show, TiviShow> {\n    override suspend fun map(from: Show) = TiviShow(\n        traktId = from.ids?.trakt,\n        tmdbId = from.ids?.tmdb,\n        imdbId = from.ids?.imdb,\n        title = from.title,\n        summary = from.overview,\n        homepage = from.homepage,\n        traktRating = from.rating?.toFloat(),\n        traktVotes = from.votes,\n        certification = from.certification,\n        runtime = from.runtime,\n        network = from.network,\n        country = from.country,\n        firstAired = from.first_aired,\n        _genres = from.genres?.joinToString(\",\"),\n        traktDataUpdate = from.updated_at,\n        status = from.status?.let {\n            statusMapper.map(it)\n        },\n        airsDay = from.airs?.day?.let { dayString ->\n            DayOfWeek.values().firstOrNull { day ->\n                dayString.equals(day.getDisplayName(TextStyle.FULL, Locale.getDefault()), true)\n            }\n        },\n        airsTime = from.airs?.time?.let {\n            try {\n                LocalTime.parse(it)\n            } catch (e: Exception) {\n                null\n            }\n        },\n        airsTimeZone = from.airs?.timezone?.let {\n            try {\n                ZoneId.of(it)\n            } catch (e: Exception) {\n                null\n            }\n        }\n    )\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.daos.TiviShowDao\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass ShowIdToTmdbIdMapper @Inject constructor(\n    private val showDao: TiviShowDao\n) : Mapper<Long, Int> {\n    override suspend fun map(from: Long) = showDao.getTmdbIdForShowId(from)\n        ?: throw IllegalArgumentException(\"Show with id $from does not exist\")\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.TraktUser\nimport com.uwetrottmann.trakt5.entities.User\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass UserToTraktUser @Inject constructor() : Mapper<User, TraktUser> {\n    override suspend fun map(from: User) = TraktUser(\n        username = from.username,\n        name = from.name,\n        location = from.location,\n        about = from.about,\n        avatarUrl = from.images?.avatar?.full,\n        joined = from.joined_at,\n        vip = from.vip\n    )\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.Episode\nimport com.uwetrottmann.tmdb2.entities.TvEpisode\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TmdbEpisodeToEpisode @Inject constructor() : Mapper<TvEpisode, Episode> {\n    override suspend fun map(from: TvEpisode) = Episode(\n        seasonId = 0,\n        tmdbId = from.id,\n        title = from.name,\n        number = from.episode_number,\n        summary = from.overview,\n        tmdbBackdropPath = from.still_path\n    )\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.Season\nimport com.uwetrottmann.trakt5.entities.Season as TraktSeason\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktSeasonToSeason @Inject constructor() : Mapper<TraktSeason, Season> {\n    override suspend fun map(from: TraktSeason) = Season(\n        showId = 0,\n        traktId = from.ids?.trakt,\n        tmdbId = from.ids?.tmdb,\n        number = from.number,\n        title = from.title,\n        summary = from.overview,\n        traktRating = from.rating?.toFloat() ?: 0f,\n        traktRatingVotes = from.votes ?: 0,\n        episodeCount = from.episode_count,\n        episodesAired = from.aired_episodes,\n        network = from.network\n    )\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.daos.EpisodesDao\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass EpisodeIdToTraktIdMapper @Inject constructor(\n    private val dao: EpisodesDao\n) : Mapper<Long, Int> {\n    override suspend fun map(from: Long): Int {\n        return dao.episodeTraktIdForId(from)\n            ?: throw IllegalArgumentException(\"Episode with id $from does not exist\")\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.Episode\nimport com.uwetrottmann.trakt5.entities.Episode as TraktEpisode\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktEpisodeToEpisode @Inject constructor() : Mapper<TraktEpisode, Episode> {\n    override suspend fun map(from: TraktEpisode) = Episode(\n        seasonId = 0,\n        traktId = from.ids.trakt,\n        tmdbId = from.ids.tmdb,\n        title = from.title,\n        number = from.number,\n        summary = from.overview,\n        firstAired = from.first_aired,\n        traktRating = from.rating?.toFloat() ?: 0f,\n        traktRatingVotes = from.votes\n    )\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.ImageType\nimport app.tivi.data.entities.ShowTmdbImage\nimport com.uwetrottmann.tmdb2.entities.Image\nimport com.uwetrottmann.tmdb2.entities.TvShow\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TmdbImagesToShowImages @Inject constructor() : Mapper<TvShow, List<ShowTmdbImage>> {\n    override suspend fun map(from: TvShow): List<ShowTmdbImage> {\n        fun mapImage(image: Image, type: ImageType): ShowTmdbImage {\n            return ShowTmdbImage(\n                showId = 0,\n                path = image.file_path!!,\n                type = type,\n                language = image.iso_639_1,\n                rating = image.vote_average?.toFloat() ?: 0f,\n                isPrimary = when (type) {\n                    ImageType.BACKDROP -> image.file_path == from.backdrop_path\n                    ImageType.POSTER -> image.file_path == from.poster_path\n                    else -> false\n                }\n            )\n        }\n\n        val result = mutableListOf<ShowTmdbImage>()\n        from.images?.posters?.mapTo(result) { mapImage(it, ImageType.POSTER) }\n        from.images?.backdrops?.mapTo(result) { mapImage(it, ImageType.BACKDROP) }\n        return result\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.daos.SeasonsDao\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass SeasonIdToTraktIdMapper @Inject constructor(\n    private val dao: SeasonsDao\n) : Mapper<Long, Int> {\n    override suspend fun map(from: Long): Int {\n        return dao.traktIdForId(from)\n            ?: throw IllegalArgumentException(\"Trakt Id for season id $from does not exist\")\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.TiviShow\nimport com.uwetrottmann.trakt5.entities.TrendingShow\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktTrendingShowToTiviShow @Inject constructor(\n    private val showMapper: TraktShowToTiviShow\n) : Mapper<TrendingShow, TiviShow> {\n    override suspend fun map(from: TrendingShow) = showMapper.map(from.show!!)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.ShowStatus\nimport com.uwetrottmann.trakt5.enums.Status\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktStatusToShowStatus @Inject constructor() : Mapper<Status, ShowStatus> {\n    override suspend fun map(from: Status) = when (from) {\n        Status.ENDED -> ShowStatus.ENDED\n        Status.RETURNING -> ShowStatus.RETURNING\n        Status.CANCELED -> ShowStatus.CANCELED\n        Status.IN_PRODUCTION -> ShowStatus.IN_PRODUCTION\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.TiviShow\nimport com.uwetrottmann.tmdb2.entities.BaseTvShow\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TmdbBaseShowToTiviShow @Inject constructor() : Mapper<BaseTvShow, TiviShow> {\n    override suspend fun map(from: BaseTvShow) = TiviShow(\n        tmdbId = from.id,\n        title = from.name,\n        summary = from.overview\n    )\n}",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.TrendingShowEntry\nimport com.uwetrottmann.trakt5.entities.TrendingShow\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktTrendingShowToTrendingShowEntry @Inject constructor() : Mapper<TrendingShow, TrendingShowEntry> {\n    override suspend fun map(from: TrendingShow): TrendingShowEntry {\n        return TrendingShowEntry(\n            showId = 0,\n            watchers = from.watchers ?: 0,\n            page = 0\n        )\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\ninterface Mapper<F, T> {\n    suspend fun map(from: F): T\n}\n\ninterface IndexedMapper<F, T> {\n    suspend fun map(index: Int, from: F): T\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.Episode\nimport com.uwetrottmann.trakt5.entities.HistoryEntry\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktHistoryEntryToEpisode @Inject constructor(\n    private val mapper: TraktEpisodeToEpisode\n) : Mapper<HistoryEntry, Episode> {\n    override suspend fun map(from: HistoryEntry) = mapper.map(from.episode)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.FollowedShowEntry\nimport com.uwetrottmann.trakt5.entities.ListEntry\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktListEntryToFollowedShowEntry @Inject constructor() : Mapper<ListEntry, FollowedShowEntry> {\n    override suspend fun map(from: ListEntry) = FollowedShowEntry(\n        showId = 0,\n        followedAt = from.listed_at,\n        traktId = from.id\n    )\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.TiviShow\nimport com.uwetrottmann.trakt5.entities.SearchResult\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktSearchResultToTiviShow @Inject constructor(\n    private val showMapper: TraktShowToTiviShow\n) : Mapper<SearchResult, TiviShow> {\n    override suspend fun map(from: SearchResult) = showMapper.map(from.show)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.mappers\n\nimport app.tivi.data.entities.TiviShow\nimport com.uwetrottmann.trakt5.entities.BaseShow\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass TraktBaseShowToTiviShow @Inject constructor(\n    private val showMapper: TraktShowToTiviShow\n) : Mapper<BaseShow, TiviShow> {\n    override suspend fun map(from: BaseShow): TiviShow {\n        val mapped = showMapper.map(from.show)\n        return mapped.copy(\n            traktDataUpdate = from.last_updated_at ?: mapped.traktDataUpdate\n        )\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.views\n\nimport androidx.room.DatabaseView\nimport app.tivi.data.entities.Season\n\n@DatabaseView(\"\"\"\n    SELECT fs.id, COUNT(*) as episodeCount, COUNT(ew.watched_at) as watchedEpisodeCount\n    FROM myshows_entries as fs\n    INNER JOIN seasons AS s ON fs.show_id = s.show_id\n    INNER JOIN episodes AS eps ON eps.season_id = s.id\n    LEFT JOIN episode_watch_entries as ew ON ew.episode_id = eps.id\n    WHERE eps.first_aired IS NOT NULL\n        AND datetime(eps.first_aired) < datetime('now')\n        AND s.number != ${Season.NUMBER_SPECIALS}\n        AND s.ignored = 0\n    GROUP BY fs.id\n\"\"\")\ndata class FollowedShowsWatchStats(\n    val id: Long,\n    val episodeCount: Int,\n    val watchedEpisodeCount: Int\n)",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.views\n\nimport androidx.room.DatabaseView\nimport app.tivi.data.entities.Season\nimport org.threeten.bp.OffsetDateTime\n\n@DatabaseView(value = \"\"\"\nSELECT\n  fs.id,\n  MAX(datetime(eps.first_aired)) as last_watched_air_date\nFROM\n  myshows_entries as fs\n  INNER JOIN seasons AS s ON fs.show_id = s.show_id\n  INNER JOIN episodes AS eps ON eps.season_id = s.id\n  INNER JOIN episode_watch_entries as ew ON ew.episode_id = eps.id\nWHERE\n  s.number != ${Season.NUMBER_SPECIALS}\n  AND s.ignored = 0\nGROUP BY\n  fs.id\n\"\"\", viewName = \"followed_last_watched_airdate\")\ndata class FollowedShowsLastWatched(\n    val id: Long,\n    val lastWatchedEpisodeAirDate: OffsetDateTime?\n)",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.views\n\nimport androidx.room.DatabaseView\nimport app.tivi.data.entities.Season\nimport org.threeten.bp.OffsetDateTime\n\n@DatabaseView(value = \"\"\"\nSELECT\n  fs.id,\n  MIN(datetime(eps.first_aired)) AS next_ep_to_watch_air_date\nFROM\n  myshows_entries as fs\n  INNER JOIN seasons AS s ON fs.show_id = s.show_id\n  INNER JOIN episodes AS eps ON eps.season_id = s.id\n  LEFT JOIN episode_watch_entries as ew ON ew.episode_id = eps.id\n  INNER JOIN followed_last_watched_airdate AS lw ON lw.id = fs.id\nWHERE\n  s.number != ${Season.NUMBER_SPECIALS}\n  AND s.ignored = 0\n  AND watched_at IS NULL\n  AND datetime(first_aired) < datetime('now')\n  AND datetime(first_aired) > datetime(last_watched_air_date)\nGROUP BY\n  fs.id\n\"\"\", viewName = \"followed_next_to_watch\")\ndata class FollowedShowsNextToWatch(\n    val id: Long,\n    val nextEpisodeToWatchAirDate: OffsetDateTime?\n)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport org.threeten.bp.OffsetDateTime\n\n@Entity(tableName = \"episode_watch_entries\",\n    indices = [\n        Index(value = [\"episode_id\"]),\n        Index(value = [\"trakt_id\"], unique = true)\n    ],\n    foreignKeys = [\n        ForeignKey(\n            entity = Episode::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"episode_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE\n        )\n    ]\n)\ndata class EpisodeWatchEntry(\n    @PrimaryKey(autoGenerate = true) override val id: Long = 0,\n    @ColumnInfo(name = \"episode_id\") val episodeId: Long,\n    @ColumnInfo(name = \"trakt_id\") val traktId: Long? = null,\n    @ColumnInfo(name = \"watched_at\") val watchedAt: OffsetDateTime,\n    @ColumnInfo(name = \"pending_action\") val pendingAction: PendingAction = PendingAction.NOTHING\n) : TiviEntity",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\ndata class ShowImages(val images: List<ShowTmdbImage>) {\n\n    val backdrop by lazy(LazyThreadSafetyMode.NONE) {\n        findHighestRatedForType(ImageType.BACKDROP)\n    }\n\n    val poster by lazy(LazyThreadSafetyMode.NONE) {\n        findHighestRatedForType(ImageType.POSTER)\n    }\n\n    private fun findHighestRatedForType(type: ImageType): ShowTmdbImage? {\n        return images.filter { it.type == type }\n            .maxBy { it.rating + (if (it.isPrimary) 10f else 0f) }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"seasons\",\n    indices = [\n        Index(value = [\"trakt_id\"], unique = true),\n        Index(value = [\"show_id\"])\n    ],\n    foreignKeys = [\n        ForeignKey(entity = TiviShow::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"show_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE)\n    ])\ndata class Season(\n    @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"id\") override val id: Long = 0,\n    @ColumnInfo(name = \"show_id\") val showId: Long,\n    @ColumnInfo(name = \"trakt_id\") override val traktId: Int? = null,\n    @ColumnInfo(name = \"tmdb_id\") override val tmdbId: Int? = null,\n    @ColumnInfo(name = \"title\") val title: String? = null,\n    @ColumnInfo(name = \"overview\") val summary: String? = null,\n    @ColumnInfo(name = \"number\") val number: Int? = null,\n    @ColumnInfo(name = \"network\") val network: String? = null,\n    @ColumnInfo(name = \"ep_count\") val episodeCount: Int? = null,\n    @ColumnInfo(name = \"ep_aired\") val episodesAired: Int? = null,\n    @ColumnInfo(name = \"trakt_rating\") val traktRating: Float? = null,\n    @ColumnInfo(name = \"trakt_votes\") val traktRatingVotes: Int? = null,\n    @ColumnInfo(name = \"tmdb_poster_path\") val tmdbPosterPath: String? = null,\n    @ColumnInfo(name = \"tmdb_backdrop_path\") val tmdbBackdropPath: String? = null,\n    @ColumnInfo(name = \"ignored\") val ignored: Boolean = false\n) : TiviEntity, TmdbIdEntity, TraktIdEntity {\n    companion object {\n        const val NUMBER_SPECIALS = 0\n        val EMPTY = Season(showId = 0)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\ninterface TiviEntity {\n    val id: Long\n}\n\ninterface TraktIdEntity {\n    val traktId: Int?\n}\n\ninterface TmdbIdEntity {\n    val tmdbId: Int?\n}\n\ninterface TmdbImageEntity : TiviEntity {\n    val path: String\n    val type: ImageType\n    val language: String?\n    val rating: Float\n    val isPrimary: Boolean\n}\n\nenum class ImageType(val storageKey: String) {\n    BACKDROP(\"backdrop\"),\n    POSTER(\"poster\"),\n    LOGO(\"logo\"),\n}\n\nfun <T : TmdbImageEntity> Collection<T>.findHighestRatedPoster(): T? {\n    return filter { it.type == ImageType.POSTER }\n        .maxBy { it.rating + (if (it.isPrimary) 10f else 0f) }\n}\n\nfun <T : TmdbImageEntity> Collection<T>.findHighestRatedBackdrop(): T? {\n    return filter { it.type == ImageType.BACKDROP }\n        .maxBy { it.rating + (if (it.isPrimary) 10f else 0f) }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport app.tivi.data.PaginatedEntry\n\n@Entity(tableName = \"recommended_entries\",\n    indices = [\n        Index(value = [\"show_id\"], unique = true)\n    ],\n    foreignKeys = [\n        ForeignKey(entity = TiviShow::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"show_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE\n        )\n    ]\n)\ndata class RecommendedShowEntry(\n    @PrimaryKey(autoGenerate = true) override val id: Long = 0,\n    @ColumnInfo(name = \"show_id\") override val showId: Long,\n    @ColumnInfo(name = \"page\") override val page: Int\n) : PaginatedEntry",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport org.threeten.bp.Instant\n\n@Entity(\n    tableName = \"last_requests\",\n    indices = [Index(value = [\"request\", \"entity_id\"], unique = true)]\n)\ndata class LastRequest(\n    @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"id\") override val id: Long = 0,\n    @ColumnInfo(name = \"request\") val request: Request,\n    @ColumnInfo(name = \"entity_id\") val entityId: Long,\n    @ColumnInfo(name = \"timestamp\") val timestamp: Instant\n) : TiviEntity",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"show_images\",\n    indices = [\n        Index(value = [\"show_id\"])\n    ],\n    foreignKeys = [\n        ForeignKey(entity = TiviShow::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"show_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE)\n    ])\ndata class ShowTmdbImage(\n    @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"id\") override val id: Long = 0,\n    @ColumnInfo(name = \"show_id\") val showId: Long,\n    @ColumnInfo(name = \"path\") override val path: String,\n    @ColumnInfo(name = \"type\") override val type: ImageType,\n    @ColumnInfo(name = \"lang\") override val language: String? = null,\n    @ColumnInfo(name = \"rating\") override val rating: Float = 0f,\n    @ColumnInfo(name = \"is_primary\") override val isPrimary: Boolean = false\n) : TiviEntity, TmdbImageEntity",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.Ignore\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport org.threeten.bp.DayOfWeek\nimport org.threeten.bp.LocalTime\nimport org.threeten.bp.OffsetDateTime\nimport org.threeten.bp.ZoneId\n\n@Entity(tableName = \"shows\",\n    indices = [\n        Index(value = [\"trakt_id\"], unique = true),\n        Index(value = [\"tmdb_id\"])\n    ]\n)\ndata class TiviShow(\n    @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"id\") override val id: Long = 0,\n    @ColumnInfo(name = \"title\") val title: String? = null,\n    @ColumnInfo(name = \"original_title\") val originalTitle: String? = null,\n    @ColumnInfo(name = \"trakt_id\") override val traktId: Int? = null,\n    @ColumnInfo(name = \"tmdb_id\") override val tmdbId: Int? = null,\n    @ColumnInfo(name = \"imdb_id\") val imdbId: String? = null,\n    @ColumnInfo(name = \"overview\") val summary: String? = null,\n    @ColumnInfo(name = \"homepage\") val homepage: String? = null,\n    @ColumnInfo(name = \"trakt_rating\") val traktRating: Float? = null,\n    @ColumnInfo(name = \"trakt_votes\") val traktVotes: Int? = null,\n    @ColumnInfo(name = \"certification\") val certification: String? = null,\n    @ColumnInfo(name = \"first_aired\") val firstAired: OffsetDateTime? = null,\n    @ColumnInfo(name = \"country\") val country: String? = null,\n    @ColumnInfo(name = \"network\") val network: String? = null,\n    @ColumnInfo(name = \"network_logo_path\") val networkLogoPath: String? = null,\n    @ColumnInfo(name = \"runtime\") val runtime: Int? = null,\n    @ColumnInfo(name = \"genres\") val _genres: String? = null,\n    @ColumnInfo(name = \"last_trakt_data_update\") val traktDataUpdate: OffsetDateTime? = null,\n    @ColumnInfo(name = \"status\") val status: ShowStatus? = null,\n    @ColumnInfo(name = \"airs_day\") val airsDay: DayOfWeek? = null,\n    @ColumnInfo(name = \"airs_time\") val airsTime: LocalTime? = null,\n    @ColumnInfo(name = \"airs_tz\") val airsTimeZone: ZoneId? = null\n) : TiviEntity, TraktIdEntity, TmdbIdEntity {\n    @Ignore\n    constructor() : this(0)\n\n    @delegate:Ignore\n    val genres by lazy(LazyThreadSafetyMode.NONE) {\n        _genres?.split(\",\")?.mapNotNull { Genre.fromTraktValue(it.trim()) } ?: emptyList()\n    }\n\n    companion object {\n        val EMPTY_SHOW = TiviShow()\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nenum class Genre(val traktValue: String) {\n    DRAMA(\"drama\"),\n    FANTASY(\"fantasy\"),\n    SCIENCE_FICTION(\"science-fiction\"),\n    ACTION(\"action\"),\n    ADVENTURE(\"adventure\"),\n    CRIME(\"crime\"),\n    THRILLER(\"thriller\"),\n    COMEDY(\"comedy\"),\n    HORROR(\"horror\"),\n    MYSTERY(\"mystery\");\n\n    companion object {\n        private val values by lazy { values() }\n        fun fromTraktValue(value: String) = values.firstOrNull { it.traktValue == value }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nenum class ShowStatus(val storageKey: String) {\n    ENDED(\"ended\"),\n    RETURNING(\"returning\"),\n    CANCELED(\"canceled\"),\n    IN_PRODUCTION(\"inproduction\");\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport app.tivi.data.MultipleEntry\n\n@Entity(tableName = \"related_shows\",\n    indices = [\n        Index(value = [\"show_id\"]),\n        Index(value = [\"other_show_id\"])\n    ],\n    foreignKeys = [\n        ForeignKey(\n            entity = TiviShow::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"show_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE\n        ),\n        ForeignKey(\n            entity = TiviShow::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"other_show_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE\n        )\n    ]\n)\ndata class RelatedShowEntry(\n    @PrimaryKey(autoGenerate = true) override val id: Long = 0,\n    @ColumnInfo(name = \"show_id\") override val showId: Long,\n    @ColumnInfo(name = \"other_show_id\") override val otherShowId: Long,\n    @ColumnInfo(name = \"order_index\") val orderIndex: Int\n) : MultipleEntry",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport app.tivi.data.Entry\nimport org.threeten.bp.OffsetDateTime\n\n@Entity(tableName = \"myshows_entries\",\n    indices = [\n        Index(value = [\"show_id\"], unique = true)\n    ],\n    foreignKeys = [\n        ForeignKey(\n            entity = TiviShow::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"show_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE\n        )\n    ]\n)\ndata class FollowedShowEntry(\n    @PrimaryKey(autoGenerate = true) override val id: Long = 0,\n    @ColumnInfo(name = \"show_id\") override val showId: Long,\n    @ColumnInfo(name = \"followed_at\") val followedAt: OffsetDateTime? = null,\n    @ColumnInfo(name = \"pending_action\") val pendingAction: PendingAction = PendingAction.NOTHING,\n    @ColumnInfo(name = \"trakt_id\") val traktId: Long? = null\n) : Entry",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nenum class RefreshType { QUICK, FULL }",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport app.tivi.data.PaginatedEntry\n\n@Entity(tableName = \"popular_shows\",\n    indices = [\n        Index(value = [\"show_id\"], unique = true)\n    ],\n    foreignKeys = [\n        ForeignKey(entity = TiviShow::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"show_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE\n        )\n    ]\n)\ndata class PopularShowEntry(\n    @PrimaryKey(autoGenerate = true) override val id: Long = 0,\n    @ColumnInfo(name = \"show_id\") override val showId: Long,\n    @ColumnInfo(name = \"page\") override val page: Int,\n    @ColumnInfo(name = \"page_order\") val pageOrder: Int\n) : PaginatedEntry",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport app.tivi.data.Entry\nimport org.threeten.bp.OffsetDateTime\n\n@Entity(tableName = \"watched_entries\",\n    indices = [\n        Index(value = [\"show_id\"], unique = true)\n    ],\n    foreignKeys = [\n        ForeignKey(entity = TiviShow::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"show_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE\n        )\n    ]\n)\ndata class WatchedShowEntry(\n    @PrimaryKey(autoGenerate = true) override val id: Long = 0,\n    @ColumnInfo(name = \"show_id\") override val showId: Long,\n    @ColumnInfo(name = \"last_watched\") val lastWatched: OffsetDateTime\n) : Entry",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport org.threeten.bp.OffsetDateTime\n\n@Entity(\n    tableName = \"episodes\",\n    indices = [\n        Index(value = [\"trakt_id\"], unique = true),\n        Index(value = [\"season_id\"])\n    ],\n    foreignKeys = [\n        ForeignKey(entity = Season::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"season_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE)\n    ]\n)\ndata class Episode(\n    @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"id\") override val id: Long = 0,\n    @ColumnInfo(name = \"season_id\") val seasonId: Long,\n    @ColumnInfo(name = \"trakt_id\") override val traktId: Int? = null,\n    @ColumnInfo(name = \"tmdb_id\") override val tmdbId: Int? = null,\n    @ColumnInfo(name = \"title\") val title: String? = null,\n    @ColumnInfo(name = \"overview\") val summary: String? = null,\n    @ColumnInfo(name = \"number\") val number: Int? = null,\n    @ColumnInfo(name = \"first_aired\") val firstAired: OffsetDateTime? = null,\n    @ColumnInfo(name = \"trakt_rating\") val traktRating: Float? = null,\n    @ColumnInfo(name = \"trakt_rating_votes\") val traktRatingVotes: Int? = null,\n    @ColumnInfo(name = \"tmdb_backdrop_path\") val tmdbBackdropPath: String? = null\n) : TiviEntity, TraktIdEntity, TmdbIdEntity {\n    companion object {\n        val EMPTY = Episode(seasonId = 0)\n    }\n\n    fun isAired() = when {\n        firstAired != null -> firstAired.isBefore(OffsetDateTime.now())\n        else -> false\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nenum class PendingAction(val value: String) {\n    NOTHING(\"nothing\"),\n    UPLOAD(\"upload\"),\n    DELETE(\"delete\"),\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nenum class SortOption {\n    SUPER_SORT,\n    LAST_WATCHED,\n    ALPHABETICAL,\n    DATE_ADDED\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport app.tivi.data.resultentities.ShowDetailed\n\ndata class SearchResults(val query: String, val results: List<ShowDetailed>)",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport org.threeten.bp.OffsetDateTime\n\n@Entity(\n    tableName = \"users\",\n    indices = [Index(value = [\"username\"], unique = true)]\n)\ndata class TraktUser(\n    @PrimaryKey(autoGenerate = true) @ColumnInfo(name = \"id\") override val id: Long = 0,\n    @ColumnInfo(name = \"username\") val username: String,\n    @ColumnInfo(name = \"name\") val name: String,\n    @ColumnInfo(name = \"joined_date\") val joined: OffsetDateTime? = null,\n    @ColumnInfo(name = \"location\") val location: String? = null,\n    @ColumnInfo(name = \"about\") val about: String? = null,\n    @ColumnInfo(name = \"avatar_url\") val avatarUrl: String? = null,\n    @ColumnInfo(name = \"vip\") val vip: Boolean? = null,\n    @ColumnInfo(name = \"is_me\") val isMe: Boolean = false\n) : TiviEntity",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nenum class Request(val tag: String) {\n    SHOW_DETAILS(\"show_details\"),\n    SHOW_IMAGES(\"show_images\"),\n    SHOW_SEASONS(\"show_seasons\"),\n    EPISODE_DETAILS(\"episode_details\"),\n    SHOW_EPISODE_WATCHES(\"show_episode_watches\"),\n    FOLLOWED_SHOWS(\"followed_shows\"),\n    WATCHED_SHOWS(\"watched_shows\"),\n    USER_PROFILE(\"user_profile\"),\n    RELATED_SHOWS(\"related_shows\"),\n    TRENDING_SHOWS(\"trending_shows\"),\n    POPULAR_SHOWS(\"popular_shows\"),\n    RECOMMENDED_SHOWS(\"recommended_shows\"),\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport app.tivi.data.PaginatedEntry\n\n@Entity(tableName = \"trending_shows\",\n    indices = [\n        Index(value = [\"show_id\"], unique = true)\n    ],\n    foreignKeys = [\n        ForeignKey(entity = TiviShow::class,\n            parentColumns = arrayOf(\"id\"),\n            childColumns = arrayOf(\"show_id\"),\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE\n        )\n    ]\n)\ndata class TrendingShowEntry(\n    @PrimaryKey(autoGenerate = true) override val id: Long = 0,\n    @ColumnInfo(name = \"show_id\") override val showId: Long,\n    @ColumnInfo(name = \"page\") override val page: Int,\n    @ColumnInfo(name = \"watchers\") val watchers: Int\n) : PaginatedEntry",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nimport androidx.room.ColumnInfo\nimport androidx.room.Entity\nimport androidx.room.Fts4\n\n@Fts4(contentEntity = TiviShow::class)\n@Entity(tableName = \"shows_fts\")\ndata class TiviShowFts(\n    @ColumnInfo(name = \"title\") val title: String? = null,\n    @ColumnInfo(name = \"original_title\") val originalTitle: String? = null\n)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nenum class ActionDate {\n    NOW,\n    AIR_DATE\n}",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data\n\nimport com.dropbox.android.external.store4.Store\nimport com.dropbox.android.external.store4.StoreRequest\nimport com.dropbox.android.external.store4.StoreResponse\nimport com.dropbox.android.external.store4.fresh\nimport kotlinx.coroutines.flow.filterNot\nimport kotlinx.coroutines.flow.first\n\nsuspend fun <Key : Any, Output : Any> Store<Key, Output>.fetch(\n    key: Key,\n    forceFresh: Boolean = false,\n    doFreshIf: suspend (Output) -> Boolean = { false }\n): Output {\n    return if (forceFresh) {\n        // If we're forcing a fresh fetch, do it now\n        fresh(key)\n    } else {\n        // Else we'll check the current cached value\n        val cached = cachedOnly(key)\n        if (cached == null || doFreshIf.invoke(cached)) {\n            // Our cached value isn't valid, do a fresh fetch\n            fresh(key)\n        } else {\n            // We have a current cached value\n            cached\n        }\n    }\n}\n\n/**\n * A wrapper around [fetch] which supports non-nullable collection outputs.\n * Primarily it checks for empty collections\n */\nsuspend fun <Key : Any, Output : Collection<Any>> Store<Key, Output>.fetchCollection(\n    key: Key,\n    forceFresh: Boolean = false,\n    doFreshIf: suspend (Output) -> Boolean = { false }\n): Output {\n    return fetch(key, forceFresh = forceFresh) { output ->\n        output.isEmpty() || doFreshIf(output)\n    }\n}\n\nsuspend fun <Key : Any, Output : Any> Store<Key, Output>.cachedOnly(key: Key): Output? {\n    return stream(StoreRequest.cached(key, refresh = false))\n        .filterNot { it is StoreResponse.Loading }\n        .first()\n        .dataOrNull()\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Dao\nimport androidx.room.Query\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.entities.PendingAction\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class EpisodeWatchEntryDao : EntityDao<EpisodeWatchEntry>() {\n    @Query(\"SELECT * FROM episode_watch_entries WHERE episode_id = :episodeId\")\n    abstract suspend fun watchesForEpisode(episodeId: Long): List<EpisodeWatchEntry>\n\n    @Query(\"SELECT COUNT(id) FROM episode_watch_entries WHERE episode_id = :episodeId\")\n    abstract suspend fun watchCountForEpisode(episodeId: Long): Int\n\n    @Query(\"SELECT * FROM episode_watch_entries WHERE episode_id = :episodeId\")\n    abstract fun watchesForEpisodeObservable(episodeId: Long): Flow<List<EpisodeWatchEntry>>\n\n    @Query(\"SELECT * FROM episode_watch_entries WHERE id = :id\")\n    abstract suspend fun entryWithId(id: Long): EpisodeWatchEntry?\n\n    @Query(\"SELECT * FROM episode_watch_entries WHERE trakt_id = :traktId\")\n    abstract suspend fun entryWithTraktId(traktId: Long): EpisodeWatchEntry?\n\n    @Query(\"SELECT id FROM episode_watch_entries WHERE trakt_id = :traktId\")\n    abstract suspend fun entryIdWithTraktId(traktId: Long): Long?\n\n    suspend fun entriesForShowIdWithNoPendingAction(showId: Long): List<EpisodeWatchEntry> {\n        return entriesForShowIdWithPendingAction(showId, PendingAction.NOTHING.value)\n    }\n\n    suspend fun entriesForShowIdWithSendPendingActions(showId: Long): List<EpisodeWatchEntry> {\n        return entriesForShowIdWithPendingAction(showId, PendingAction.UPLOAD.value)\n    }\n\n    suspend fun entriesForShowIdWithDeletePendingActions(showId: Long): List<EpisodeWatchEntry> {\n        return entriesForShowIdWithPendingAction(showId, PendingAction.DELETE.value)\n    }\n\n    @Query(\"\"\"\n        SELECT ew.* FROM episode_watch_entries AS ew\n        INNER JOIN episodes AS eps ON ew.episode_id = eps.id\n        INNER JOIN seasons AS s ON eps.season_id = s.id\n        INNER JOIN shows ON s.show_id = shows.id\n        WHERE shows.id = :showId AND ew.pending_action = :pendingAction\n    \"\"\")\n    internal abstract suspend fun entriesForShowIdWithPendingAction(\n        showId: Long,\n        pendingAction: String\n    ): List<EpisodeWatchEntry>\n\n    @Query(\"\"\"\n        SELECT ew.* FROM episode_watch_entries AS ew\n        INNER JOIN episodes AS eps ON ew.episode_id = eps.id\n        INNER JOIN seasons AS s ON eps.season_id = s.id\n        INNER JOIN shows ON s.show_id = shows.id\n        WHERE shows.id = :showId\n    \"\"\")\n    abstract suspend fun entriesForShowId(showId: Long): List<EpisodeWatchEntry>\n\n    @Query(\"UPDATE episode_watch_entries SET pending_action = :pendingAction WHERE id IN (:ids)\")\n    abstract suspend fun updateEntriesToPendingAction(ids: List<Long>, pendingAction: String): Int\n\n    @Query(\"DELETE FROM episode_watch_entries WHERE id = :id\")\n    abstract suspend fun deleteWithId(id: Long): Int\n\n    @Query(\"DELETE FROM episode_watch_entries WHERE id IN (:ids)\")\n    abstract suspend fun deleteWithIds(ids: List<Long>): Int\n\n    @Query(\"DELETE FROM episode_watch_entries WHERE trakt_id = :traktId\")\n    abstract suspend fun deleteWithTraktId(traktId: Long): Int\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.paging.DataSource\nimport androidx.room.Dao\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport app.tivi.data.entities.FollowedShowEntry\nimport app.tivi.data.entities.PendingAction\nimport app.tivi.data.entities.Season\nimport app.tivi.data.resultentities.FollowedShowEntryWithShow\nimport app.tivi.data.views.FollowedShowsWatchStats\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class FollowedShowsDao : EntryDao<FollowedShowEntry, FollowedShowEntryWithShow>() {\n    @Query(\"SELECT * FROM myshows_entries\")\n    abstract suspend fun entries(): List<FollowedShowEntry>\n\n    @Transaction\n    @Query(ENTRY_QUERY_SUPER_SORT)\n    internal abstract fun pagedListSuperSort(): DataSource.Factory<Int, FollowedShowEntryWithShow>\n\n    @Transaction\n    @Query(ENTRY_QUERY_SUPER_SORT_FILTER)\n    internal abstract fun pagedListSuperSortFilter(filter: String): DataSource.Factory<Int, FollowedShowEntryWithShow>\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_LAST_WATCHED)\n    internal abstract fun pagedListLastWatched(): DataSource.Factory<Int, FollowedShowEntryWithShow>\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_LAST_WATCHED_FILTER)\n    internal abstract fun pagedListLastWatchedFilter(filter: String): DataSource.Factory<Int, FollowedShowEntryWithShow>\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_ALPHA)\n    internal abstract fun pagedListAlpha(): DataSource.Factory<Int, FollowedShowEntryWithShow>\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_ALPHA_FILTER)\n    internal abstract fun pagedListAlphaFilter(filter: String): DataSource.Factory<Int, FollowedShowEntryWithShow>\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_ADDED)\n    internal abstract fun pagedListAdded(): DataSource.Factory<Int, FollowedShowEntryWithShow>\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_ADDED_FILTER)\n    internal abstract fun pagedListAddedFilter(filter: String): DataSource.Factory<Int, FollowedShowEntryWithShow>\n\n    @Query(\"\"\"\n        SELECT myshows_entries.* FROM myshows_entries\n            INNER JOIN seasons AS s ON s.show_id = myshows_entries.show_id\n\t\t\tINNER JOIN followed_next_to_watch AS next ON next.id = myshows_entries.id\n\t\t\tINNER JOIN episodes AS eps ON eps.season_id = s.id\n            INNER JOIN episode_watch_entries AS ew ON ew.episode_id = eps.id\n            WHERE s.number != ${Season.NUMBER_SPECIALS} AND s.ignored = 0\n\t\t\tORDER BY datetime(ew.watched_at) DESC\n\t\t\tLIMIT 1\n    \"\"\")\n    abstract fun observeNextShowToWatch(): Flow<FollowedShowEntryWithShow?>\n\n    @Query(\"DELETE FROM myshows_entries\")\n    abstract override suspend fun deleteAll()\n\n    @Transaction\n    @Query(\"SELECT * FROM myshows_entries WHERE id = :id\")\n    abstract suspend fun entryWithId(id: Long): FollowedShowEntryWithShow?\n\n    @Query(\"SELECT * FROM myshows_entries WHERE show_id = :showId\")\n    abstract suspend fun entryWithShowId(showId: Long): FollowedShowEntry?\n\n    @Query(\"SELECT COUNT(*) FROM myshows_entries WHERE show_id = :showId AND pending_action != 'delete'\")\n    abstract fun entryCountWithShowIdNotPendingDeleteObservable(showId: Long): Flow<Int>\n\n    @Query(\"SELECT COUNT(*) FROM myshows_entries WHERE show_id = :showId\")\n    abstract suspend fun entryCountWithShowId(showId: Long): Int\n\n    @Query(\"\"\"\n        SELECT stats.* FROM FollowedShowsWatchStats as stats\n        INNER JOIN myshows_entries ON stats.id = myshows_entries.id\n        WHERE show_id = :showId\n    \"\"\")\n    abstract fun entryShowViewStats(showId: Long): Flow<FollowedShowsWatchStats>\n\n    suspend fun entriesWithNoPendingAction() = entriesWithPendingAction(PendingAction.NOTHING.value)\n\n    suspend fun entriesWithSendPendingActions() = entriesWithPendingAction(PendingAction.UPLOAD.value)\n\n    suspend fun entriesWithDeletePendingActions() = entriesWithPendingAction(PendingAction.DELETE.value)\n\n    @Query(\"SELECT * FROM myshows_entries WHERE pending_action = :pendingAction\")\n    internal abstract suspend fun entriesWithPendingAction(pendingAction: String): List<FollowedShowEntry>\n\n    @Query(\"UPDATE myshows_entries SET pending_action = :pendingAction WHERE id IN (:ids)\")\n    abstract suspend fun updateEntriesToPendingAction(ids: List<Long>, pendingAction: String): Int\n\n    @Query(\"DELETE FROM myshows_entries WHERE id IN (:ids)\")\n    abstract suspend fun deleteWithIds(ids: List<Long>): Int\n\n    companion object {\n        private const val ENTRY_QUERY_SUPER_SORT = \"\"\"\n            SELECT fs.* FROM myshows_entries as fs\n            INNER JOIN seasons AS s ON fs.show_id = s.show_id\n            INNER JOIN episodes AS eps ON eps.season_id = s.id\n            LEFT JOIN episode_watch_entries as ew ON ew.episode_id = eps.id\n            LEFT JOIN followed_next_to_watch as nw ON nw.id = fs.id\n            WHERE s.number != ${Season.NUMBER_SPECIALS}\n                AND s.ignored = 0\n            GROUP BY fs.id\n            ORDER BY\n                /* shows with aired episodes to watch first */\n                SUM(CASE WHEN datetime(first_aired) < datetime('now') THEN 1 ELSE 0 END) = COUNT(watched_at) ASC,\n                /* latest event */\n                MAX(\n                    MAX(datetime(coalesce(next_ep_to_watch_air_date, 0))), /* next episode to watch */\n                    MAX(datetime(coalesce(watched_at, 0))), /* last watch */\n                    MAX(datetime(coalesce(followed_at, 0))) /* when followed */\n                ) DESC\n        \"\"\"\n\n        private const val ENTRY_QUERY_SUPER_SORT_FILTER = \"\"\"\n            SELECT fs.* FROM myshows_entries as fs\n            INNER JOIN shows_fts AS s_fts ON fs.show_id = s_fts.docid\n            INNER JOIN seasons AS s ON fs.show_id = s.show_id\n            INNER JOIN episodes AS eps ON eps.season_id = s.id\n            LEFT JOIN episode_watch_entries as ew ON ew.episode_id = eps.id\n            LEFT JOIN followed_next_to_watch as nw ON nw.id = fs.id\n            WHERE s.number != ${Season.NUMBER_SPECIALS}\n                AND s.ignored = 0\n                AND s_fts.title MATCH :filter\n            GROUP BY fs.id\n            ORDER BY\n                /* shows with aired episodes to watch first */\n                SUM(CASE WHEN datetime(first_aired) < datetime('now') THEN 1 ELSE 0 END) = COUNT(watched_at) ASC,\n                /* latest event */\n                MAX(\n                    MAX(datetime(coalesce(next_ep_to_watch_air_date, 0))), /* next episode to watch */\n                    MAX(datetime(coalesce(watched_at, 0))), /* last watch */\n                    MAX(datetime(coalesce(followed_at, 0))) /* when followed */\n                ) DESC\n        \"\"\"\n\n        private const val ENTRY_QUERY_ORDER_LAST_WATCHED = \"\"\"\n            SELECT fs.* FROM myshows_entries as fs\n            INNER JOIN seasons AS s ON fs.show_id = s.show_id\n            INNER JOIN episodes AS eps ON eps.season_id = s.id\n            LEFT JOIN episode_watch_entries as ew ON ew.episode_id = eps.id\n            GROUP BY fs.id\n            ORDER BY MAX(datetime(ew.watched_at)) DESC\n        \"\"\"\n\n        private const val ENTRY_QUERY_ORDER_LAST_WATCHED_FILTER = \"\"\"\n            SELECT fs.* FROM myshows_entries as fs\n            INNER JOIN shows_fts AS s_fts ON fs.show_id = s_fts.docid\n            INNER JOIN seasons AS s ON fs.show_id = s.show_id\n            INNER JOIN episodes AS eps ON eps.season_id = s.id\n            LEFT JOIN episode_watch_entries as ew ON ew.episode_id = eps.id\n            WHERE s_fts.title MATCH :filter\n            GROUP BY fs.id\n            ORDER BY MAX(datetime(ew.watched_at)) DESC\n        \"\"\"\n\n        private const val ENTRY_QUERY_ORDER_ALPHA = \"\"\"\n            SELECT fs.* FROM myshows_entries as fs\n            INNER JOIN shows_fts AS s_fts ON fs.show_id = s_fts.docid\n            ORDER BY title ASC\n        \"\"\"\n\n        private const val ENTRY_QUERY_ORDER_ALPHA_FILTER = \"\"\"\n            SELECT fs.* FROM myshows_entries as fs\n            INNER JOIN shows_fts AS s_fts ON fs.show_id = s_fts.docid\n            WHERE s_fts.title MATCH :filter\n            ORDER BY title ASC\n        \"\"\"\n\n        private const val ENTRY_QUERY_ORDER_ADDED = \"\"\"\n            SELECT * FROM myshows_entries\n            ORDER BY datetime(followed_at) DESC\n        \"\"\"\n\n        private const val ENTRY_QUERY_ORDER_ADDED_FILTER = \"\"\"\n            SELECT fs.* FROM myshows_entries as fs\n            INNER JOIN shows_fts AS s_fts ON fs.show_id = s_fts.docid\n            WHERE s_fts.title MATCH :filter\n            ORDER BY datetime(followed_at) DESC\n        \"\"\"\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.paging.DataSource\nimport androidx.room.Dao\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport app.tivi.data.entities.PopularShowEntry\nimport app.tivi.data.resultentities.PopularEntryWithShow\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class PopularDao : PaginatedEntryDao<PopularShowEntry, PopularEntryWithShow>() {\n    @Transaction\n    @Query(\"SELECT * FROM popular_shows WHERE page = :page ORDER BY page_order\")\n    abstract fun entriesObservable(page: Int): Flow<List<PopularShowEntry>>\n\n    @Transaction\n    @Query(\"SELECT * FROM popular_shows ORDER BY page, page_order\")\n    abstract fun entriesObservable(): Flow<List<PopularEntryWithShow>>\n\n    @Transaction\n    @Query(\"SELECT * FROM popular_shows ORDER BY page, page_order\")\n    abstract fun entriesDataSource(): DataSource.Factory<Int, PopularEntryWithShow>\n\n    @Query(\"DELETE FROM popular_shows WHERE page = :page\")\n    abstract override suspend fun deletePage(page: Int)\n\n    @Query(\"DELETE FROM popular_shows\")\n    abstract override suspend fun deleteAll()\n\n    @Query(\"SELECT MAX(page) from popular_shows\")\n    abstract override suspend fun getLastPage(): Int?\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Dao\nimport androidx.room.Query\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.repositories.shows.mergeShows\nimport app.tivi.data.resultentities.ShowDetailed\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class TiviShowDao : EntityDao<TiviShow>() {\n    @Query(\"SELECT * FROM shows WHERE trakt_id = :id\")\n    abstract suspend fun getShowWithTraktId(id: Int): TiviShow?\n\n    @Query(\"SELECT * FROM shows WHERE id IN (:ids)\")\n    abstract fun getShowsWithIds(ids: List<Long>): Flow<List<TiviShow>>\n\n    @Query(\"SELECT * FROM shows WHERE tmdb_id = :id\")\n    abstract suspend fun getShowWithTmdbId(id: Int): TiviShow?\n\n    @Query(\"SELECT * FROM shows WHERE id = :id\")\n    abstract fun getShowWithIdFlow(id: Long): Flow<TiviShow>\n\n    @Query(\"SELECT * FROM shows WHERE id = :id\")\n    abstract suspend fun getShowWithIdDetailed(id: Long): ShowDetailed?\n\n    @Query(\"SELECT * FROM shows WHERE id = :id\")\n    abstract fun getShowDetailedWithIdFlow(id: Long): Flow<ShowDetailed>\n\n    @Query(\"SELECT * FROM shows WHERE id = :id\")\n    abstract suspend fun getShowWithId(id: Long): TiviShow?\n\n    @Query(\"SELECT trakt_id FROM shows WHERE id = :id\")\n    abstract suspend fun getTraktIdForShowId(id: Long): Int?\n\n    @Query(\"SELECT tmdb_id FROM shows WHERE id = :id\")\n    abstract suspend fun getTmdbIdForShowId(id: Long): Int?\n\n    @Query(\"SELECT id FROM shows WHERE trakt_id = :traktId\")\n    abstract suspend fun getIdForTraktId(traktId: Int): Long?\n\n    @Query(\"SELECT id FROM shows WHERE tmdb_id = :tmdbId\")\n    abstract suspend fun getIdForTmdbId(tmdbId: Int): Long?\n\n    @Query(\"DELETE FROM shows WHERE id = :id\")\n    abstract suspend fun delete(id: Long)\n\n    @Query(\"DELETE FROM shows\")\n    abstract suspend fun deleteAll()\n\n    suspend fun getIdOrSavePlaceholder(show: TiviShow): Long {\n        val idForTraktId: Long? = if (show.traktId != null) getIdForTraktId(show.traktId) else null\n        val idForTmdbId: Long? = if (show.tmdbId != null) getIdForTmdbId(show.tmdbId) else null\n\n        if (idForTraktId != null && idForTmdbId != null) {\n            return if (idForTmdbId == idForTraktId) {\n                // Great, the entities are matching\n                idForTraktId\n            } else {\n                val showForTmdbId = getShowWithId(idForTmdbId)!!\n                val showForTraktId = getShowWithId(idForTraktId)!!\n                deleteEntity(showForTmdbId)\n                return insertOrUpdate(mergeShows(showForTraktId, showForTraktId, showForTmdbId))\n            }\n        }\n\n        if (idForTraktId != null) {\n            // If we get here, we only have a entity with the trakt id\n            return idForTraktId\n        }\n        if (idForTmdbId != null) {\n            // If we get here, we only have a entity with the tmdb id\n            return idForTmdbId\n        }\n\n        // TODO add fuzzy search on name or slug\n\n        return insert(show)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Delete\nimport androidx.room.Insert\nimport androidx.room.Transaction\nimport androidx.room.Update\nimport app.tivi.data.entities.TiviEntity\n\nabstract class EntityDao<in E : TiviEntity> {\n    @Insert\n    abstract suspend fun insert(entity: E): Long\n\n    @Insert\n    abstract suspend fun insertAll(vararg entity: E)\n\n    @Insert\n    abstract suspend fun insertAll(entities: List<E>)\n\n    @Update\n    abstract suspend fun update(entity: E)\n\n    @Delete\n    abstract suspend fun deleteEntity(entity: E): Int\n\n    @Transaction\n    open suspend fun withTransaction(tx: suspend () -> Unit) = tx()\n\n    suspend fun insertOrUpdate(entity: E): Long {\n        return if (entity.id == 0L) {\n            insert(entity)\n        } else {\n            update(entity)\n            entity.id\n        }\n    }\n\n    @Transaction\n    open suspend fun insertOrUpdate(entities: List<E>) {\n        entities.forEach {\n            insertOrUpdate(it)\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.paging.DataSource\nimport androidx.room.Dao\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport app.tivi.data.entities.RecommendedShowEntry\nimport app.tivi.data.resultentities.RecommendedEntryWithShow\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class RecommendedDao : PaginatedEntryDao<RecommendedShowEntry, RecommendedEntryWithShow>() {\n    @Query(\"SELECT * FROM recommended_entries WHERE page = :page ORDER BY id ASC\")\n    abstract fun entriesForPage(page: Int): Flow<List<RecommendedShowEntry>>\n\n    @Transaction\n    @Query(\"SELECT * FROM recommended_entries ORDER BY page ASC, id ASC LIMIT :count OFFSET :offset\")\n    abstract fun entriesObservable(count: Int, offset: Int): Flow<List<RecommendedEntryWithShow>>\n\n    @Transaction\n    @Query(\"SELECT * FROM recommended_entries ORDER BY page ASC, id ASC\")\n    abstract fun entriesDataSource(): DataSource.Factory<Int, RecommendedEntryWithShow>\n\n    @Query(\"DELETE FROM recommended_entries WHERE page = :page\")\n    abstract override suspend fun deletePage(page: Int)\n\n    @Query(\"DELETE FROM recommended_entries\")\n    abstract override suspend fun deleteAll()\n\n    @Query(\"SELECT MAX(page) from recommended_entries\")\n    abstract override suspend fun getLastPage(): Int?\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Dao\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport app.tivi.data.entities.ShowTmdbImage\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class ShowImagesDao : EntityDao<ShowTmdbImage>() {\n    @Query(\"DELETE FROM show_images WHERE show_id = :showId\")\n    abstract suspend fun deleteForShowId(showId: Long)\n\n    @Query(\"SELECT COUNT(*) FROM show_images WHERE show_id = :showId\")\n    abstract suspend fun imageCountForShowId(showId: Long): Int\n\n    @Query(\"SELECT * FROM show_images WHERE show_id = :showId\")\n    abstract fun getImagesForShowId(showId: Long): Flow<List<ShowTmdbImage>>\n\n    @Query(\"DELETE FROM show_images\")\n    abstract suspend fun deleteAll()\n\n    @Transaction\n    open suspend fun saveImages(showId: Long, images: List<ShowTmdbImage>) {\n        deleteForShowId(showId)\n        insertOrUpdate(images)\n    }\n\n    @Transaction\n    open suspend fun saveImagesIfEmpty(showId: Long, images: List<ShowTmdbImage>) {\n        if (imageCountForShowId(showId) <= 0) {\n            insertAll(images)\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Dao\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport app.tivi.data.entities.Season\nimport app.tivi.data.entities.Season.Companion.NUMBER_SPECIALS\nimport app.tivi.data.resultentities.SeasonWithEpisodesAndWatches\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class SeasonsDao : EntityDao<Season>() {\n    @Transaction\n    @Query(\"SELECT * FROM seasons WHERE show_id = :showId ORDER BY number=$NUMBER_SPECIALS, number\")\n    abstract fun seasonsWithEpisodesForShowId(showId: Long): Flow<List<SeasonWithEpisodesAndWatches>>\n\n    @Query(\"SELECT * FROM seasons WHERE show_id = :showId ORDER BY number=$NUMBER_SPECIALS, number\")\n    abstract suspend fun seasonsForShowId(showId: Long): List<Season>\n\n    @Query(\"DELETE FROM seasons WHERE show_id = :showId\")\n    abstract suspend fun deleteWithShowId(showId: Long)\n\n    @Query(\"DELETE FROM seasons WHERE show_id = :showId\")\n    abstract suspend fun deleteSeasonsForShowId(showId: Long): Int\n\n    @Query(\"SELECT * FROM seasons WHERE id = :id\")\n    abstract suspend fun seasonWithId(id: Long): Season?\n\n    @Query(\"SELECT trakt_id FROM seasons WHERE id = :id\")\n    abstract suspend fun traktIdForId(id: Long): Int?\n\n    @Query(\"SELECT * FROM seasons WHERE trakt_id = :traktId\")\n    abstract suspend fun seasonWithTraktId(traktId: Int): Season?\n\n    @Query(\"\"\"\n        SELECT id from seasons WHERE \n          show_id = (SELECT show_id from SEASONS WHERE id = :seasonId)\n          AND number != $NUMBER_SPECIALS\n          AND number < (SELECT number from SEASONS WHERE id = :seasonId)\n    \"\"\")\n    abstract suspend fun showPreviousSeasonIds(seasonId: Long): LongArray\n\n    @Query(\"UPDATE seasons SET ignored = :ignored WHERE id = :seasonId\")\n    abstract suspend fun updateSeasonIgnoreFlag(seasonId: Long, ignored: Boolean)\n\n    @Query(\"SELECT * FROM seasons WHERE show_id = :showId AND number = :number\")\n    abstract suspend fun seasonWithShowIdAndNumber(showId: Long, number: Int): Season?\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport app.tivi.data.entities.TraktUser\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class UserDao : EntityDao<TraktUser>() {\n    @Query(\"SELECT * FROM users WHERE is_me != 0\")\n    abstract fun observeMe(): Flow<TraktUser>\n\n    @Query(\"SELECT * FROM users WHERE username = :username\")\n    abstract fun observeTraktUser(username: String): Flow<TraktUser>\n\n    @Query(\"SELECT * FROM users WHERE username = :username\")\n    abstract suspend fun getTraktUser(username: String): TraktUser?\n\n    @Query(\"SELECT * FROM users WHERE is_me != 0\")\n    abstract suspend fun getMe(): TraktUser?\n\n    @Query(\"SELECT id FROM users WHERE username = :username\")\n    abstract suspend fun getIdForUsername(username: String): Long?\n\n    @Query(\"SELECT id FROM users WHERE is_me != 0\")\n    abstract suspend fun getIdForMe(): Long?\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    abstract override suspend fun insert(entity: TraktUser): Long\n\n    @Query(\"DELETE FROM users\")\n    abstract suspend fun deleteAll()\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.paging.DataSource\nimport androidx.room.Dao\nimport androidx.room.Query\nimport app.tivi.data.entities.TrendingShowEntry\nimport app.tivi.data.resultentities.TrendingEntryWithShow\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class TrendingDao : PaginatedEntryDao<TrendingShowEntry, TrendingEntryWithShow>() {\n    @Query(\"SELECT * FROM trending_shows WHERE page = :page ORDER BY watchers DESC, id ASC\")\n    abstract fun entriesObservable(page: Int): Flow<List<TrendingShowEntry>>\n\n    @Query(\"SELECT * FROM trending_shows ORDER BY page ASC, watchers DESC, id ASC LIMIT :count OFFSET :offset\")\n    abstract fun entriesObservable(count: Int, offset: Int): Flow<List<TrendingEntryWithShow>>\n\n    @Query(\"SELECT * FROM trending_shows ORDER BY page ASC, watchers DESC, id ASC\")\n    abstract fun entriesDataSource(): DataSource.Factory<Int, TrendingEntryWithShow>\n\n    @Query(\"DELETE FROM trending_shows WHERE page = :page\")\n    abstract override suspend fun deletePage(page: Int)\n\n    @Query(\"DELETE FROM trending_shows\")\n    abstract override suspend fun deleteAll()\n\n    @Query(\"SELECT MAX(page) from trending_shows\")\n    abstract override suspend fun getLastPage(): Int?\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport app.tivi.data.Entry\nimport app.tivi.data.resultentities.EntryWithShow\n\n/**\n * This interface represents a DAO which contains entities which are part of a single collective list.\n */\nabstract class EntryDao<EC : Entry, LI : EntryWithShow<EC>> : EntityDao<EC>() {\n    abstract suspend fun deleteAll()\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Dao\nimport androidx.room.Query\nimport app.tivi.data.resultentities.ShowDetailed\n\n@Dao\nabstract class ShowFtsDao {\n    @Query(\"\"\"\n        SELECT s.* FROM shows as s\n        INNER JOIN shows_fts AS fts ON s.id = fts.docid\n        WHERE fts.title MATCH :filter\n        \"\"\"\n    )\n    abstract suspend fun search(filter: String): List<ShowDetailed>\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport app.tivi.data.MultipleEntry\nimport app.tivi.data.resultentities.EntryWithShow\nimport kotlinx.coroutines.flow.Flow\n\n/**\n * This interface represents a DAO which contains entities which are part of a collective list for a given show.\n */\nabstract class PairEntryDao<EC : MultipleEntry, LI : EntryWithShow<EC>> : EntityDao<EC>() {\n    abstract fun entries(showId: Long): List<EC>\n    abstract fun entriesWithShows(showId: Long): List<LI>\n    abstract fun entriesWithShowsObservable(showId: Long): Flow<List<LI>>\n    abstract suspend fun deleteWithShowId(showId: Long)\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Transaction\nimport app.tivi.data.PaginatedEntry\nimport app.tivi.data.resultentities.EntryWithShow\n\nabstract class PaginatedEntryDao<EC : PaginatedEntry, LI : EntryWithShow<EC>> : EntryDao<EC, LI>() {\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    abstract override suspend fun insert(entity: EC): Long\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    abstract override suspend fun insertAll(vararg entity: EC)\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    abstract override suspend fun insertAll(entities: List<EC>)\n\n    abstract suspend fun deletePage(page: Int)\n    abstract suspend fun getLastPage(): Int?\n\n    @Transaction\n    open suspend fun updatePage(page: Int, entities: List<EC>) {\n        deletePage(page)\n        insertAll(entities)\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.paging.DataSource\nimport androidx.room.Dao\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.entities.WatchedShowEntry\nimport app.tivi.data.resultentities.WatchedShowEntryWithShow\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class WatchedShowDao : EntryDao<WatchedShowEntry, WatchedShowEntryWithShow>() {\n    @Transaction\n    @Query(\"SELECT * FROM watched_entries WHERE show_id = :showId\")\n    abstract suspend fun entryWithShowId(showId: Long): WatchedShowEntry?\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_LAST_WATCHED)\n    abstract suspend fun entries(): List<WatchedShowEntry>\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_LAST_WATCHED)\n    abstract fun entriesObservable(): Flow<List<WatchedShowEntry>>\n\n    fun observePagedList(\n        filter: String?,\n        sort: SortOption\n    ): DataSource.Factory<Int, WatchedShowEntryWithShow> {\n        val filtered = filter != null && filter.isNotEmpty()\n        return when (sort) {\n            SortOption.LAST_WATCHED -> {\n                if (filtered) {\n                    pagedListLastWatchedFilter(\"*$filter*\")\n                } else {\n                    pagedListLastWatched()\n                }\n            }\n            SortOption.ALPHABETICAL -> {\n                if (filtered) {\n                    pagedListAlphaFilter(\"*$filter*\")\n                } else {\n                    pagedListAlpha()\n                }\n            }\n            else -> throw IllegalArgumentException(\"$sort option is not supported\")\n        }\n    }\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_LAST_WATCHED)\n    protected abstract fun pagedListLastWatched(): DataSource.Factory<Int, WatchedShowEntryWithShow>\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_LAST_WATCHED_FILTER)\n    protected abstract fun pagedListLastWatchedFilter(filter: String): DataSource.Factory<Int, WatchedShowEntryWithShow>\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_ALPHA)\n    protected abstract fun pagedListAlpha(): DataSource.Factory<Int, WatchedShowEntryWithShow>\n\n    @Transaction\n    @Query(ENTRY_QUERY_ORDER_ALPHA_FILTER)\n    protected abstract fun pagedListAlphaFilter(filter: String): DataSource.Factory<Int, WatchedShowEntryWithShow>\n\n    @Query(\"DELETE FROM watched_entries\")\n    abstract override suspend fun deleteAll()\n\n    companion object {\n        private const val ENTRY_QUERY_ORDER_LAST_WATCHED = \"\"\"\n            SELECT we.* FROM watched_entries as we\n            ORDER BY datetime(last_watched) DESC\n        \"\"\"\n\n        private const val ENTRY_QUERY_ORDER_LAST_WATCHED_FILTER = \"\"\"\n            SELECT we.* FROM watched_entries as we\n            INNER JOIN shows_fts AS fts ON we.show_id = fts.docid\n            WHERE fts.title MATCH :filter\n            ORDER BY datetime(last_watched) DESC\n        \"\"\"\n\n        private const val ENTRY_QUERY_ORDER_ALPHA = \"\"\"\n            SELECT we.* FROM watched_entries as we\n            INNER JOIN shows_fts AS fts ON we.show_id = fts.docid\n            ORDER BY title ASC\n        \"\"\"\n\n        private const val ENTRY_QUERY_ORDER_ALPHA_FILTER = \"\"\"\n            SELECT we.* FROM watched_entries as we\n            INNER JOIN shows_fts AS fts ON we.show_id = fts.docid\n            WHERE title MATCH :filter\n            ORDER BY title ASC\n        \"\"\"\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport app.tivi.data.entities.LastRequest\nimport app.tivi.data.entities.Request\n\n@Dao\nabstract class LastRequestDao : EntityDao<LastRequest>() {\n    @Query(\"SELECT * FROM last_requests WHERE request = :request AND entity_id = :entityId\")\n    abstract suspend fun lastRequest(request: Request, entityId: Long): LastRequest?\n\n    @Query(\"SELECT COUNT(*) FROM last_requests WHERE request = :request AND entity_id = :entityId\")\n    abstract suspend fun requestCount(request: Request, entityId: Long): Int\n\n    @Transaction\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    abstract override suspend fun insert(entity: LastRequest): Long\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Dao\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport app.tivi.data.entities.RelatedShowEntry\nimport app.tivi.data.resultentities.RelatedShowEntryWithShow\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class RelatedShowsDao : PairEntryDao<RelatedShowEntry, RelatedShowEntryWithShow>() {\n    @Transaction\n    @Query(\"SELECT * FROM related_shows WHERE show_id = :showId ORDER BY order_index\")\n    abstract override fun entries(showId: Long): List<RelatedShowEntry>\n\n    @Transaction\n    @Query(\"SELECT * FROM related_shows WHERE show_id = :showId ORDER BY order_index\")\n    abstract fun entriesObservable(showId: Long): Flow<List<RelatedShowEntry>>\n\n    @Transaction\n    @Query(\"SELECT * FROM related_shows WHERE show_id = :showId ORDER BY order_index\")\n    abstract override fun entriesWithShows(showId: Long): List<RelatedShowEntryWithShow>\n\n    @Transaction\n    @Query(\"SELECT * FROM related_shows WHERE show_id = :showId ORDER BY order_index\")\n    abstract override fun entriesWithShowsObservable(showId: Long): Flow<List<RelatedShowEntryWithShow>>\n\n    @Query(\"DELETE FROM related_shows WHERE show_id = :showId\")\n    abstract override suspend fun deleteWithShowId(showId: Long)\n\n    @Query(\"DELETE FROM related_shows\")\n    abstract suspend fun deleteAll()\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.daos\n\nimport androidx.room.Dao\nimport androidx.room.Query\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport app.tivi.data.resultentities.EpisodeWithSeason\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class EpisodesDao : EntityDao<Episode>() {\n    @Query(\"SELECT * from episodes WHERE season_id = :seasonId ORDER BY number\")\n    abstract suspend fun episodesWithSeasonId(seasonId: Long): List<Episode>\n\n    @Query(\"DELETE FROM episodes WHERE season_id = :seasonId\")\n    abstract suspend fun deleteWithSeasonId(seasonId: Long)\n\n    @Query(\"SELECT * from episodes WHERE trakt_id = :traktId\")\n    abstract suspend fun episodeWithTraktId(traktId: Int): Episode?\n\n    @Query(\"SELECT * from episodes WHERE tmdb_id = :tmdbId\")\n    abstract suspend fun episodeWithTmdbId(tmdbId: Int): Episode?\n\n    @Query(\"SELECT * from episodes WHERE id = :id\")\n    abstract suspend fun episodeWithId(id: Long): Episode?\n\n    @Query(\"SELECT trakt_id from episodes WHERE id = :id\")\n    abstract suspend fun episodeTraktIdForId(id: Long): Int?\n\n    @Query(\"SELECT id from episodes WHERE trakt_id = :traktId\")\n    abstract suspend fun episodeIdWithTraktId(traktId: Int): Long?\n\n    @Query(\"SELECT * from episodes WHERE id = :id\")\n    abstract fun episodeWithIdObservable(id: Long): Flow<EpisodeWithSeason>\n\n    @Query(\"SELECT shows.id FROM shows\" +\n        \" INNER JOIN seasons AS s ON s.show_id = shows.id\" +\n        \" INNER JOIN episodes AS eps ON eps.season_id = s.id\" +\n        \" WHERE eps.id = :episodeId\")\n    abstract suspend fun showIdForEpisodeId(episodeId: Long): Long\n\n    @Query(latestWatchedEpisodeForShowId)\n    abstract fun observeLatestWatchedEpisodeForShowId(showId: Long): Flow<EpisodeWithSeason?>\n\n    @Query(nextEpisodeForShowIdAfter)\n    abstract fun observeNextEpisodeForShowAfter(\n        showId: Long,\n        seasonNumber: Int,\n        episodeNumber: Int\n    ): Flow<EpisodeWithSeason?>\n\n    @Query(nextAiredEpisodeForShowIdAfter)\n    abstract fun observeNextAiredEpisodeForShowAfter(\n        showId: Long,\n        seasonNumber: Int,\n        episodeNumber: Int\n    ): Flow<EpisodeWithSeason?>\n\n    companion object {\n        const val latestWatchedEpisodeForShowId = \"\"\"\n            SELECT eps.*, (100 * s.number) + eps.number AS computed_abs_number\n            FROM shows\n            INNER JOIN seasons AS s ON shows.id = s.show_id\n            INNER JOIN episodes AS eps ON eps.season_id = s.id\n            INNER JOIN episode_watch_entries AS ew ON ew.episode_id = eps.id\n            WHERE s.number != ${Season.NUMBER_SPECIALS}\n                AND s.ignored = 0\n                AND shows.id = :showId\n            ORDER BY computed_abs_number DESC\n            LIMIT 1\n            \"\"\"\n\n        const val nextEpisodeForShowIdAfter = \"\"\"\n            SELECT eps.*, (1000 * s.number) + eps.number AS computed_abs_number\n            FROM shows\n            INNER JOIN seasons AS s ON shows.id = s.show_id\n            INNER JOIN episodes AS eps ON eps.season_id = s.id\n            WHERE s.number != ${Season.NUMBER_SPECIALS}\n                AND s.ignored = 0\n                AND shows.id = :showId\n                AND computed_abs_number > ((1000 * :seasonNumber) + :episodeNumber)\n            ORDER BY computed_abs_number ASC\n            LIMIT 1\n        \"\"\"\n\n        const val nextAiredEpisodeForShowIdAfter = \"\"\"\n            SELECT eps.*, (1000 * s.number) + eps.number AS computed_abs_number\n            FROM shows\n            INNER JOIN seasons AS s ON shows.id = s.show_id\n            INNER JOIN episodes AS eps ON eps.season_id = s.id\n            WHERE s.number != ${Season.NUMBER_SPECIALS}\n                AND s.ignored = 0\n                AND shows.id = :showId\n                AND computed_abs_number > ((1000 * :seasonNumber) + :episodeNumber)\n                AND eps.first_aired IS NOT NULL\n                AND datetime(eps.first_aired) < datetime('now')\n            ORDER BY computed_abs_number ASC\n            LIMIT 1\n        \"\"\"\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Relation\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.entities.TrendingShowEntry\nimport java.util.Objects\n\nclass TrendingEntryWithShow : EntryWithShow<TrendingShowEntry> {\n    @Embedded\n    override lateinit var entry: TrendingShowEntry\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"id\")\n    override var relations: List<TiviShow> = emptyList()\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"show_id\")\n    override var images: List<ShowTmdbImage> = emptyList()\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is TrendingEntryWithShow -> {\n            entry == other.entry && relations == other.relations && images == other.images\n        }\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(entry, relations, images)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Relation\nimport app.tivi.data.entities.Season\nimport app.tivi.data.entities.TiviShow\nimport java.util.Objects\n\nclass SeasonWithShow {\n    @Embedded\n    lateinit var season: Season\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"id\")\n    var _shows: List<TiviShow> = emptyList()\n\n    val show: TiviShow\n        get() {\n            assert(_shows.size == 1)\n            return _shows[0]\n        }\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is SeasonWithShow -> season == other.season && _shows == other._shows\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(season, _shows)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Relation\nimport app.tivi.data.entities.PopularShowEntry\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport java.util.Objects\n\nclass PopularEntryWithShow : EntryWithShow<PopularShowEntry> {\n    @Embedded\n    override lateinit var entry: PopularShowEntry\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"id\")\n    override var relations: List<TiviShow> = emptyList()\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"show_id\")\n    override var images: List<ShowTmdbImage> = emptyList()\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is PopularEntryWithShow -> {\n            entry == other.entry && relations == other.relations && images == other.images\n        }\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(entry, relations, images)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Ignore\nimport androidx.room.Relation\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport java.util.Objects\n\nclass SeasonWithEpisodesAndWatches {\n    @Embedded\n    lateinit var season: Season\n\n    @Relation(parentColumn = \"id\", entityColumn = \"season_id\", entity = Episode::class)\n    var episodes: List<EpisodeWithWatches> = emptyList()\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is SeasonWithEpisodesAndWatches -> season == other.season && episodes == other.episodes\n        else -> false\n    }\n\n    @delegate:Ignore\n    val numberAiredToWatch by lazy(LazyThreadSafetyMode.NONE) {\n        episodes.count { !it.isWatched() && it.episode?.isAired() == true }\n    }\n\n    @delegate:Ignore\n    val numberWatched by lazy(LazyThreadSafetyMode.NONE) {\n        episodes.count { it.isWatched() }\n    }\n\n    @delegate:Ignore\n    val numberToAir by lazy(LazyThreadSafetyMode.NONE) {\n        numberEpisodes - numberAired\n    }\n\n    @delegate:Ignore\n    val numberAired by lazy(LazyThreadSafetyMode.NONE) {\n        episodes.count { it.episode?.isAired() == true }\n    }\n\n    @delegate:Ignore\n    val numberEpisodes by lazy(LazyThreadSafetyMode.NONE) {\n        episodes.size\n    }\n\n    @delegate:Ignore\n    val nextToAir by lazy(LazyThreadSafetyMode.NONE) {\n        episodes.firstOrNull {\n            val ep = it.episode!!\n            !ep.isAired() && ep.firstAired != null\n        }?.let { it.episode }\n    }\n\n    override fun hashCode(): Int = Objects.hash(season, episodes)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Relation\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport java.util.Objects\n\nclass SeasonWithEpisodes {\n    @Embedded\n    var season: Season? = null\n\n    @Relation(parentColumn = \"id\", entityColumn = \"season_id\")\n    var episodes: List<Episode> = emptyList()\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is SeasonWithEpisodes -> season == other.season && episodes == other.episodes\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(season, episodes)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Ignore\nimport androidx.room.Relation\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.entities.findHighestRatedBackdrop\nimport app.tivi.data.entities.findHighestRatedPoster\nimport java.util.Objects\n\nclass ShowDetailed {\n    @Embedded\n    var show: TiviShow = TiviShow.EMPTY_SHOW\n\n    @Relation(parentColumn = \"id\", entityColumn = \"show_id\")\n    var images: List<ShowTmdbImage> = emptyList()\n\n    @get:Ignore\n    val backdrop: ShowTmdbImage?\n        get() = images.findHighestRatedBackdrop()\n\n    @get:Ignore\n    val poster: ShowTmdbImage?\n        get() = images.findHighestRatedPoster()\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is ShowDetailed -> show == other.show && images == other.images\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(show, images)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Relation\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.entities.WatchedShowEntry\nimport java.util.Objects\n\nclass WatchedShowEntryWithShow : EntryWithShow<WatchedShowEntry> {\n    @Embedded\n    override lateinit var entry: WatchedShowEntry\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"id\")\n    override var relations: List<TiviShow> = emptyList()\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"show_id\")\n    override var images: List<ShowTmdbImage> = emptyList()\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is WatchedShowEntryWithShow -> {\n            entry == other.entry && relations == other.relations && images == other.images\n        }\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(entry, relations, images)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Relation\nimport app.tivi.data.entities.RelatedShowEntry\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport java.util.Objects\n\nclass RelatedShowEntryWithShow : EntryWithShow<RelatedShowEntry> {\n    @Embedded\n    override lateinit var entry: RelatedShowEntry\n\n    @Relation(parentColumn = \"other_show_id\", entityColumn = \"id\")\n    override var relations: List<TiviShow> = emptyList()\n\n    @Relation(parentColumn = \"other_show_id\", entityColumn = \"show_id\")\n    override var images: List<ShowTmdbImage> = emptyList()\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is RelatedShowEntryWithShow -> {\n            entry == other.entry && relations == other.relations && images == other.images\n        }\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(entry, relations, images)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Relation\nimport app.tivi.data.entities.RecommendedShowEntry\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport java.util.Objects\n\nclass RecommendedEntryWithShow : EntryWithShow<RecommendedShowEntry> {\n    @Embedded\n    override lateinit var entry: RecommendedShowEntry\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"id\")\n    override var relations: List<TiviShow> = emptyList()\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"show_id\")\n    override var images: List<ShowTmdbImage> = emptyList()\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is RecommendedEntryWithShow -> {\n            entry == other.entry && relations == other.relations && images == other.images\n        }\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(entry, relations, images)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.entities.TmdbImageEntity\n\ndata class EpisodeWithSeasonWithShow(\n    val episode: Episode,\n    val season: Season,\n    val show: TiviShow,\n    val images: List<TmdbImageEntity>\n)",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Relation\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.Season\nimport java.util.Objects\n\nclass EpisodeWithSeason {\n    @Embedded\n    var episode: Episode? = null\n\n    @Relation(parentColumn = \"season_id\", entityColumn = \"id\")\n    var _seasons: List<Season> = emptyList()\n\n    val season: Season?\n        get() = _seasons.getOrNull(0)\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is EpisodeWithSeason -> episode == other.episode && _seasons == other._seasons\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(episode, _seasons)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Relation\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.entities.PendingAction\nimport java.util.Objects\nimport org.threeten.bp.OffsetDateTime\n\nclass EpisodeWithWatches {\n    @Embedded\n    var episode: Episode? = null\n\n    @Relation(parentColumn = \"id\", entityColumn = \"episode_id\")\n    var watches: List<EpisodeWatchEntry> = emptyList()\n\n    fun hasWatches() = watches.isNotEmpty()\n\n    fun isWatched() = watches.any {\n        it.pendingAction != PendingAction.DELETE\n    }\n\n    fun hasPending() = watches.any {\n        it.pendingAction != PendingAction.NOTHING\n    }\n\n    fun onlyPendingDeletes() = watches.all {\n        it.pendingAction == PendingAction.DELETE\n    }\n\n    fun hasAired(): Boolean {\n        val aired = episode?.firstAired\n        return aired != null && aired.isBefore(OffsetDateTime.now())\n    }\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is EpisodeWithWatches -> watches == other.watches && episode == other.episode\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(episode, watches)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport androidx.room.Embedded\nimport androidx.room.Relation\nimport app.tivi.data.entities.FollowedShowEntry\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.views.FollowedShowsWatchStats\nimport java.util.Objects\n\nclass FollowedShowEntryWithShow : EntryWithShow<FollowedShowEntry> {\n    @Embedded\n    override lateinit var entry: FollowedShowEntry\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"id\")\n    override var relations: List<TiviShow> = emptyList()\n\n    @Relation(parentColumn = \"show_id\", entityColumn = \"show_id\")\n    override var images: List<ShowTmdbImage> = emptyList()\n\n    @Relation(parentColumn = \"id\", entityColumn = \"id\")\n    var _stats: List<FollowedShowsWatchStats> = emptyList()\n\n    val stats: FollowedShowsWatchStats?\n        get() = _stats.getOrNull(0)\n\n    override fun equals(other: Any?): Boolean = when {\n        other === this -> true\n        other is FollowedShowEntryWithShow -> {\n            entry == other.entry && relations == other.relations && stats == other.stats && images == other.images\n        }\n        else -> false\n    }\n\n    override fun hashCode(): Int = Objects.hash(entry, relations, stats, images)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.resultentities\n\nimport app.tivi.data.Entry\nimport app.tivi.data.entities.ShowTmdbImage\nimport app.tivi.data.entities.TiviShow\nimport java.util.Objects\n\ninterface EntryWithShow<ET : Entry> {\n    var entry: ET\n    var relations: List<TiviShow>\n    var images: List<ShowTmdbImage>\n\n    val show: TiviShow\n        get() {\n            assert(relations.size == 1)\n            return relations[0]\n        }\n\n    fun generateStableId(): Long {\n        return Objects.hash(entry::class.java.name, entry.showId).toLong()\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain\n\nimport androidx.paging.PagedList\nimport app.tivi.base.InvokeError\nimport app.tivi.base.InvokeIdle\nimport app.tivi.base.InvokeStarted\nimport app.tivi.base.InvokeStatus\nimport app.tivi.base.InvokeSuccess\nimport app.tivi.base.InvokeTimeout\nimport java.util.concurrent.TimeUnit\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.TimeoutCancellationException\nimport kotlinx.coroutines.channels.ConflatedBroadcastChannel\nimport kotlinx.coroutines.channels.sendBlocking\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.asFlow\nimport kotlinx.coroutines.flow.distinctUntilChanged\nimport kotlinx.coroutines.flow.flatMapLatest\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport kotlinx.coroutines.withTimeout\n\nabstract class Interactor<in P> {\n    protected abstract val scope: CoroutineScope\n\n    operator fun invoke(params: P, timeoutMs: Long = defaultTimeoutMs): Flow<InvokeStatus> {\n        val channel = ConflatedBroadcastChannel<InvokeStatus>(InvokeIdle)\n        scope.launch {\n            try {\n                withTimeout(timeoutMs) {\n                    channel.send(InvokeStarted)\n                    try {\n                        doWork(params)\n                        channel.send(InvokeSuccess)\n                    } catch (t: Throwable) {\n                        channel.send(InvokeError(t))\n                    }\n                }\n            } catch (t: TimeoutCancellationException) {\n                channel.send(InvokeTimeout)\n            }\n        }\n        return channel.asFlow()\n    }\n\n    suspend fun executeSync(params: P) = withContext(scope.coroutineContext) { doWork(params) }\n\n    protected abstract suspend fun doWork(params: P)\n\n    companion object {\n        private val defaultTimeoutMs = TimeUnit.MINUTES.toMillis(5)\n    }\n}\n\nabstract class ResultInteractor<in P, R> {\n    abstract val dispatcher: CoroutineDispatcher\n\n    suspend operator fun invoke(params: P): R {\n        return withContext(dispatcher) { doWork(params) }\n    }\n\n    protected abstract suspend fun doWork(params: P): R\n}\n\ninterface ObservableInteractor<T> {\n    val dispatcher: CoroutineDispatcher\n    fun observe(): Flow<T>\n}\n\nabstract class PagingInteractor<P : PagingInteractor.Parameters<T>, T> : SubjectInteractor<P, PagedList<T>>() {\n    interface Parameters<T> {\n        val pagingConfig: PagedList.Config\n        val boundaryCallback: PagedList.BoundaryCallback<T>?\n    }\n}\n\nabstract class SuspendingWorkInteractor<P : Any, T : Any> : ObservableInteractor<T> {\n    private val channel = ConflatedBroadcastChannel<T>()\n\n    suspend operator fun invoke(params: P) = channel.send(doWork(params))\n\n    abstract suspend fun doWork(params: P): T\n\n    override fun observe(): Flow<T> = channel.asFlow()\n}\n\nabstract class SubjectInteractor<P : Any, T> : ObservableInteractor<T> {\n    private val channel = ConflatedBroadcastChannel<P>()\n\n    operator fun invoke(params: P) = channel.sendBlocking(params)\n\n    protected abstract fun createObservable(params: P): Flow<T>\n\n    override fun observe(): Flow<T> = channel.asFlow()\n        .distinctUntilChanged()\n        .flatMapLatest { createObservable(it) }\n}\n\noperator fun Interactor<Unit>.invoke() = invoke(Unit)\noperator fun <T> SubjectInteractor<Unit, T>.invoke() = invoke(Unit)\n\nfun <I : ObservableInteractor<T>, T> CoroutineScope.launchObserve(\n    interactor: I,\n    f: suspend (Flow<T>) -> Unit\n) {\n    launch(interactor.dispatcher) {\n        f(interactor.observe())\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.data.repositories.followedshows.FollowedShowsRepository\nimport app.tivi.domain.Interactor\nimport app.tivi.domain.interactors.UpdateShowSeasonData.Params\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass UpdateShowSeasonData @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    private val followedShowsRepository: FollowedShowsRepository,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        if (followedShowsRepository.isShowFollowed(params.showId)) {\n            // Then update the seasons/episodes\n            if (params.forceRefresh || seasonsEpisodesRepository.needShowSeasonsUpdate(params.showId)) {\n                seasonsEpisodesRepository.updateSeasonsEpisodes(params.showId)\n            }\n            // Finally update any watched progress\n            if (params.forceRefresh || seasonsEpisodesRepository.needShowEpisodeWatchesSync(params.showId)) {\n                seasonsEpisodesRepository.syncEpisodeWatchesForShow(params.showId)\n            }\n        } else {\n            seasonsEpisodesRepository.removeShowSeasonData(params.showId)\n        }\n    }\n\n    data class Params(val showId: Long, val forceRefresh: Boolean)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.domain.Interactor\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass RemoveEpisodeWatches @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<RemoveEpisodeWatches.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        seasonsEpisodesRepository.removeAllEpisodeWatches(params.episodeId)\n    }\n\n    data class Params(val episodeId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.domain.Interactor\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.tmdb.TmdbManager\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass UpdateTmdbConfig @Inject constructor(\n    private val tmdbManager: TmdbManager,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<Unit>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Unit) {\n        tmdbManager.refreshConfiguration()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.domain.Interactor\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass RemoveEpisodeWatch @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<RemoveEpisodeWatch.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        seasonsEpisodesRepository.removeEpisodeWatch(params.episodeWatchId)\n    }\n\n    data class Params(val episodeWatchId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.cachedOnly\nimport app.tivi.data.entities.RefreshType\nimport app.tivi.data.fetch\nimport app.tivi.data.fetchCollection\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.data.repositories.followedshows.FollowedShowsRepository\nimport app.tivi.data.repositories.showimages.ShowImagesStore\nimport app.tivi.data.repositories.shows.ShowStore\nimport app.tivi.domain.Interactor\nimport app.tivi.extensions.parallelForEach\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.coroutineScope\nimport kotlinx.coroutines.plus\n\nclass UpdateFollowedShows @Inject constructor(\n    private val followedShowsRepository: FollowedShowsRepository,\n    private val seasonEpisodeRepository: SeasonsEpisodesRepository,\n    private val showStore: ShowStore,\n    private val showImagesStore: ShowImagesStore,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<UpdateFollowedShows.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) = coroutineScope {\n        if (params.forceRefresh || followedShowsRepository.needFollowedShowsSync()) {\n            followedShowsRepository.syncFollowedShows()\n        }\n\n        // Finally sync the seasons/episodes and watches\n        followedShowsRepository.getFollowedShows().parallelForEach {\n            showStore.fetch(it.showId)\n            showImagesStore.fetchCollection(it.showId)\n\n            // Download the seasons + episodes\n            if (params.forceRefresh || seasonEpisodeRepository.needShowSeasonsUpdate(it.showId)) {\n                seasonEpisodeRepository.updateSeasonsEpisodes(it.showId)\n            }\n\n            seasonEpisodeRepository.updateShowEpisodeWatches(\n                it.showId,\n                params.type,\n                params.forceRefresh,\n                showStore.cachedOnly(it.showId)?.traktDataUpdate\n            )\n        }\n    }\n\n    data class Params(val forceRefresh: Boolean, val type: RefreshType)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.repositories.traktusers.TraktUsersRepository\nimport app.tivi.domain.Interactor\nimport app.tivi.domain.interactors.UpdateUserDetails.Params\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass UpdateUserDetails @Inject constructor(\n    private val repository: TraktUsersRepository,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        if (params.forceLoad || repository.needUpdate(params.username)) {\n            repository.updateUser(params.username)\n        }\n    }\n\n    data class Params(val username: String, val forceLoad: Boolean)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.domain.Interactor\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\nimport org.threeten.bp.OffsetDateTime\n\nclass AddEpisodeWatch @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<AddEpisodeWatch.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        seasonsEpisodesRepository.addEpisodeWatch(params.episodeId, params.timestamp)\n    }\n\n    data class Params(val episodeId: Long, val timestamp: OffsetDateTime)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.fetch\nimport app.tivi.data.repositories.shows.ShowLastRequestStore\nimport app.tivi.data.repositories.shows.ShowStore\nimport app.tivi.domain.Interactor\nimport app.tivi.domain.interactors.UpdateShowDetails.Params\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\nimport org.threeten.bp.Period\n\nclass UpdateShowDetails @Inject constructor(\n    private val showStore: ShowStore,\n    private val lastRequestStore: ShowLastRequestStore,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        showStore.fetch(params.showId, params.forceLoad) {\n            // Refresh if our cached data is over 14 days old\n            lastRequestStore.isRequestExpired(params.showId, Period.ofDays(14))\n        }\n    }\n\n    data class Params(val showId: Long, val forceLoad: Boolean)\n}",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.fetchCollection\nimport app.tivi.data.repositories.showimages.ShowImagesLastRequestStore\nimport app.tivi.data.repositories.showimages.ShowImagesStore\nimport app.tivi.domain.Interactor\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\nimport org.threeten.bp.Period\n\nclass UpdateShowImages @Inject constructor(\n    private val showImagesStore: ShowImagesStore,\n    private val lastRequestStore: ShowImagesLastRequestStore,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<UpdateShowImages.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        showImagesStore.fetchCollection(params.showId, params.forceLoad) {\n            // Refresh if our local data is over 30 days old\n            lastRequestStore.isRequestExpired(params.showId, Period.ofDays(30))\n        }\n    }\n\n    data class Params(val showId: Long, val forceLoad: Boolean)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.entities.Episode\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.domain.ResultInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\n\nclass GetEpisodeDetails @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    private val dispatchers: AppCoroutineDispatchers\n) : ResultInteractor<GetEpisodeDetails.Params, Episode?>() {\n    override val dispatcher: CoroutineDispatcher\n        get() = dispatchers.io\n\n    override suspend fun doWork(params: Params): Episode? {\n        return seasonsEpisodesRepository.getEpisode(params.episodeId)\n    }\n\n    data class Params(val episodeId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.fetch\nimport app.tivi.data.fetchCollection\nimport app.tivi.data.repositories.recommendedshows.RecommendedShowsLastRequestStore\nimport app.tivi.data.repositories.recommendedshows.RecommendedShowsStore\nimport app.tivi.data.repositories.showimages.ShowImagesStore\nimport app.tivi.data.repositories.shows.ShowStore\nimport app.tivi.domain.Interactor\nimport app.tivi.extensions.parallelForEach\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.trakt.TraktAuthState\nimport app.tivi.trakt.TraktManager\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.plus\nimport org.threeten.bp.Duration\n\nclass UpdateRecommendedShows @Inject constructor(\n    private val recommendedShowsStore: RecommendedShowsStore,\n    private val lastRequestStore: RecommendedShowsLastRequestStore,\n    private val showsStore: ShowStore,\n    private val showImagesStore: ShowImagesStore,\n    dispatchers: AppCoroutineDispatchers,\n    private val traktManager: TraktManager,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<UpdateRecommendedShows.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        if (traktManager.state.first() != TraktAuthState.LOGGED_IN) {\n            // If we're not logged in, we can't load the recommended shows\n            return\n        }\n\n        // Recommended fetcher does not support paging\n        recommendedShowsStore.fetchCollection(0, forceFresh = params.forceRefresh) {\n            // Refresh if our local data is over 3 hours old\n            lastRequestStore.isRequestExpired(Duration.ofHours(3))\n        }.parallelForEach {\n            showsStore.fetch(it.showId)\n            showImagesStore.fetchCollection(it.showId)\n        }\n    }\n\n    data class Params(val page: Page, val forceRefresh: Boolean)\n\n    enum class Page {\n        NEXT_PAGE, REFRESH\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.fetch\nimport app.tivi.data.fetchCollection\nimport app.tivi.data.repositories.relatedshows.RelatedShowsLastRequestStore\nimport app.tivi.data.repositories.relatedshows.RelatedShowsStore\nimport app.tivi.data.repositories.showimages.ShowImagesStore\nimport app.tivi.data.repositories.shows.ShowStore\nimport app.tivi.domain.Interactor\nimport app.tivi.domain.interactors.UpdateRelatedShows.Params\nimport app.tivi.extensions.parallelForEach\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\nimport org.threeten.bp.Period\n\nclass UpdateRelatedShows @Inject constructor(\n    private val relatedShowsStore: RelatedShowsStore,\n    private val lastRequestStore: RelatedShowsLastRequestStore,\n    private val showsStore: ShowStore,\n    private val showImagesStore: ShowImagesStore,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        relatedShowsStore.fetchCollection(params.showId, forceFresh = params.forceLoad) {\n            // Refresh if our local data is over 28 days old\n            lastRequestStore.isRequestExpired(params.showId, Period.ofDays(28))\n        }.parallelForEach {\n            showsStore.fetch(it.showId)\n            showImagesStore.fetchCollection(it.showId)\n        }\n    }\n\n    data class Params(val showId: Long, val forceLoad: Boolean)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.domain.Interactor\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass ChangeSeasonFollowStatus @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<ChangeSeasonFollowStatus.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) = when (params.action) {\n        Action.FOLLOW -> {\n            seasonsEpisodesRepository.markSeasonFollowed(params.seasonId)\n        }\n        Action.IGNORE -> {\n            seasonsEpisodesRepository.markSeasonIgnored(params.seasonId)\n        }\n        Action.IGNORE_PREVIOUS -> {\n            seasonsEpisodesRepository.markPreviousSeasonsIgnored(params.seasonId)\n        }\n    }\n\n    data class Params(\n        val seasonId: Long,\n        val action: Action\n    )\n\n    enum class Action { FOLLOW, IGNORE, IGNORE_PREVIOUS }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.daos.TrendingDao\nimport app.tivi.data.fetch\nimport app.tivi.data.fetchCollection\nimport app.tivi.data.repositories.showimages.ShowImagesStore\nimport app.tivi.data.repositories.shows.ShowStore\nimport app.tivi.data.repositories.trendingshows.TrendingShowsLastRequestStore\nimport app.tivi.data.repositories.trendingshows.TrendingShowsStore\nimport app.tivi.domain.Interactor\nimport app.tivi.domain.interactors.UpdateTrendingShows.Params\nimport app.tivi.extensions.parallelForEach\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\nimport org.threeten.bp.Duration\n\nclass UpdateTrendingShows @Inject constructor(\n    private val trendingShowsStore: TrendingShowsStore,\n    private val trendingShowsDao: TrendingDao,\n    private val lastRequestStore: TrendingShowsLastRequestStore,\n    private val showsStore: ShowStore,\n    private val showImagesStore: ShowImagesStore,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        val lastPage = trendingShowsDao.getLastPage()\n        val page = when {\n            lastPage != null && params.page == Page.NEXT_PAGE -> lastPage + 1\n            else -> 0\n        }\n\n        trendingShowsStore.fetchCollection(page, forceFresh = params.forceRefresh) {\n            // Refresh if our local data is over 3 hours old\n            page == 0 && lastRequestStore.isRequestExpired(Duration.ofHours(3))\n        }.parallelForEach {\n            showsStore.fetch(it.showId)\n            showImagesStore.fetchCollection(it.showId)\n        }\n    }\n\n    data class Params(val page: Page, val forceRefresh: Boolean)\n\n    enum class Page {\n        NEXT_PAGE, REFRESH\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.daos.ShowFtsDao\nimport app.tivi.data.entities.SearchResults\nimport app.tivi.data.repositories.search.SearchRepository\nimport app.tivi.domain.SuspendingWorkInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\n\nclass SearchShows @Inject constructor(\n    private val searchRepository: SearchRepository,\n    private val showFtsDao: ShowFtsDao,\n    dispatchers: AppCoroutineDispatchers\n) : SuspendingWorkInteractor<SearchShows.Params, SearchResults>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override suspend fun doWork(params: Params): SearchResults {\n        val remoteResults = searchRepository.search(params.query)\n        return when {\n            remoteResults.isNotEmpty() -> SearchResults(params.query, remoteResults)\n            else -> SearchResults(params.query, when {\n                params.query.isNotBlank() -> showFtsDao.search(\"*$params.query*\")\n                else -> emptyList()\n            })\n        }\n    }\n\n    data class Params(val query: String)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.daos.PopularDao\nimport app.tivi.data.fetch\nimport app.tivi.data.fetchCollection\nimport app.tivi.data.repositories.popularshows.PopularShowsLastRequestStore\nimport app.tivi.data.repositories.popularshows.PopularShowsStore\nimport app.tivi.data.repositories.showimages.ShowImagesStore\nimport app.tivi.data.repositories.shows.ShowStore\nimport app.tivi.domain.Interactor\nimport app.tivi.domain.interactors.UpdatePopularShows.Params\nimport app.tivi.extensions.parallelForEach\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\nimport org.threeten.bp.Period\n\nclass UpdatePopularShows @Inject constructor(\n    private val popularShowStore: PopularShowsStore,\n    private val popularDao: PopularDao,\n    private val lastRequestStore: PopularShowsLastRequestStore,\n    private val showsStore: ShowStore,\n    private val showImagesStore: ShowImagesStore,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        val lastPage = popularDao.getLastPage()\n        val page = when {\n            lastPage != null && params.page == Page.NEXT_PAGE -> lastPage + 1\n            else -> 0\n        }\n\n        popularShowStore.fetchCollection(page, forceFresh = params.forceRefresh) {\n            // Refresh if our local data is over 7 days old\n            page == 0 && lastRequestStore.isRequestExpired(Period.ofDays(7))\n        }.parallelForEach {\n            showsStore.fetch(it.showId)\n            showImagesStore.fetchCollection(it.showId)\n        }\n    }\n\n    data class Params(val page: Page, val forceRefresh: Boolean)\n\n    enum class Page {\n        NEXT_PAGE, REFRESH\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.domain.Interactor\nimport app.tivi.domain.interactors.UpdateShowSeasons.Params\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass UpdateShowSeasons @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        seasonsEpisodesRepository.updateSeasonsEpisodes(params.showId)\n    }\n\n    data class Params(val showId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.fetch\nimport app.tivi.data.fetchCollection\nimport app.tivi.data.repositories.showimages.ShowImagesStore\nimport app.tivi.data.repositories.shows.ShowStore\nimport app.tivi.data.repositories.watchedshows.WatchedShowsLastRequestStore\nimport app.tivi.data.repositories.watchedshows.WatchedShowsStore\nimport app.tivi.domain.Interactor\nimport app.tivi.extensions.parallelForEach\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\nimport org.threeten.bp.Duration\n\nclass UpdateWatchedShows @Inject constructor(\n    private val watchedShowsStore: WatchedShowsStore,\n    private val showsStore: ShowStore,\n    private val showImagesStore: ShowImagesStore,\n    private val lastRequestStore: WatchedShowsLastRequestStore,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<UpdateWatchedShows.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        watchedShowsStore.fetchCollection(Unit, forceFresh = params.forceRefresh) {\n            // Refresh if our local data is over 12 hours old\n            lastRequestStore.isRequestExpired(Duration.ofHours(12))\n        }.parallelForEach {\n            showsStore.fetch(it.showId)\n            showImagesStore.fetchCollection(it.showId)\n        }\n    }\n\n    data class Params(val forceRefresh: Boolean)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.domain.Interactor\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass UpdateEpisodeDetails @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<UpdateEpisodeDetails.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        seasonsEpisodesRepository.updateEpisode(params.episodeId)\n    }\n\n    data class Params(val episodeId: Long, val forceLoad: Boolean)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.domain.Interactor\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport java.io.File\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass DeleteFolder @Inject constructor(\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<DeleteFolder.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        if (params.directory.exists()) {\n            params.directory.deleteRecursively()\n        }\n    }\n\n    data class Params(val directory: File)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.data.entities.ActionDate\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.domain.Interactor\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass ChangeSeasonWatchedStatus @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    dispatchers: AppCoroutineDispatchers,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<ChangeSeasonWatchedStatus.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) = when (params.action) {\n        Action.WATCHED -> {\n            seasonsEpisodesRepository.markSeasonWatched(\n                params.seasonId,\n                params.onlyAired,\n                params.actionDate\n            )\n        }\n        Action.UNWATCH -> {\n            seasonsEpisodesRepository.markSeasonUnwatched(params.seasonId)\n        }\n    }\n\n    data class Params(\n        val seasonId: Long,\n        val action: Action,\n        val onlyAired: Boolean = true,\n        val actionDate: ActionDate = ActionDate.NOW\n    )\n\n    enum class Action { WATCHED, UNWATCH }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.interactors\n\nimport app.tivi.actions.ShowTasks\nimport app.tivi.data.fetch\nimport app.tivi.data.fetchCollection\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.data.repositories.followedshows.FollowedShowsRepository\nimport app.tivi.data.repositories.showimages.ShowImagesStore\nimport app.tivi.data.repositories.shows.ShowStore\nimport app.tivi.domain.Interactor\nimport app.tivi.inject.ProcessLifetime\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.plus\n\nclass ChangeShowFollowStatus @Inject constructor(\n    private val followedShowsRepository: FollowedShowsRepository,\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    private val showStore: ShowStore,\n    private val showImagesStore: ShowImagesStore,\n    dispatchers: AppCoroutineDispatchers,\n    private val showTasks: ShowTasks,\n    @ProcessLifetime val processScope: CoroutineScope\n) : Interactor<ChangeShowFollowStatus.Params>() {\n    override val scope: CoroutineScope = processScope + dispatchers.io\n\n    override suspend fun doWork(params: Params) {\n        suspend fun unfollow(showId: Long) {\n            followedShowsRepository.removeFollowedShow(showId)\n            // Remove seasons, episodes and watches\n            seasonsEpisodesRepository.removeShowSeasonData(showId)\n        }\n\n        suspend fun follow(showId: Long) {\n            followedShowsRepository.addFollowedShow(showId)\n            // Update seasons, episodes and watches\n            if (!params.deferDataFetch) {\n                seasonsEpisodesRepository.updateSeasonsEpisodes(showId)\n                seasonsEpisodesRepository.updateShowEpisodeWatches(showId, forceRefresh = true)\n            }\n        }\n\n        for (showId in params.showIds) {\n            when (params.action) {\n                Action.TOGGLE -> {\n                    if (followedShowsRepository.isShowFollowed(showId)) {\n                        unfollow(showId)\n                    } else {\n                        follow(showId)\n                    }\n                }\n                Action.FOLLOW -> follow(showId)\n                Action.UNFOLLOW -> unfollow(showId)\n            }\n        }\n        // Finally, sync the changes to Trakt\n        val result = followedShowsRepository.syncFollowedShows()\n\n        result.added.forEach {\n            showStore.fetch(it.showId)\n            showImagesStore.fetchCollection(it.showId)\n        }\n\n        if (params.deferDataFetch) {\n            showTasks.syncFollowedShows()\n        }\n    }\n\n    data class Params(\n        val showIds: Collection<Long>,\n        val action: Action,\n        val deferDataFetch: Boolean = false\n    ) {\n        constructor(showId: Long, action: Action) : this(listOf(showId), action)\n    }\n\n    enum class Action { FOLLOW, UNFOLLOW, TOGGLE }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.repositories.followedshows.FollowedShowsRepository\nimport app.tivi.data.views.FollowedShowsWatchStats\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveShowViewStats @Inject constructor(\n    private val repository: FollowedShowsRepository,\n    dispatchers: AppCoroutineDispatchers\n) : SubjectInteractor<ObserveShowViewStats.Params, FollowedShowsWatchStats>() {\n    override val dispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<FollowedShowsWatchStats> {\n        return repository.observeShowViewStats(params.showId)\n    }\n\n    data class Params(val showId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.entities.EpisodeWatchEntry\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveEpisodeWatches @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    private val dispatchers: AppCoroutineDispatchers\n) : SubjectInteractor<ObserveEpisodeWatches.Params, List<EpisodeWatchEntry>>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<List<EpisodeWatchEntry>> {\n        return seasonsEpisodesRepository.observeEpisodeWatches(params.episodeId)\n    }\n\n    data class Params(val episodeId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.daos.RecommendedDao\nimport app.tivi.data.resultentities.RecommendedEntryWithShow\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveRecommendedShows @Inject constructor(\n    private val dispatchers: AppCoroutineDispatchers,\n    private val recommendedDao: RecommendedDao\n) : SubjectInteractor<Unit, List<RecommendedEntryWithShow>>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Unit): Flow<List<RecommendedEntryWithShow>> {\n        return recommendedDao.entriesObservable(20, 0)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.data.resultentities.EpisodeWithSeason\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveShowNextEpisodeToWatch @Inject constructor(\n    private val repository: SeasonsEpisodesRepository,\n    dispatchers: AppCoroutineDispatchers\n) : SubjectInteractor<ObserveShowNextEpisodeToWatch.Params, EpisodeWithSeason?>() {\n    override val dispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<EpisodeWithSeason?> {\n        return repository.observeNextEpisodeToWatch(params.showId)\n    }\n\n    data class Params(val showId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.repositories.followedshows.FollowedShowsRepository\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveShowFollowStatus @Inject constructor(\n    private val dispatchers: AppCoroutineDispatchers,\n    private val followedShowsRepository: FollowedShowsRepository\n) : SubjectInteractor<ObserveShowFollowStatus.Params, Boolean>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<Boolean> {\n        return followedShowsRepository.observeIsShowFollowed(params.showId)\n    }\n\n    data class Params(val showId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.data.resultentities.SeasonWithEpisodesAndWatches\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveShowSeasons @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    private val dispatchers: AppCoroutineDispatchers\n) : SubjectInteractor<ObserveShowSeasons.Params, List<SeasonWithEpisodesAndWatches>>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<List<SeasonWithEpisodesAndWatches>> {\n        return seasonsEpisodesRepository.observeSeasonsForShow(params.showId)\n    }\n\n    data class Params(val showId: Long, val forceLoad: Boolean)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.daos.TrendingDao\nimport app.tivi.data.resultentities.TrendingEntryWithShow\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveTrendingShows @Inject constructor(\n    private val dispatchers: AppCoroutineDispatchers,\n    private val trendingShowsDao: TrendingDao\n) : SubjectInteractor<ObserveTrendingShows.Params, List<TrendingEntryWithShow>>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<List<TrendingEntryWithShow>> {\n        return trendingShowsDao.entriesObservable(params.count, 0)\n    }\n\n    data class Params(val count: Int = 20)\n}",
        "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.entities.ShowImages\nimport app.tivi.data.repositories.showimages.ShowImagesStore\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport com.dropbox.android.external.store4.StoreRequest\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map\n\nclass ObserveShowImages @Inject constructor(\n    private val store: ShowImagesStore,\n    dispatchers: AppCoroutineDispatchers\n) : SubjectInteractor<ObserveShowImages.Params, ShowImages>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<ShowImages> {\n        return store.stream(StoreRequest.cached(params.showId, refresh = false))\n            .map { ShowImages(it.requireData()) }\n    }\n\n    data class Params(val showId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.trakt.TraktAuthState\nimport app.tivi.trakt.TraktManager\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveTraktAuthState @Inject constructor(\n    dispatchers: AppCoroutineDispatchers,\n    private val traktManager: TraktManager\n) : SubjectInteractor<Unit, TraktAuthState>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.main\n\n    override fun createObservable(params: Unit): Flow<TraktAuthState> {\n        return traktManager.state\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport androidx.paging.PagedList\nimport app.tivi.data.FlowPagedListBuilder\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.repositories.followedshows.FollowedShowsRepository\nimport app.tivi.data.resultentities.FollowedShowEntryWithShow\nimport app.tivi.domain.PagingInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObservePagedFollowedShows @Inject constructor(\n    dispatchers: AppCoroutineDispatchers,\n    private val followedShowsRepository: FollowedShowsRepository\n) : PagingInteractor<ObservePagedFollowedShows.Parameters, FollowedShowEntryWithShow>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Parameters): Flow<PagedList<FollowedShowEntryWithShow>> {\n        return FlowPagedListBuilder(\n            followedShowsRepository.observeFollowedShows(params.sort, params.filter),\n            params.pagingConfig,\n            boundaryCallback = params.boundaryCallback\n        ).buildFlow()\n    }\n\n    data class Parameters(\n        val filter: String? = null,\n        val sort: SortOption,\n        override val pagingConfig: PagedList.Config,\n        override val boundaryCallback: PagedList.BoundaryCallback<FollowedShowEntryWithShow>? = null\n    ) : PagingInteractor.Parameters<FollowedShowEntryWithShow>\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.data.resultentities.EpisodeWithSeason\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveEpisodeDetails @Inject constructor(\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    private val dispatchers: AppCoroutineDispatchers\n) : SubjectInteractor<ObserveEpisodeDetails.Params, EpisodeWithSeason>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<EpisodeWithSeason> {\n        return seasonsEpisodesRepository.observeEpisode(params.episodeId)\n    }\n\n    data class Params(val episodeId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport androidx.paging.PagedList\nimport app.tivi.data.FlowPagedListBuilder\nimport app.tivi.data.daos.RecommendedDao\nimport app.tivi.data.resultentities.RecommendedEntryWithShow\nimport app.tivi.domain.PagingInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObservePagedRecommendedShows @Inject constructor(\n    dispatchers: AppCoroutineDispatchers,\n    private val recommendedDao: RecommendedDao\n) : PagingInteractor<ObservePagedRecommendedShows.Params, RecommendedEntryWithShow>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<PagedList<RecommendedEntryWithShow>> {\n        return FlowPagedListBuilder(\n            recommendedDao.entriesDataSource(),\n            params.pagingConfig,\n            boundaryCallback = params.boundaryCallback\n        ).buildFlow()\n    }\n\n    data class Params(\n        override val pagingConfig: PagedList.Config,\n        override val boundaryCallback: PagedList.BoundaryCallback<RecommendedEntryWithShow>?\n    ) : Parameters<RecommendedEntryWithShow>\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.data.repositories.followedshows.FollowedShowsRepository\nimport app.tivi.data.resultentities.EpisodeWithSeasonWithShow\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.extensions.flatMapLatestNullable\nimport app.tivi.extensions.mapNullable\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveNextShowEpisodeToWatch @Inject constructor(\n    private val followedShowsRepository: FollowedShowsRepository,\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository,\n    dispatchers: AppCoroutineDispatchers\n) : SubjectInteractor<Unit, EpisodeWithSeasonWithShow?>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Unit): Flow<EpisodeWithSeasonWithShow?> {\n        return followedShowsRepository.observeNextShowToWatch().flatMapLatestNullable { nextShow ->\n            seasonsEpisodesRepository.observeNextEpisodeToWatch(nextShow.entry.showId).mapNullable {\n                EpisodeWithSeasonWithShow(it.episode!!, it.season!!, nextShow.show, nextShow.images)\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport androidx.paging.PagedList\nimport app.tivi.data.FlowPagedListBuilder\nimport app.tivi.data.daos.WatchedShowDao\nimport app.tivi.data.entities.SortOption\nimport app.tivi.data.resultentities.WatchedShowEntryWithShow\nimport app.tivi.domain.PagingInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObservePagedWatchedShows @Inject constructor(\n    dispatchers: AppCoroutineDispatchers,\n    private val watchedShowDao: WatchedShowDao\n) : PagingInteractor<ObservePagedWatchedShows.Params, WatchedShowEntryWithShow>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<PagedList<WatchedShowEntryWithShow>> {\n        return FlowPagedListBuilder(\n            watchedShowDao.observePagedList(params.filter, params.sort),\n            params.pagingConfig,\n            boundaryCallback = params.boundaryCallback\n        ).buildFlow()\n    }\n\n    data class Params(\n        val filter: String? = null,\n        val sort: SortOption,\n        override val pagingConfig: PagedList.Config,\n        override val boundaryCallback: PagedList.BoundaryCallback<WatchedShowEntryWithShow>?\n    ) : Parameters<WatchedShowEntryWithShow>\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.repositories.episodes.SeasonsEpisodesRepository\nimport app.tivi.data.resultentities.SeasonWithEpisodesAndWatches\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveShowSeasonData @Inject constructor(\n    private val dispatchers: AppCoroutineDispatchers,\n    private val seasonsEpisodesRepository: SeasonsEpisodesRepository\n) : SubjectInteractor<ObserveShowSeasonData.Params, List<SeasonWithEpisodesAndWatches>>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<List<SeasonWithEpisodesAndWatches>> {\n        return seasonsEpisodesRepository.observeSeasonsForShow(params.showId)\n    }\n\n    data class Params(val showId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport androidx.paging.PagedList\nimport app.tivi.data.FlowPagedListBuilder\nimport app.tivi.data.daos.PopularDao\nimport app.tivi.data.resultentities.PopularEntryWithShow\nimport app.tivi.domain.PagingInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObservePagedPopularShows @Inject constructor(\n    dispatchers: AppCoroutineDispatchers,\n    private val popularDao: PopularDao\n) : PagingInteractor<ObservePagedPopularShows.Params, PopularEntryWithShow>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<PagedList<PopularEntryWithShow>> {\n        return FlowPagedListBuilder(\n            popularDao.entriesDataSource(),\n            params.pagingConfig,\n            boundaryCallback = params.boundaryCallback\n        ).buildFlow()\n    }\n\n    data class Params(\n        override val pagingConfig: PagedList.Config,\n        override val boundaryCallback: PagedList.BoundaryCallback<PopularEntryWithShow>?\n    ) : Parameters<PopularEntryWithShow>\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport androidx.paging.PagedList\nimport app.tivi.data.FlowPagedListBuilder\nimport app.tivi.data.daos.TrendingDao\nimport app.tivi.data.resultentities.TrendingEntryWithShow\nimport app.tivi.domain.PagingInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObservePagedTrendingShows @Inject constructor(\n    dispatchers: AppCoroutineDispatchers,\n    private val trendingShowsDao: TrendingDao\n) : PagingInteractor<ObservePagedTrendingShows.Params, TrendingEntryWithShow>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<PagedList<TrendingEntryWithShow>> {\n        return FlowPagedListBuilder(\n            trendingShowsDao.entriesDataSource(),\n            params.pagingConfig,\n            boundaryCallback = params.boundaryCallback\n        ).buildFlow()\n    }\n\n    data class Params(\n        override val pagingConfig: PagedList.Config,\n        override val boundaryCallback: PagedList.BoundaryCallback<TrendingEntryWithShow>?\n    ) : Parameters<TrendingEntryWithShow>\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.entities.TraktUser\nimport app.tivi.data.repositories.traktusers.TraktUsersRepository\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveUserDetails @Inject constructor(\n    private val dispatchers: AppCoroutineDispatchers,\n    private val repository: TraktUsersRepository\n) : SubjectInteractor<ObserveUserDetails.Params, TraktUser>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<TraktUser> {\n        return repository.observeUser(params.username)\n    }\n\n    data class Params(val username: String)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.daos.PopularDao\nimport app.tivi.data.resultentities.PopularEntryWithShow\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObservePopularShows @Inject constructor(\n    private val dispatchers: AppCoroutineDispatchers,\n    private val popularShowsRepository: PopularDao\n) : SubjectInteractor<Unit, List<PopularEntryWithShow>>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Unit): Flow<List<PopularEntryWithShow>> {\n        return popularShowsRepository.entriesObservable()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.repositories.shows.ShowStore\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport com.dropbox.android.external.store4.StoreRequest\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map\n\nclass ObserveShowDetails @Inject constructor(\n    private val showStore: ShowStore,\n    private val dispatchers: AppCoroutineDispatchers\n) : SubjectInteractor<ObserveShowDetails.Params, TiviShow>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<TiviShow> {\n        return showStore.stream(StoreRequest.cached(params.showId, refresh = false))\n            .map { it.requireData() }\n    }\n\n    data class Params(val showId: Long)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.domain.observers\n\nimport app.tivi.data.daos.RelatedShowsDao\nimport app.tivi.data.resultentities.RelatedShowEntryWithShow\nimport app.tivi.domain.SubjectInteractor\nimport app.tivi.util.AppCoroutineDispatchers\nimport javax.inject.Inject\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.Flow\n\nclass ObserveRelatedShows @Inject constructor(\n    private val dispatchers: AppCoroutineDispatchers,\n    private val relatedShowsDao: RelatedShowsDao\n) : SubjectInteractor<ObserveRelatedShows.Params, List<RelatedShowEntryWithShow>>() {\n    override val dispatcher: CoroutineDispatcher = dispatchers.io\n\n    override fun createObservable(params: Params): Flow<List<RelatedShowEntryWithShow>> {\n        return relatedShowsDao.entriesWithShowsObservable(params.showId)\n    }\n\n    data class Params(val showId: Long)\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport android.transition.ChangeBounds\nimport android.transition.TransitionManager\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.TextView\nimport androidx.interpolator.view.animation.FastOutSlowInInterpolator\nimport androidx.recyclerview.widget.RecyclerView\n\nclass MaxLinesToggleClickListener(private val collapsedLines: Int) : View.OnClickListener {\n    private val transition = ChangeBounds().apply {\n        duration = 200\n        interpolator = FastOutSlowInInterpolator()\n    }\n\n    override fun onClick(view: View) {\n        TransitionManager.beginDelayedTransition(findParent(view), transition)\n        val textView = view as TextView\n        textView.maxLines = if (textView.maxLines > collapsedLines) collapsedLines else Int.MAX_VALUE\n    }\n\n    private fun findParent(view: View): ViewGroup {\n        var parentView: View? = view\n        while (parentView != null) {\n            val parent = parentView.parent as View?\n            if (parent is RecyclerView) {\n                return parent\n            }\n            parentView = parent\n        }\n        // If we reached here we didn't find a RecyclerView in the parent tree, so lets just use our parent\n        return view.parent as ViewGroup\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.motionlayout\n\nimport androidx.constraintlayout.motion.widget.MotionLayout\n\nopen class TransitionListenerAdapter : MotionLayout.TransitionListener {\n    private var lastProgress = 0f\n\n    override fun onTransitionTrigger(\n        parent: MotionLayout,\n        triggerId: Int,\n        positive: Boolean,\n        progress: Float\n    ) {\n    }\n\n    override fun onTransitionStarted(\n        parent: MotionLayout,\n        startId: Int,\n        endId: Int\n    ) {\n        lastProgress = 0f\n    }\n\n    final override fun onTransitionChange(\n        parent: MotionLayout,\n        startId: Int,\n        endId: Int,\n        progress: Float\n    ) {\n        onTransitionChange(parent, startId, endId, progress, progress > lastProgress)\n        lastProgress = progress\n    }\n\n    open fun onTransitionChange(\n        parent: MotionLayout,\n        startId: Int,\n        endId: Int,\n        progress: Float,\n        positive: Boolean\n    ) = Unit\n\n    override fun onTransitionCompleted(\n        parent: MotionLayout,\n        currentId: Int\n    ) = Unit\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.motionlayout\n\nimport androidx.constraintlayout.motion.widget.MotionLayout\nimport com.google.android.material.floatingactionbutton.FloatingActionButton\n\nclass FabShowHideTransitionListener(\n    private val floatingActionButton: FloatingActionButton,\n    private val stateFabOpen: Int,\n    private val stateFabClosed: Int\n) : TransitionListenerAdapter() {\n    override fun onTransitionCompleted(parent: MotionLayout, currentId: Int) {\n        when (currentId) {\n            stateFabOpen -> {\n                if (!floatingActionButton.isOrWillBeShown) {\n                    floatingActionButton.show()\n                }\n            }\n            stateFabClosed -> {\n                if (!floatingActionButton.isOrWillBeHidden) {\n                    floatingActionButton.hide()\n                }\n            }\n        }\n    }\n\n    override fun onTransitionChange(\n        parent: MotionLayout,\n        startId: Int,\n        endId: Int,\n        progress: Float,\n        positive: Boolean\n    ) {\n        if (startId == stateFabOpen && endId == stateFabClosed) {\n            if (progress >= 0.53 && positive && !floatingActionButton.isOrWillBeHidden) {\n                floatingActionButton.hide()\n            } else if (progress <= 0.47 && !positive && !floatingActionButton.isOrWillBeShown) {\n                floatingActionButton.show()\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport android.view.View\nimport androidx.core.view.forEach\nimport androidx.recyclerview.widget.RecyclerView\nimport app.tivi.SharedElementHelper\nimport app.tivi.data.Entry\nimport app.tivi.data.resultentities.EntryWithShow\n\nfun RecyclerView.createSharedElementHelperForItem(\n    item: EntryWithShow<out Entry>,\n    transitionName: String,\n    viewFinder: (view: View) -> View = defaultViewFinder\n) = createSharedElementHelperForItemId(item.generateStableId(), transitionName, viewFinder)\n\nfun RecyclerView.createSharedElementHelperForItems(\n    items: List<EntryWithShow<out Entry>> = emptyList(),\n    viewFinder: (view: View) -> View = defaultViewFinder\n): SharedElementHelper {\n    val sharedElementHelper = SharedElementHelper()\n    items.forEach {\n        val homepage = it.show.homepage\n        if (homepage != null) {\n            sharedElementHelper.addSharedElementFromRecyclerView(this, it.generateStableId(), homepage, viewFinder)\n        }\n    }\n    return sharedElementHelper\n}\n\nfun RecyclerView.createSharedElementHelperForItemId(\n    viewHolderId: Long,\n    transitionName: String,\n    viewFinder: (view: View) -> View = defaultViewFinder\n) = SharedElementHelper().apply {\n    addSharedElementFromRecyclerView(this@createSharedElementHelperForItemId, viewHolderId, transitionName, viewFinder)\n}\n\nprivate fun SharedElementHelper.addSharedElementFromRecyclerView(\n    view: RecyclerView,\n    viewHolderId: Long,\n    transitionName: String,\n    viewFinder: (view: View) -> View\n): Boolean {\n    val itemFromParentRv = view.findViewHolderForItemId(viewHolderId)\n    if (itemFromParentRv != null) {\n        addSharedElement(viewFinder(itemFromParentRv.itemView), transitionName)\n        return true\n    }\n\n    // We also check any child RecyclerViews. This is mainly for things like Carousels\n    view.forEach { child ->\n        if (child is RecyclerView) {\n            val itemFromChildRv = child.findViewHolderForItemId(viewHolderId)\n            if (itemFromChildRv != null) {\n                addSharedElement(viewFinder(itemFromChildRv.itemView), transitionName)\n                return true\n            }\n        }\n    }\n\n    return false\n}\n\nprivate val defaultViewFinder: (View) -> View = { it }",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport android.view.View\nimport androidx.constraintlayout.motion.widget.MotionLayout\nimport androidx.core.view.NestedScrollingChild3\nimport androidx.core.view.NestedScrollingChildHelper\n\n/**\n * This is a extension class to [MotionLayout] which turns it into a [NestedScrollingChild3].\n * This enables you to use a MotionLayout as a child in a nested scrolling parent\n * (such as CoordinatorLayout).\n *\n * There are certain situations when this is very useful, such as when using a MotionLayout in a\n * BottomSheetDialog. BottomSheetDialog and friends use a CoordinatorLayout\n * internally, so we need to make sure that any nested scrolls reach that parent. MotionLayout\n * is not a [NestedScrollingChild3] itself, meaning that it _only_ consumes nested scrolls. This\n * means that any nested scrolls which happen deeper in the tree (i.e. a child RecyclerView) will\n * be consumed by the [MotionLayout] and not travel further up the tree, breaking the bottom sheet\n * behavior.\n *\n * This implementation is unfortunately not perfect, due the complicated nature of scrolling which\n * MotionLayout supports. A very rough implementation of [canScrollVertically] is provided, but\n * ideally this would be added directly to MotionLayout. The same would need to be done for\n * [canScrollHorizontally].\n */\nclass NestedChildMotionLayout @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : MotionLayout(context, attrs, defStyleAttr), NestedScrollingChild3 {\n    private val helper = NestedScrollingChildHelper(this)\n    private val tmpArray = IntArray(2)\n\n    init {\n        isNestedScrollingEnabled = true\n    }\n\n    /**\n     * NestedScrollingParent methods\n     */\n    override fun onStartNestedScroll(\n        child: View,\n        target: View,\n        axes: Int,\n        type: Int\n    ): Boolean {\n        val selfStarted = super.onStartNestedScroll(child, target, nestedScrollAxes, type)\n        val parentStarted = startNestedScroll(axes, type)\n        return parentStarted || selfStarted\n    }\n\n    override fun onNestedPreScroll(\n        target: View,\n        dx: Int,\n        dy: Int,\n        consumed: IntArray,\n        type: Int\n    ) {\n        // Dispatch up to our parent first. This gives the parent hierarchy the first attempt\n        // at nested scrolling the dx/dy\n        dispatchNestedPreScroll(dx, dy, consumed, null, type)\n\n        if (dx != consumed[0] || dy != consumed[1]) {\n            // If there is any dx/dy remaining, let MotionLayout handle it\n            val innerConsumed = tmpArray\n            super.onNestedPreScroll(target, dx - consumed[0], dy - consumed[1],\n                innerConsumed, type)\n            consumed[0] += innerConsumed[0]\n            consumed[1] += innerConsumed[1]\n        }\n    }\n\n    override fun onNestedScroll(\n        target: View,\n        dxConsumed: Int,\n        dyConsumed: Int,\n        dxUnconsumed: Int,\n        dyUnconsumed: Int,\n        type: Int,\n        consumed: IntArray\n    ) {\n        super.onNestedScroll(target, dxConsumed, dyConsumed,\n            dxUnconsumed, dyUnconsumed,\n            type, consumed)\n\n        dispatchNestedScroll(dxConsumed, dyConsumed,\n            dxUnconsumed, dyUnconsumed,\n            null,\n            type, tmpArray)\n    }\n\n    override fun onNestedPreFling(\n        target: View,\n        velocityX: Float,\n        velocityY: Float\n    ): Boolean {\n        return dispatchNestedPreFling(velocityX, velocityY) ||\n            super.onNestedPreFling(target, velocityX, velocityY)\n    }\n\n    override fun onNestedFling(\n        target: View,\n        velocityX: Float,\n        velocityY: Float,\n        consumed: Boolean\n    ): Boolean {\n        return dispatchNestedFling(velocityX, velocityY, consumed) ||\n            super.onNestedFling(target, velocityX, velocityY, consumed)\n    }\n\n    override fun onStopNestedScroll(\n        target: View,\n        type: Int\n    ) {\n        super.onStopNestedScroll(target, type)\n        stopNestedScroll(type)\n    }\n\n    /**\n     * NestedScrollingChild3 methods\n     */\n\n    override fun startNestedScroll(axes: Int, type: Int) = helper.startNestedScroll(axes, type)\n\n    override fun dispatchNestedPreScroll(\n        dx: Int,\n        dy: Int,\n        consumed: IntArray?,\n        offsetInWindow: IntArray?,\n        type: Int\n    ) = helper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type)\n\n    override fun stopNestedScroll(type: Int) = helper.stopNestedScroll(type)\n\n    override fun hasNestedScrollingParent(type: Int) = helper.hasNestedScrollingParent(type)\n\n    override fun dispatchNestedScroll(\n        dxConsumed: Int,\n        dyConsumed: Int,\n        dxUnconsumed: Int,\n        dyUnconsumed: Int,\n        offsetInWindow: IntArray?,\n        type: Int,\n        consumed: IntArray\n    ) {\n        helper.dispatchNestedScroll(dxConsumed, dyConsumed,\n            dxUnconsumed, dyUnconsumed,\n            offsetInWindow, type, consumed)\n    }\n\n    override fun dispatchNestedScroll(\n        dxConsumed: Int,\n        dyConsumed: Int,\n        dxUnconsumed: Int,\n        dyUnconsumed: Int,\n        offsetInWindow: IntArray?,\n        type: Int\n    ) = helper.dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed,\n        offsetInWindow, type)\n\n    override fun dispatchNestedPreFling(\n        velocityX: Float,\n        velocityY: Float\n    ): Boolean {\n        return helper.dispatchNestedPreFling(velocityX, velocityY)\n    }\n\n    override fun dispatchNestedFling(\n        velocityX: Float,\n        velocityY: Float,\n        consumed: Boolean\n    ) = helper.dispatchNestedFling(velocityX, velocityY, consumed)\n\n    override fun isNestedScrollingEnabled() = helper.isNestedScrollingEnabled\n\n    override fun setNestedScrollingEnabled(enabled: Boolean) {\n        helper.isNestedScrollingEnabled = enabled\n    }\n\n    override fun canScrollVertically(direction: Int): Boolean {\n        // This is what BottomSheetBehavior uses to determine whether to take over the nested scroll\n        // or not. Since we can't look into MotionLayout's state, we need to make a lot of\n        // assumptions based on the progress value\n        return (direction > 0 && progress < 1) || (direction < 0 && progress > 0)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport android.view.View\nimport android.widget.Checkable\nimport androidx.constraintlayout.widget.ConstraintLayout\n\nopen class CheckableConstraintLayout @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyle: Int = 0\n) : ConstraintLayout(context, attrs, defStyle), Checkable {\n\n    private var isChecked = false\n\n    override fun onCreateDrawableState(extraSpace: Int): IntArray {\n        val drawableState = super.onCreateDrawableState(extraSpace + 1)\n        if (isChecked) {\n            View.mergeDrawableStates(drawableState, CHECKED)\n        }\n        return drawableState\n    }\n\n    override fun setChecked(checked: Boolean) {\n        if (isChecked != checked) {\n            isChecked = checked\n            refreshDrawableState()\n        }\n    }\n\n    override fun isChecked(): Boolean = isChecked\n\n    override fun toggle() {\n        isChecked = !isChecked\n    }\n\n    companion object {\n        private val CHECKED = intArrayOf(android.R.attr.state_checked)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport androidx.annotation.Keep\nimport androidx.appcompat.widget.Toolbar\nimport app.tivi.common.ui.R\nimport app.tivi.extensions.resolveThemeColor\n\nclass TintingToolbar @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = R.attr.toolbarStyle\n) : Toolbar(context, attrs, defStyleAttr) {\n    @get:Keep\n    @set:Keep\n    var iconTint: Int = context.resolveThemeColor(android.R.attr.colorControlNormal)\n        set(value) {\n            if (value != field) {\n                navigationIcon = navigationIcon?.let {\n                    it.setTint(value)\n                    it.mutate()\n                }\n                overflowIcon = overflowIcon?.let {\n                    it.setTint(value)\n                    it.mutate()\n                }\n            }\n            field = value\n        }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.drawable.Drawable\nimport android.util.AttributeSet\nimport android.view.View\nimport androidx.core.content.res.use\nimport app.tivi.common.ui.R\nimport com.google.android.material.shape.CornerFamily\nimport com.google.android.material.shape.MaterialShapeDrawable\n\nclass MaterialShapeConstraintLayout @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyle: Int = 0\n) : CheckableConstraintLayout(context, attrs, defStyle) {\n\n    init {\n        context.obtainStyledAttributes(attrs, R.styleable.MaterialShapeConstraintLayout).use { ta ->\n            background = MaterialShapeDrawable.createWithElevationOverlay(context, elevation).apply {\n                fillColor = ta.getColorStateList(R.styleable.MaterialShapeConstraintLayout_materialBackgroundColor)\n\n                val builder = shapeAppearanceModel.toBuilder()\n\n                val topLeft = ta.getDimension(\n                    R.styleable.MaterialShapeConstraintLayout_materialBackgroundTopLeftRadius, 0f)\n                if (topLeft > 0) {\n                    builder.setTopLeftCorner(CornerFamily.ROUNDED, topLeft)\n                }\n                val topRight = ta.getDimension(\n                    R.styleable.MaterialShapeConstraintLayout_materialBackgroundTopRightRadius, 0f)\n                if (topRight > 0) {\n                    builder.setTopRightCorner(CornerFamily.ROUNDED, topRight)\n                }\n\n                shapeAppearanceModel = builder.build()\n            }\n        }\n    }\n\n    override fun draw(canvas: Canvas?) {\n        updateElevationRelativeToParentSurface()\n        super.draw(canvas)\n    }\n\n    override fun setBackground(background: Drawable?) {\n        super.setBackground(background)\n\n        if (background is MaterialShapeDrawable) {\n            background.elevation = elevation\n            background.translationZ = translationZ\n        }\n    }\n\n    override fun setElevation(elevation: Float) {\n        super.setElevation(elevation)\n\n        val bg = background\n        if (bg is MaterialShapeDrawable) {\n            bg.elevation = elevation\n        }\n    }\n\n    override fun setTranslationZ(translationZ: Float) {\n        super.setTranslationZ(translationZ)\n\n        val bg = background\n        if (bg is MaterialShapeDrawable) {\n            bg.translationZ = translationZ\n        }\n    }\n\n    private fun updateElevationRelativeToParentSurface() {\n        val bg = background\n        if (bg is MaterialShapeDrawable) {\n\n            var v = parent\n            var cumulativeElevation = elevation\n\n            // Iterate through our parents, until we find a view with a MaterialShapeDrawable\n            // background (the 'parent surface'). We then update our background, based on the\n            // 'parent surface's elevation\n            while (v is View) {\n                val vBg = v.background\n                if (vBg is MaterialShapeDrawable) {\n                    bg.elevation = vBg.elevation.coerceAtLeast(v.elevation) + cumulativeElevation\n                    break\n                } else {\n                    cumulativeElevation += v.elevation\n                }\n\n                v = v.getParent()\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.content.res.TypedArray\nimport android.util.AttributeSet\nimport android.util.TypedValue\nimport android.view.View\nimport androidx.appcompat.widget.AppCompatTextView\nimport app.tivi.common.ui.R\n\n/**\n * An extension to [AppCompatTextView] which aligns text to a 4dp baseline grid.\n *\n *\n * To achieve this we expose a `lineHeightHint` allowing you to specify the desired line\n * height (alternatively a `lineHeightMultiplierHint` to use a multiplier of the text size).\n * This line height will be adjusted to be a multiple of 4dp to ensure that baselines sit on\n * the grid.\n *\n *\n * We also adjust spacing above and below the text to ensure that the first line's baseline sits on\n * the grid (relative to the view's top) & that this view's height is a multiple of 4dp so that\n * subsequent views start on the grid.\n */\nclass BaselineGridTextView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = android.R.attr.textViewStyle\n) : AppCompatTextView(context, attrs, defStyleAttr) {\n\n    var lineHeightMultiplierHint = 1f\n        set(value) {\n            if (field != value) {\n                field = value\n                computeLineHeight()\n            }\n        }\n\n    var lineHeightHint = 0\n        set(value) {\n            if (field != value) {\n                field = value\n                computeLineHeight()\n            }\n        }\n\n    var maxLinesByHeight = true\n        set(value) {\n            if (field != value) {\n                field = value\n                computeLineHeight()\n            }\n        }\n\n    private var extraTopPadding = 0\n    private var extraBottomPadding = 0\n    private val fourDipInPx: Float\n\n    init {\n        val a = context.obtainStyledAttributes(\n            attrs, R.styleable.BaselineGridTextView, defStyleAttr, 0)\n\n        // first check TextAppearance for line height & font attributes\n        if (a.hasValue(R.styleable.BaselineGridTextView_android_textAppearance)) {\n            val textAppearanceId = a.getResourceId(\n                R.styleable.BaselineGridTextView_android_textAppearance, android.R.style.TextAppearance)\n            val ta = context.obtainStyledAttributes(\n                textAppearanceId, R.styleable.BaselineGridTextView)\n            parseTextAttrs(ta)\n            ta.recycle()\n        }\n\n        // then check view attrs\n        parseTextAttrs(a)\n        maxLinesByHeight = a.getBoolean(R.styleable.BaselineGridTextView_maxLinesByHeight, false)\n        a.recycle()\n\n        fourDipInPx = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 4f, resources.displayMetrics)\n        computeLineHeight()\n    }\n\n    override fun getCompoundPaddingTop(): Int {\n        // include extra padding to place the first line's baseline on the grid\n        return super.getCompoundPaddingTop() + extraTopPadding\n    }\n\n    override fun getCompoundPaddingBottom(): Int {\n        // include extra padding to make the height a multiple of 4dp\n        return super.getCompoundPaddingBottom() + extraBottomPadding\n    }\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        extraTopPadding = 0\n        extraBottomPadding = 0\n\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n\n        var height = measuredHeight\n        height += ensureBaselineOnGrid()\n        height += ensureHeightGridAligned(height)\n        setMeasuredDimension(measuredWidth, height)\n        checkMaxLines(height, View.MeasureSpec.getMode(heightMeasureSpec))\n    }\n\n    private fun parseTextAttrs(a: TypedArray) {\n        if (a.hasValue(R.styleable.BaselineGridTextView_lineHeightMultiplierHint)) {\n            lineHeightMultiplierHint = a.getFloat(R.styleable.BaselineGridTextView_lineHeightMultiplierHint, 1f)\n        }\n        if (a.hasValue(R.styleable.BaselineGridTextView_lineHeightHint)) {\n            lineHeightHint = a.getDimensionPixelSize(\n                R.styleable.BaselineGridTextView_lineHeightHint, 0)\n        }\n    }\n\n    /**\n     * Ensures line height is a multiple of 4dp.\n     */\n    private fun computeLineHeight() {\n        val fm = paint.fontMetrics\n        val fontHeight = Math.abs(fm.ascent - fm.descent) + fm.leading\n        val desiredLineHeight = if (lineHeightHint > 0) lineHeightHint.toFloat() else lineHeightMultiplierHint * fontHeight\n\n        val baselineAlignedLineHeight = Math.round(fourDipInPx * Math.ceil((desiredLineHeight / fourDipInPx).toDouble()))\n        setLineSpacing(baselineAlignedLineHeight - fontHeight, 1f)\n    }\n\n    /**\n     * Ensure that the first line of text sits on the 4dp grid.\n     */\n    private fun ensureBaselineOnGrid(): Int {\n        val baseline = baseline.toFloat()\n        val gridAlign = baseline % fourDipInPx\n        if (gridAlign != 0f) {\n            extraTopPadding = (fourDipInPx - Math.ceil(gridAlign.toDouble())).toInt()\n        }\n        return extraTopPadding\n    }\n\n    /**\n     * Ensure that height is a multiple of 4dp.\n     */\n    private fun ensureHeightGridAligned(height: Int): Int {\n        val gridOverhang = height % fourDipInPx\n        if (gridOverhang != 0f) {\n            extraBottomPadding = (fourDipInPx - Math.ceil(gridOverhang.toDouble())).toInt()\n        }\n        return extraBottomPadding\n    }\n\n    /**\n     * When measured with an exact height, text can be vertically clipped mid-line. Prevent\n     * this by setting the `maxLines` property based on the available space.\n     */\n    private fun checkMaxLines(height: Int, heightMode: Int) {\n        if (!maxLinesByHeight || heightMode != View.MeasureSpec.EXACTLY) return\n\n        val textHeight = height - compoundPaddingTop - compoundPaddingBottom\n        val completeLines = Math.floor((textHeight / lineHeight).toDouble()).toInt()\n        maxLines = completeLines\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.graphics.Color\nimport android.util.AttributeSet\nimport android.view.View\nimport androidx.annotation.Keep\nimport app.tivi.common.ui.R\nimport app.tivi.ui.animations.lerp\nimport com.google.android.material.shape.CornerFamily\nimport com.google.android.material.shape.MaterialShapeDrawable\n\nclass TopLeftCutoutBackgroundView : View {\n    private val shapeDrawable = MaterialShapeDrawable()\n\n    constructor(context: Context) : this(context, null)\n    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)\n    constructor(\n        context: Context,\n        attrs: AttributeSet?,\n        defStyleAttr: Int\n    ) : super(context, attrs, defStyleAttr) {\n        val a = context.obtainStyledAttributes(attrs, R.styleable.TopLeftCutoutBackgroundView)\n        color = a.getColor(R.styleable.TopLeftCutoutBackgroundView_backgroundColor, Color.MAGENTA)\n        maxCutSize = a.getDimension(R.styleable.TopLeftCutoutBackgroundView_topLeftCutSize, 0f)\n        a.recycle()\n\n        background = shapeDrawable\n        syncCutSize()\n    }\n\n    @set:Keep\n    var color: Int = Color.MAGENTA\n        set(value) {\n            shapeDrawable.setTint(value)\n            field = value\n        }\n\n    var maxCutSize: Float = 0f\n        set(value) {\n            if (value != field) {\n                field = value\n                syncCutSize()\n            }\n        }\n\n    @set:Keep\n    var cutProgress: Float\n        get() = shapeDrawable.interpolation\n        set(value) {\n            shapeDrawable.interpolation = value\n        }\n\n    private fun syncCutSize() {\n        shapeDrawable.shapeAppearanceModel = shapeDrawable.shapeAppearanceModel.toBuilder()\n            .setTopLeftCorner(CornerFamily.CUT, lerp(0f, maxCutSize, cutProgress))\n            .build()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.graphics.Canvas\nimport android.graphics.drawable.Drawable\nimport android.util.AttributeSet\nimport android.view.View\nimport android.widget.FrameLayout\nimport androidx.core.content.res.use\nimport app.tivi.common.ui.R\nimport com.google.android.material.shape.MaterialShapeDrawable\n\nclass HeaderHolderFrameLayout @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyle: Int = 0\n) : FrameLayout(context, attrs, defStyle) {\n\n    var dividerDrawable: Drawable? = null\n        set(value) {\n            field?.callback = null\n            if (value != null) {\n                value.callback = this\n            }\n            field = value\n        }\n\n    var dividerMarginEnd: Int = 0\n        set(value) {\n            field = value\n            dividerDrawable?.run { invalidateSelf() }\n        }\n\n    var dividerMarginStart: Int = 0\n        set(value) {\n            field = value\n            dividerDrawable?.run { invalidateSelf() }\n        }\n\n    init {\n        context.obtainStyledAttributes(attrs, R.styleable.HeaderHolderFrameLayout,\n            defStyle, R.style.Widget_Tivi_HeaderHolderFrameLayout).use {\n            dividerDrawable = it.getDrawable(R.styleable.HeaderHolderFrameLayout_dividerDrawable)\n            dividerMarginStart = it.getDimensionPixelSize(\n                R.styleable.HeaderHolderFrameLayout_dividerMarginStart, 0)\n            dividerMarginEnd = it.getDimensionPixelSize(\n                R.styleable.HeaderHolderFrameLayout_dividerMarginEnd, 0)\n            background = MaterialShapeDrawable.createWithElevationOverlay(context, elevation).apply {\n                fillColor = it.getColorStateList(R.styleable.HeaderHolderFrameLayout_materialBackgroundColor)\n            }\n        }\n    }\n\n    override fun draw(canvas: Canvas) {\n        updateElevationRelativeToParentSurface()\n\n        super.draw(canvas)\n\n        dividerDrawable?.run {\n            val left = when (layoutDirection) {\n                View.LAYOUT_DIRECTION_RTL -> dividerMarginEnd\n                else -> dividerMarginStart\n            }\n            val right = when (layoutDirection) {\n                View.LAYOUT_DIRECTION_RTL -> dividerMarginStart\n                else -> dividerMarginEnd\n            }\n            setBounds(left, height - intrinsicHeight, width - right, height)\n        }\n        dividerDrawable?.draw(canvas)\n    }\n\n    override fun setBackground(background: Drawable?) {\n        super.setBackground(background)\n\n        if (background is MaterialShapeDrawable) {\n            background.elevation = elevation\n            background.translationZ = translationZ\n        }\n    }\n\n    override fun setElevation(elevation: Float) {\n        super.setElevation(elevation)\n\n        val bg = background\n        if (bg is MaterialShapeDrawable) {\n            bg.elevation = elevation\n        }\n    }\n\n    override fun setTranslationZ(translationZ: Float) {\n        super.setTranslationZ(translationZ)\n\n        val bg = background\n        if (bg is MaterialShapeDrawable) {\n            bg.translationZ = translationZ\n        }\n    }\n\n    private fun updateElevationRelativeToParentSurface() {\n        val bg = background\n        if (bg is MaterialShapeDrawable) {\n\n            var v = parent\n            var cumulativeElevation = elevation\n\n            // Iterate through our parents, until we find a view with a MaterialShapeDrawable\n            // background (the 'parent surface'). We then update our background, based on the\n            // 'parent surface's elevation\n            while (v is View) {\n                val vBg = v.background\n                if (vBg is MaterialShapeDrawable) {\n                    bg.elevation = vBg.elevation.coerceAtLeast(v.elevation) + cumulativeElevation\n                    break\n                } else {\n                    cumulativeElevation += v.elevation\n                }\n\n                v = v.getParent()\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport android.view.View\nimport android.widget.Checkable\nimport com.google.android.material.floatingactionbutton.FloatingActionButton\n\nclass CheckableFloatingActionButton @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyle: Int = com.google.android.material.R.attr.floatingActionButtonStyle\n) : FloatingActionButton(context, attrs, defStyle), Checkable {\n\n    private var isChecked = false\n\n    override fun onCreateDrawableState(extraSpace: Int): IntArray {\n        val drawableState = super.onCreateDrawableState(extraSpace + 1)\n        if (isChecked) {\n            View.mergeDrawableStates(drawableState, CHECKED)\n        }\n        return drawableState\n    }\n\n    override fun setChecked(checked: Boolean) {\n        if (isChecked != checked) {\n            isChecked = checked\n            refreshDrawableState()\n        }\n    }\n\n    override fun isChecked(): Boolean = isChecked\n\n    override fun toggle() {\n        isChecked = !isChecked\n    }\n\n    companion object {\n        private val CHECKED = intArrayOf(android.R.attr.state_checked)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport android.view.Gravity\nimport android.view.MotionEvent\nimport android.view.View\nimport androidx.annotation.AttrRes\nimport androidx.annotation.MenuRes\nimport androidx.annotation.StyleRes\nimport androidx.appcompat.widget.AppCompatImageButton\nimport androidx.appcompat.widget.PopupMenu\nimport app.tivi.common.ui.R\n\nclass PopupMenuButton : AppCompatImageButton {\n    constructor(context: Context) : this(context, null)\n    constructor(\n        context: Context,\n        attrs: AttributeSet?\n    ) : this(context, attrs, android.R.attr.actionOverflowButtonStyle)\n\n    constructor(\n        context: Context,\n        attrs: AttributeSet?,\n        defStyleAttr: Int\n    ) : super(context, attrs, defStyleAttr) {\n        val a = context.obtainStyledAttributes(attrs, R.styleable.PopupMenuButton)\n        val menuRes = a.getResourceId(R.styleable.PopupMenuButton_menu, -1)\n        if (menuRes != -1) {\n            inflateMenu(menuRes)\n        }\n        a.recycle()\n    }\n\n    val popupMenu: PopupMenu = InternalPopupMenu(context, this, R.attr.actionOverflowMenuStyle)\n    var popupMenuListener: PopupMenuListener? = null\n\n    fun inflateMenu(@MenuRes menuRes: Int) = popupMenu.inflate(menuRes)\n\n    fun setMenuItemClickListener(listener: PopupMenu.OnMenuItemClickListener?) {\n        popupMenu.setOnMenuItemClickListener(listener)\n    }\n\n    override fun dispatchTouchEvent(event: MotionEvent): Boolean {\n        if (popupMenu.dragToOpenListener.onTouch(this, event)) {\n            return true\n        }\n        return super.dispatchTouchEvent(event)\n    }\n\n    override fun performClick(): Boolean {\n        popupMenu.show()\n        return true\n    }\n\n    interface PopupMenuListener {\n        fun onPreparePopupMenu(popupMenu: PopupMenu)\n    }\n\n    private fun onPrePopupShow() {\n        popupMenuListener?.also {\n            it.onPreparePopupMenu(popupMenu)\n        }\n    }\n\n    private inner class InternalPopupMenu(\n        context: Context,\n        anchor: View,\n        gravity: Int = Gravity.NO_GRAVITY,\n        @AttrRes popupStyleAttr: Int = R.attr.popupMenuStyle,\n        @StyleRes popupStyleRes: Int = 0\n    ) : PopupMenu(context, anchor, gravity, popupStyleAttr, popupStyleRes) {\n        override fun show() {\n            onPrePopupShow()\n            super.show()\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport androidx.constraintlayout.motion.widget.MotionLayout\nimport java.util.concurrent.CopyOnWriteArrayList\n\nclass TiviMotionLayout @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : MotionLayout(context, attrs, defStyleAttr) {\n\n    private val listeners = CopyOnWriteArrayList<TransitionListener>()\n\n    fun addTransitionListener(listener: TransitionListener) {\n        listeners.addIfAbsent(listener)\n    }\n\n    fun removeTransitionListener(listener: TransitionListener) {\n        listeners.remove(listener)\n    }\n\n    init {\n        super.setTransitionListener(object : TransitionListener {\n            override fun onTransitionTrigger(\n                motionLayout: MotionLayout,\n                triggerId: Int,\n                positive: Boolean,\n                progress: Float\n            ) {\n                listeners.forEach {\n                    it.onTransitionTrigger(motionLayout, triggerId, positive, progress)\n                }\n            }\n\n            override fun onTransitionStarted(motionLayout: MotionLayout, startId: Int, endId: Int) {\n                listeners.forEach {\n                    it.onTransitionStarted(motionLayout, startId, endId)\n                }\n            }\n\n            override fun onTransitionChange(\n                motionLayout: MotionLayout,\n                startId: Int,\n                endId: Int,\n                progress: Float\n            ) {\n                listeners.forEach {\n                    it.onTransitionChange(motionLayout, startId, endId, progress)\n                }\n            }\n\n            override fun onTransitionCompleted(motionLayout: MotionLayout, currentId: Int) {\n                listeners.forEach {\n                    it.onTransitionCompleted(motionLayout, currentId)\n                }\n            }\n        })\n    }\n\n    @Deprecated(\"Use addTransitionListener instead\")\n    override fun setTransitionListener(listener: TransitionListener) {\n        throw IllegalArgumentException(\"Use addTransitionListener instead\")\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.widget\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport android.view.View.MeasureSpec.EXACTLY\nimport androidx.appcompat.widget.AppCompatImageView\n\nclass TwoThreeImageView(\n    context: Context?,\n    attrs: AttributeSet?\n) : AppCompatImageView(context, attrs) {\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        val height = MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec) * 3 / 2, EXACTLY)\n        super.onMeasure(widthMeasureSpec, height)\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport android.content.Context\nimport android.util.AttributeSet\nimport android.view.View\nimport androidx.coordinatorlayout.widget.CoordinatorLayout\nimport androidx.core.view.WindowInsetsCompat\n\nclass StatusBarHeightBehavior(\n    context: Context,\n    attrs: AttributeSet?\n) : CoordinatorLayout.Behavior<View>(context, attrs) {\n    override fun onApplyWindowInsets(\n        coordinatorLayout: CoordinatorLayout,\n        child: View,\n        insets: WindowInsetsCompat\n    ): WindowInsetsCompat {\n        val lp = child.layoutParams\n        lp.height = insets.systemWindowInsetTop\n        child.layoutParams = lp\n        return insets.consumeSystemWindowInsets()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport androidx.appcompat.widget.PopupMenu\nimport androidx.core.view.get\nimport app.tivi.common.ui.R\nimport app.tivi.data.entities.SortOption\nimport app.tivi.ui.widget.PopupMenuButton\n\nclass SortPopupMenuListener(\n    private val selectedSort: SortOption,\n    private val availableSorts: List<SortOption>\n) : PopupMenuButton.PopupMenuListener {\n    override fun onPreparePopupMenu(popupMenu: PopupMenu) {\n        val menu = popupMenu.menu\n        for (index in 0 until menu.size()) {\n            val menuItem = menu[index]\n            val sortOption = popupMenuItemIdToSortOption(menuItem.itemId) ?: break\n\n            menuItem.isVisible = availableSorts.contains(sortOption)\n            if (selectedSort == sortOption) {\n                menuItem.isChecked = true\n            }\n        }\n    }\n}\n\nfun popupMenuItemIdToSortOption(itemId: Int) = when (itemId) {\n    R.id.popup_sort_super -> SortOption.SUPER_SORT\n    R.id.popup_sort_date_followed -> SortOption.DATE_ADDED\n    R.id.popup_sort_alpha -> SortOption.ALPHABETICAL\n    R.id.popup_sort_last_watched -> SortOption.LAST_WATCHED\n    else -> null\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport android.graphics.Rect\nimport android.view.View\nimport androidx.recyclerview.widget.RecyclerView\n\nclass SpacingItemDecorator(\n    left: Int = 0,\n    top: Int = 0,\n    right: Int = 0,\n    bottom: Int = 0\n) : RecyclerView.ItemDecoration() {\n\n    constructor(spacing: Int) : this(spacing, spacing, spacing, spacing)\n\n    private val spacingRect = Rect()\n\n    init {\n        spacingRect.set(left, top, right, bottom)\n    }\n\n    override fun getItemOffsets(\n        outRect: Rect,\n        view: View,\n        parent: RecyclerView,\n        state: RecyclerView.State\n    ) {\n        outRect.set(spacingRect)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport android.graphics.Color\nimport android.graphics.LinearGradient\nimport android.graphics.Shader\nimport android.graphics.drawable.Drawable\nimport android.graphics.drawable.PaintDrawable\nimport android.graphics.drawable.ShapeDrawable\nimport android.graphics.drawable.shapes.RectShape\nimport android.util.LruCache\nimport android.view.Gravity\nimport androidx.annotation.ColorInt\nimport androidx.core.graphics.ColorUtils\nimport kotlin.math.pow\nimport kotlin.math.roundToInt\n\n/**\n * Utility methods for creating prettier gradient scrims.\n */\nobject ScrimUtil {\n    private val cache = LruCache<Int, Drawable>(10)\n\n    /**\n     * Creates an approximated cubic gradient using a multi-stop linear gradient. See\n     * [this post](https://plus.google.com/+RomanNurik/posts/2QvHVFWrHZf) for more\n     * details.\n     */\n    fun makeCubicGradientScrimDrawable(\n        @ColorInt baseColor: Int,\n        numStops: Int,\n        gravity: Int\n    ): Drawable {\n        // Generate a cache key by hashing together the inputs, based on the method described in the Effective Java book\n        var cacheKeyHash = baseColor\n        cacheKeyHash = 31 * cacheKeyHash + numStops\n        cacheKeyHash = 31 * cacheKeyHash + gravity\n\n        val cachedGradient = cache.get(cacheKeyHash)\n        if (cachedGradient != null) {\n            return cachedGradient\n        }\n\n        val paintDrawable = PaintDrawable()\n        paintDrawable.shape = RectShape()\n\n        val stopColors = IntArray(numStops)\n        val alpha = Color.alpha(baseColor)\n\n        for (i in 0 until numStops) {\n            val x = i * 1f / (numStops - 1)\n            val opacity = x.toDouble().pow(3.0).toFloat()\n            stopColors[i] = ColorUtils.setAlphaComponent(baseColor,\n                (alpha * opacity).roundToInt().coerceIn(0, 255))\n        }\n\n        val x0: Float\n        val x1: Float\n        val y0: Float\n        val y1: Float\n        when (gravity and Gravity.HORIZONTAL_GRAVITY_MASK) {\n            Gravity.LEFT -> {\n                x0 = 1f\n                x1 = 0f\n            }\n            Gravity.RIGHT -> {\n                x0 = 0f\n                x1 = 1f\n            }\n            else -> {\n                x0 = 0f\n                x1 = 0f\n            }\n        }\n        when (gravity and Gravity.VERTICAL_GRAVITY_MASK) {\n            Gravity.TOP -> {\n                y0 = 1f\n                y1 = 0f\n            }\n            Gravity.BOTTOM -> {\n                y0 = 0f\n                y1 = 1f\n            }\n            else -> {\n                y0 = 0f\n                y1 = 0f\n            }\n        }\n\n        paintDrawable.shaderFactory = object : ShapeDrawable.ShaderFactory() {\n            override fun resize(width: Int, height: Int): Shader {\n                return LinearGradient(\n                    width * x0,\n                    height * y0,\n                    width * x1,\n                    height * y1,\n                    stopColors,\n                    null,\n                    Shader.TileMode.CLAMP)\n            }\n        }\n        cache.put(cacheKeyHash, paintDrawable)\n        return paintDrawable\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport androidx.annotation.StringRes\nimport app.tivi.common.ui.R\nimport app.tivi.data.entities.Genre\n\nobject GenreStringer {\n    fun getEmoji(genre: Genre): String = when (genre) {\n        Genre.DRAMA -> \"\\uD83D\\uDE28\"\n        Genre.FANTASY -> \"\\uD83E\\uDDD9\"\n        Genre.SCIENCE_FICTION -> \"\\uD83D\\uDE80\"\n        Genre.ACTION -> \"\\uD83E\\uDD20\"\n        Genre.ADVENTURE -> \"\\uD83C\\uDFDE\"\n        Genre.CRIME -> \"\\uD83D\\uDC6E\"\n        Genre.THRILLER -> \"\\uD83D\\uDDE1\"\n        Genre.COMEDY -> \"\\uD83E\\uDD23\"\n        Genre.HORROR -> \"\\uD83E\\uDDDF\"\n        Genre.MYSTERY -> \"\\uD83D\\uDD75\"\n    }\n\n    @StringRes\n    fun getLabel(genre: Genre): Int = when (genre) {\n        Genre.DRAMA -> R.string.genre_label_drama\n        Genre.FANTASY -> R.string.genre_label_fantasy\n        Genre.SCIENCE_FICTION -> R.string.genre_label_science_fiction\n        Genre.ACTION -> R.string.genre_label_action\n        Genre.ADVENTURE -> R.string.genre_label_adventure\n        Genre.CRIME -> R.string.genre_label_crime\n        Genre.THRILLER -> R.string.genre_label_thriller\n        Genre.COMEDY -> R.string.genre_label_comedy\n        Genre.HORROR -> R.string.genre_label_horror\n        Genre.MYSTERY -> R.string.genre_label_mystery\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.recyclerview\n\nimport android.content.Context\nimport android.util.DisplayMetrics\nimport androidx.recyclerview.widget.LinearSmoothScroller\n\nclass TiviLinearSmoothScroller(\n    private val context: Context,\n    private val snapPreference: Int = SNAP_TO_ANY,\n    private val scrollMsPerInch: Float = 25f\n) : LinearSmoothScroller(context) {\n\n    var targetOffset: Int = 0\n\n    override fun getVerticalSnapPreference(): Int = snapPreference\n\n    override fun getHorizontalSnapPreference(): Int = snapPreference\n\n    override fun calculateSpeedPerPixel(displayMetrics: DisplayMetrics): Float {\n        return scrollMsPerInch / displayMetrics.densityDpi\n    }\n\n    override fun calculateDtToFit(\n        viewStart: Int,\n        viewEnd: Int,\n        boxStart: Int,\n        boxEnd: Int,\n        snapPreference: Int\n    ): Int {\n        return targetOffset + super.calculateDtToFit(viewStart, viewEnd,\n            boxStart, boxEnd, snapPreference)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.recyclerview\n\nimport android.app.Activity\nimport android.view.inputmethod.InputMethodManager\nimport androidx.core.content.getSystemService\nimport androidx.recyclerview.widget.RecyclerView\nimport app.tivi.extensions.findBaseContext\n\nclass HideImeOnScrollListener : RecyclerView.OnScrollListener() {\n    private lateinit var imm: InputMethodManager\n\n    override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {\n        if (newState == RecyclerView.SCROLL_STATE_DRAGGING && recyclerView.childCount > 0) {\n            if (!::imm.isInitialized) {\n                imm = recyclerView.context.getSystemService()!!\n            }\n            if (imm.isAcceptingText) {\n                val activity: Activity? = recyclerView.context.findBaseContext()\n                val currentFocus = activity?.currentFocus\n                if (currentFocus != null) {\n                    imm.hideSoftInputFromWindow(currentFocus.windowToken, 0)\n                }\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport android.os.Handler\nimport android.os.Looper\nimport android.os.SystemClock\n\n/**\n * A class which acts as a time latch for show progress bars UIs. It waits a minimum time to be\n * dismissed before showing. Once visible, the progress bar will be visible for\n * a minimum amount of time to avoid \"flashes\" in the UI when an event could take\n * a largely variable time to complete (from none, to a user perceivable amount).\n *\n * Works with an view through the lambda API.\n */\nclass ProgressTimeLatch(\n    private val delayMs: Long = 750,\n    private val minShowTime: Long = 500,\n    private val viewRefreshingToggle: ((Boolean) -> Unit)\n) {\n    private val handler = Handler(Looper.getMainLooper())\n    private var showTime = 0L\n\n    private val delayedShow = Runnable(this::show)\n    private val delayedHide = Runnable(this::hideAndReset)\n\n    var refreshing = false\n        set(value) {\n            if (field != value) {\n                field = value\n                handler.removeCallbacks(delayedShow)\n                handler.removeCallbacks(delayedHide)\n\n                if (value) {\n                    handler.postDelayed(delayedShow, delayMs)\n                } else if (showTime >= 0) {\n                    // We're already showing, lets check if we need to delay the hide\n                    val showTime = SystemClock.uptimeMillis() - showTime\n                    if (showTime < minShowTime) {\n                        handler.postDelayed(delayedHide, minShowTime - showTime)\n                    } else {\n                        // We've been showing longer than the min, so hide and clean up\n                        hideAndReset()\n                    }\n                } else {\n                    // We're not currently show so just hide and clean up\n                    hideAndReset()\n                }\n            }\n        }\n\n    private fun show() {\n        viewRefreshingToggle(true)\n        showTime = SystemClock.uptimeMillis()\n    }\n\n    private fun hideAndReset() {\n        viewRefreshingToggle(false)\n        showTime = 0\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport android.view.MenuItem\nimport androidx.appcompat.widget.Toolbar\nimport app.tivi.data.entities.TraktUser\nimport app.tivi.trakt.TraktAuthState\n\nclass AuthStateMenuItemBinder(\n    private val userMenuItem: MenuItem,\n    private val loginMenuItem: MenuItem,\n    private val loadImageFunc: (MenuItem, url: String) -> Unit\n) {\n    fun bind(authState: TraktAuthState, user: TraktUser? = null) {\n        if (authState == TraktAuthState.LOGGED_IN) {\n            userMenuItem.isVisible = true\n            user?.avatarUrl?.also { url -> loadImageFunc(userMenuItem, url) }\n            loginMenuItem.isVisible = false\n        } else if (authState == TraktAuthState.LOGGED_OUT) {\n            userMenuItem.isVisible = false\n            loginMenuItem.isVisible = true\n        }\n    }\n}\n\nfun authStateToolbarMenuBinder(\n    toolbar: Toolbar,\n    userMenuItemId: Int,\n    loginMenuItemId: Int,\n    loadImageFunc: (MenuItem, url: String) -> Unit\n) = AuthStateMenuItemBinder(\n    toolbar.menu.findItem(userMenuItemId),\n    toolbar.menu.findItem(loginMenuItemId),\n    loadImageFunc\n)",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.text\n\nimport android.graphics.Paint\nimport android.graphics.Typeface\nimport android.text.TextPaint\nimport android.text.style.MetricAffectingSpan\n\nclass TypefaceSpan(private val typeface: Typeface? = null) : MetricAffectingSpan() {\n\n    override fun updateMeasureState(p: TextPaint) {\n        if (typeface != null) {\n            p.typeface = typeface\n            // Note: This flag is required for proper typeface rendering\n            p.flags = p.flags or Paint.SUBPIXEL_TEXT_FLAG\n        }\n    }\n\n    override fun updateDrawState(tp: TextPaint) {\n        if (typeface != null) {\n            tp.typeface = typeface\n            // Note: This flag is required for proper typeface rendering\n            tp.flags = tp.flags or Paint.SUBPIXEL_TEXT_FLAG\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.text\n\nimport android.content.Context\nimport android.text.style.TextAppearanceSpan\nimport android.util.TypedValue\n\nprivate val typedValue = TypedValue()\n\nfun textAppearanceSpanForAttribute(context: Context, attr: Int): TextAppearanceSpan {\n    if (context.theme.resolveAttribute(attr, typedValue, true)) {\n        return TextAppearanceSpan(context, typedValue.resourceId)\n    } else {\n        throw IllegalArgumentException(\"TextAppearance theme attribute can not be resolved\")\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.transitions\n\nimport android.animation.Animator\nimport android.graphics.Rect\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.recyclerview.widget.RecyclerView\nimport androidx.transition.Transition\nimport androidx.transition.TransitionListenerAdapter\nimport androidx.transition.TransitionValues\nimport app.tivi.extensions.animatorSetOf\n\n/**\n * This transition captures the layout bounds of target views before and after\n * the scene change and animates those changes during the transition.\n *\n * A ChangeBounds transition can be described in a resource file by using the\n * tag `changeBounds`, along with the other standard attributes of Transition.\n */\nclass ColumnedChangeBounds : ViewChangeBounds() {\n\n    override fun createAnimator(\n        sceneRoot: ViewGroup,\n        startValues: TransitionValues?,\n        endValues: TransitionValues?\n    ): Animator? {\n        if (startValues == null || endValues == null) {\n            return null\n        }\n\n        val view = endValues.view\n\n        val startBounds = startValues.values[PROPNAME_BOUNDS] as Rect\n        val endBounds = endValues.values[PROPNAME_BOUNDS] as Rect\n\n        val startLeft = startBounds.left\n        val endLeft = endBounds.left\n\n        val startTop = startBounds.top\n        val startBottom = startBounds.bottom\n\n        val startWidth = startBounds.width()\n        val startHeight = startBounds.height()\n\n        val endWidth = endBounds.width()\n\n        // If we don't have a RecyclerView parent, not much point us doing anything so return null\n        val recyclerViewEndParent = findRecyclerViewParent(view) ?: return null\n\n        val anim: Animator\n\n        if (endWidth > startWidth && endLeft < startLeft) {\n            // If we're bigger, and we're going left, we're probably part of a grid of different column\n            // counts\n            val anims = mutableListOf<Animator>()\n\n            // Animate the current view in from the left\n            val startCopy = Rect(endLeft - startWidth, startBottom, endLeft, startBottom + startHeight)\n            anims += createPointToPointAnimator(view, startCopy, endBounds, 0f, 1f)\n\n            // Animate a copy of the current view out to the right\n            createAnimatorsForChildCopyOutRight(view, recyclerViewEndParent, startBounds, endBounds)?.also {\n                anims += it\n            }\n\n            anim = animatorSetOf(anims)\n        } else if (endWidth < startWidth && endLeft > startLeft) {\n            // If we're smaller, and we're going right, we're probably part of a grid of different column\n            // counts\n            val anims = mutableListOf<Animator>()\n\n            val gap = 0 // TODO Fix this spacing\n            val inStartLeft = startLeft + sceneRoot.width\n            val inStartTop = startTop - startHeight - gap\n            val startCopy = Rect(inStartLeft, inStartTop, inStartLeft + startWidth, inStartTop + startHeight)\n\n            anims += createPointToPointAnimator(view, startCopy, endBounds, 0f, 1f)\n\n            // Animate a copy of the current view out to the left\n            anims += createAnimatorForChildCopyOutLeft(view, startBounds, endBounds)\n\n            anim = animatorSetOf(anims)\n        } else {\n            anim = createPointToPointAnimator(view, startBounds, endBounds)\n        }\n\n        val parent = view.parent\n        if (parent is ViewGroup) {\n            parent.suppressLayoutInternal(true)\n\n            addListener(object : TransitionListenerAdapter() {\n                private var canceled = false\n\n                override fun onTransitionCancel(transition: Transition) {\n                    parent.suppressLayoutInternal(false)\n                    canceled = true\n                }\n\n                override fun onTransitionEnd(transition: Transition) {\n                    if (!canceled) {\n                        parent.suppressLayoutInternal(false)\n                    }\n                    transition.removeListener(this)\n                }\n\n                override fun onTransitionPause(transition: Transition) {\n                    parent.suppressLayoutInternal(false)\n                }\n\n                override fun onTransitionResume(transition: Transition) {\n                    parent.suppressLayoutInternal(false)\n                }\n            })\n        }\n\n        return anim\n    }\n\n    private fun createAnimatorForChildCopyOutLeft(\n        view: View,\n        startBounds: Rect,\n        endBounds: Rect\n    ): Animator {\n        val gap = 0 // TODO\n        val newEndRight = startBounds.left - gap\n        val newEndTop = endBounds.bottom + gap\n        val newEndBounds = Rect(\n            newEndRight - endBounds.width(),\n            newEndTop,\n            newEndRight,\n            newEndTop + endBounds.height())\n\n        return createPointToPointAnimator(view, startBounds, newEndBounds, 1f, 0f, true)\n    }\n\n    private fun createAnimatorsForChildCopyOutRight(\n        view: View,\n        endParent: RecyclerView,\n        startBounds: Rect,\n        endBounds: Rect\n    ): Animator? {\n        val prevEndBounds = findPreviousItemViewWithGreaterRight(endParent, view, endBounds.right)\n            ?: return null\n\n        val newEndLeft = prevEndBounds.right + endBounds.left\n        val newEndTop = prevEndBounds.top\n        val newEndBounds = Rect(newEndLeft, newEndTop,\n            newEndLeft + endBounds.width(),\n            newEndTop + endBounds.height())\n\n        return createPointToPointAnimator(view, startBounds, newEndBounds, 1f, 0f, true)\n    }\n\n    private fun findRecyclerViewParent(view: View): RecyclerView? {\n        var parent = view.parent\n        while (parent != null && parent !is RecyclerView) {\n            parent = parent.parent\n        }\n        return when (parent) {\n            is RecyclerView -> parent\n            else -> null\n        }\n    }\n\n    private fun findPreviousItemViewWithGreaterRight(\n        parent: RecyclerView,\n        view: View,\n        right: Int\n    ): Rect? {\n        // This view might not necessarily be the root of the item view\n        val rvItemView = parent.findContainingItemView(view) ?: return null\n\n        for (i in parent.getChildAdapterPosition(rvItemView) - 1 downTo 0) {\n            val vh = parent.findViewHolderForAdapterPosition(i) ?: continue\n            val tv = getTransitionValues(vh.itemView, false) ?: continue\n            val bounds = tv.values[PROPNAME_BOUNDS] as? Rect ?: continue\n            if (bounds.right > right) {\n                return bounds\n            }\n        }\n\n        return null\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.transitions\n\nimport android.animation.Animator\nimport android.animation.ObjectAnimator\nimport android.animation.PropertyValuesHolder\nimport android.graphics.Bitmap\nimport android.graphics.PointF\nimport android.graphics.Rect\nimport android.util.Property\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.core.animation.doOnEnd\nimport androidx.core.graphics.drawable.toDrawable\nimport androidx.core.view.ViewCompat\nimport androidx.core.view.drawToBitmap\nimport androidx.transition.Transition\nimport androidx.transition.TransitionListenerAdapter\nimport androidx.transition.TransitionValues\nimport app.tivi.extensions.getBounds\nimport app.tivi.ui.animations.FloatProp\nimport app.tivi.ui.animations.createFloatProperty\nimport kotlin.math.roundToInt\n\n/**\n * This transition captures the layout bounds of target views before and after\n * the scene change and animates those changes during the transition.\n *\n * A ChangeBounds transition can be described in a resource file by using the\n * tag `changeBounds`, along with the other standard attributes of Transition.\n */\nopen class ViewChangeBounds : Transition() {\n\n    override fun getTransitionProperties(): Array<String>? = TRANSITION_PROPS\n\n    private fun captureValues(values: TransitionValues) {\n        val view = values.view\n        if (ViewCompat.isLaidOut(view) || view.width != 0 || view.height != 0) {\n            values.values[PROPNAME_BOUNDS] = Rect().apply { view.getBounds(this) }\n            values.values[PROPNAME_PARENT] = values.view.parent\n        }\n    }\n\n    override fun captureStartValues(transitionValues: TransitionValues) {\n        captureValues(transitionValues)\n    }\n\n    override fun captureEndValues(transitionValues: TransitionValues) {\n        captureValues(transitionValues)\n    }\n\n    override fun createAnimator(\n        sceneRoot: ViewGroup,\n        startValues: TransitionValues?,\n        endValues: TransitionValues?\n    ): Animator? {\n        if (startValues == null || endValues == null) {\n            return null\n        }\n\n        val view = endValues.view\n\n        val startBounds = startValues.values[PROPNAME_BOUNDS] as Rect\n        val endBounds = endValues.values[PROPNAME_BOUNDS] as Rect\n\n        val anim = createPointToPointAnimator(view, startBounds, endBounds)\n\n        val parent = view.parent\n        if (parent is ViewGroup) {\n            parent.suppressLayoutInternal(true)\n\n            addListener(object : TransitionListenerAdapter() {\n                private var canceled = false\n\n                override fun onTransitionCancel(transition: Transition) {\n                    parent.suppressLayoutInternal(false)\n                    canceled = true\n                }\n\n                override fun onTransitionEnd(transition: Transition) {\n                    if (!canceled) {\n                        parent.suppressLayoutInternal(false)\n                    }\n                    transition.removeListener(this)\n                }\n\n                override fun onTransitionPause(transition: Transition) {\n                    parent.suppressLayoutInternal(false)\n                }\n\n                override fun onTransitionResume(transition: Transition) {\n                    parent.suppressLayoutInternal(false)\n                }\n            })\n        }\n\n        return anim\n    }\n\n    fun createPointToPointAnimator(\n        view: View,\n        startBounds: Rect,\n        endBounds: Rect,\n        startAlpha: Float = 1f,\n        endAlpha: Float = 1f,\n        useCopy: Boolean = false\n    ): Animator {\n        val bounds = if (useCopy) DrawableBounds(view) else ViewBounds(view)\n\n        val originalAlpha = bounds.getAlpha()\n\n        val outTopLeftPropVal = PropertyValuesHolder.ofObject<PointF>(\n            TOP_LEFT_PROPERTY,\n            null,\n            pathMotion.getPath(\n                startBounds.left.toFloat(), startBounds.top.toFloat(),\n                endBounds.left.toFloat(), endBounds.top.toFloat())\n        )\n\n        val outBottomRightPropVal = PropertyValuesHolder.ofObject<PointF>(\n            BOTTOM_RIGHT_PROPERTY,\n            null,\n            pathMotion.getPath(\n                startBounds.right.toFloat(), startBounds.bottom.toFloat(),\n                endBounds.right.toFloat(), endBounds.bottom.toFloat())\n        )\n\n        val alphaPropVal = PropertyValuesHolder.ofFloat(ALPHA_PROPERTY, startAlpha, endAlpha)\n\n        bounds.setup()\n\n        bounds.setLeftTopRightBottom(startBounds.left, startBounds.top, startBounds.right, startBounds.bottom)\n\n        return ObjectAnimator.ofPropertyValuesHolder(bounds,\n            outTopLeftPropVal,\n            outBottomRightPropVal,\n            alphaPropVal\n        ).apply {\n            doOnEnd {\n                bounds.setAlpha(originalAlpha)\n                bounds.cleanup()\n            }\n        }\n    }\n\n    class DrawableBounds(view: View) : PointFBounds() {\n        private val drawable = view.drawToBitmap(Bitmap.Config.ARGB_8888).toDrawable(view.resources)\n        private val parent = view.parent as ViewGroup\n\n        override fun setup() {\n            parent.overlay.add(drawable)\n        }\n\n        override fun cleanup() {\n            parent.overlay.remove(drawable)\n        }\n\n        override fun setLeftTopRightBottom(left: Int, top: Int, right: Int, bottom: Int) {\n            drawable.setBounds(left, top, right, bottom)\n        }\n\n        override fun setAlpha(alpha: Float) {\n            drawable.alpha = (alpha * 255).roundToInt().coerceIn(0, 255)\n        }\n\n        override fun getAlpha(): Float {\n            return (drawable.alpha / 255f).coerceIn(0f, 1f)\n        }\n    }\n\n    class ViewBounds(val view: View) : PointFBounds() {\n        override fun setLeftTopRightBottom(left: Int, top: Int, right: Int, bottom: Int) {\n            view.left = left\n            view.top = top\n            view.right = right\n            view.bottom = bottom\n        }\n\n        override fun getAlpha(): Float = view.alpha\n\n        override fun setAlpha(alpha: Float) {\n            view.alpha = alpha\n        }\n    }\n\n    abstract class PointFBounds {\n        private var left: Int = 0\n        private var top: Int = 0\n        private var right: Int = 0\n        private var bottom: Int = 0\n        private var topLeftCalls: Int = 0\n        private var bottomRightCalls: Int = 0\n\n        open fun setup() = Unit\n        open fun cleanup() = Unit\n\n        abstract fun getAlpha(): Float\n        abstract fun setAlpha(alpha: Float)\n\n        fun getTopLeft(): PointF {\n            return PointF(left.toFloat(), top.toFloat())\n        }\n\n        fun setTopLeft(topLeft: PointF) {\n            left = topLeft.x.roundToInt()\n            top = topLeft.y.roundToInt()\n            topLeftCalls++\n            if (topLeftCalls == bottomRightCalls) {\n                setLeftTopRightBottom()\n            }\n        }\n\n        fun getBottomRight(): PointF {\n            return PointF(right.toFloat(), bottom.toFloat())\n        }\n\n        fun setBottomRight(bottomRight: PointF) {\n            right = bottomRight.x.roundToInt()\n            bottom = bottomRight.y.roundToInt()\n            bottomRightCalls++\n            if (topLeftCalls == bottomRightCalls) {\n                setLeftTopRightBottom()\n            }\n        }\n\n        private fun setLeftTopRightBottom() {\n            setLeftTopRightBottom(left, top, right, bottom)\n            topLeftCalls = 0\n            bottomRightCalls = 0\n        }\n\n        abstract fun setLeftTopRightBottom(left: Int, top: Int, right: Int, bottom: Int)\n    }\n\n    companion object {\n        const val PROPNAME_BOUNDS = \"tivi:changeBounds:bounds\"\n        const val PROPNAME_PARENT = \"tivi:changeBounds:parent\"\n        val TRANSITION_PROPS = arrayOf(PROPNAME_BOUNDS, PROPNAME_PARENT)\n\n        val TOP_LEFT_PROPERTY: Property<PointFBounds, PointF> =\n            object : Property<PointFBounds, PointF>(PointF::class.java, \"topLeft\") {\n                override fun set(bounds: PointFBounds, topLeft: PointF) = bounds.setTopLeft(topLeft)\n                override fun get(bounds: PointFBounds): PointF? = bounds.getTopLeft()\n            }\n\n        val BOTTOM_RIGHT_PROPERTY: Property<PointFBounds, PointF> =\n            object : Property<PointFBounds, PointF>(PointF::class.java, \"bottomRight\") {\n                override fun set(\n                    bounds: PointFBounds,\n                    bottomRight: PointF\n                ) = bounds.setBottomRight(bottomRight)\n\n                override fun get(bounds: PointFBounds): PointF? = bounds.getBottomRight()\n            }\n\n        val ALPHA_PROPERTY: Property<PointFBounds, Float> =\n            createFloatProperty(object : FloatProp<PointFBounds>(\"alpha\") {\n                override fun set(o: PointFBounds, value: Float) = o.setAlpha(value)\n                override fun get(o: PointFBounds): Float = o.getAlpha()\n            })\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.transitions\n\nimport android.graphics.drawable.Drawable\nimport android.util.Property\n\nobject DrawableAlphaProperty : Property<Drawable, Int>(Int::class.java, \"drawableAlpha\") {\n    override fun set(d: Drawable, value: Int) {\n        d.alpha = value\n    }\n\n    override fun get(d: Drawable): Int = d.alpha\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.transitions\n\nimport android.view.animation.LinearInterpolator\nimport androidx.fragment.app.Fragment\nimport androidx.interpolator.view.animation.FastOutLinearInInterpolator\nimport androidx.interpolator.view.animation.FastOutSlowInInterpolator\nimport androidx.interpolator.view.animation.LinearOutSlowInInterpolator\nimport androidx.transition.Fade\nimport androidx.transition.Transition\nimport androidx.transition.TransitionListenerAdapter\nimport androidx.transition.TransitionSet\n\nobject GridToGridTransitioner {\n\n    // If you wish to\n    private const val CONTENT_TRANSITION_DURATION = 200L\n\n    private const val RETURN_TRANSITION_FRACTION = 2 / 3f\n    private const val GRID_SHARED_ELEMENT_ENTER_DURATION = CONTENT_TRANSITION_DURATION * 4 / 3\n    private const val GRID_SHARED_ELEMENT_RETURN_DURATION =\n        (GRID_SHARED_ELEMENT_ENTER_DURATION * RETURN_TRANSITION_FRACTION).toLong()\n\n    private val LINEAR_INTERPOLATOR = LinearInterpolator()\n    private val FAST_OUT_SLOW_IN_INTERPOLATOR = FastOutSlowInInterpolator()\n    private val FAST_OUT_LINEAR_IN_INTERPOLATOR = FastOutLinearInInterpolator()\n    private val LINEAR_OUT_SLOW_IN_INTERPOLATOR = LinearOutSlowInInterpolator()\n\n    /**\n     * Setup the first fragment.\n     *\n     * @param fragment The fragment to setup\n     * @param contentFadeElementIds An array of view ids which will transition at the normal rate. This will\n     * typically be your toolbar\n     */\n    fun setupFirstFragment(fragment: Fragment, vararg contentFadeElementIds: Int) {\n        fragment.exitTransition = TransitionSet().apply {\n            addTransition(Fade().apply {\n                contentFadeElementIds.forEach { excludeTarget(it, true) }\n                interpolator = LINEAR_INTERPOLATOR\n                duration = CONTENT_TRANSITION_DURATION / 2\n            })\n            addTransition(Fade().apply {\n                contentFadeElementIds.forEach { addTarget(it) }\n                interpolator = LINEAR_INTERPOLATOR\n                duration = CONTENT_TRANSITION_DURATION\n            })\n        }\n        fragment.reenterTransition = Fade().apply {\n            interpolator = LINEAR_INTERPOLATOR\n            duration = CONTENT_TRANSITION_DURATION\n        }\n    }\n\n    /**\n     * Setup the second fragment.\n     *\n     * @param fragment The fragment to setup\n     * @param fadeElementIds An array of view ids which will fade rather than slide. This will typically be your toolbar\n     */\n    fun setupSecondFragment(\n        fragment: Fragment,\n        vararg fadeElementIds: Int,\n        onTransitionEnd: () -> Unit\n    ) {\n        fragment.sharedElementEnterTransition = ColumnedChangeBounds().apply {\n            interpolator = FAST_OUT_SLOW_IN_INTERPOLATOR\n            duration = GRID_SHARED_ELEMENT_ENTER_DURATION\n        }\n        fragment.sharedElementReturnTransition = ColumnedChangeBounds().apply {\n            interpolator = FAST_OUT_SLOW_IN_INTERPOLATOR\n            duration = GRID_SHARED_ELEMENT_RETURN_DURATION\n        }\n        fragment.enterTransition = TransitionSet().apply {\n            addTransition(Fade().apply {\n                fadeElementIds.forEach { addTarget(it) }\n                interpolator = LINEAR_INTERPOLATOR\n            })\n            addTransition(BabySlide().apply {\n                fadeElementIds.forEach { excludeTarget(it, true) }\n                interpolator = LINEAR_OUT_SLOW_IN_INTERPOLATOR\n            })\n            duration = CONTENT_TRANSITION_DURATION\n            // We want this to end at the same time as the shared element transition so we delay it\n            startDelay = GRID_SHARED_ELEMENT_ENTER_DURATION - CONTENT_TRANSITION_DURATION\n\n            addListener(object : TransitionListenerAdapter() {\n                override fun onTransitionEnd(transition: Transition) {\n                    onTransitionEnd()\n                }\n            })\n        }\n        fragment.returnTransition = TransitionSet().apply {\n            addTransition(Fade().apply {\n                fadeElementIds.forEach { addTarget(it) }\n                interpolator = LINEAR_INTERPOLATOR\n            })\n            addTransition(BabySlide().apply {\n                fadeElementIds.forEach { excludeTarget(it, true) }\n                interpolator = FAST_OUT_LINEAR_IN_INTERPOLATOR\n            })\n            duration = (CONTENT_TRANSITION_DURATION * RETURN_TRANSITION_FRACTION).toLong()\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.transitions\n\nimport android.util.Log\nimport android.view.ViewGroup\nimport java.lang.reflect.InvocationTargetException\nimport java.lang.reflect.Method\n\nprivate var sSuppressLayoutMethod: Method? = null\nprivate var sSuppressLayoutMethodFetched: Boolean = false\n\nfun ViewGroup.suppressLayoutInternal(suppress: Boolean) {\n    if (!sSuppressLayoutMethodFetched) {\n        try {\n            sSuppressLayoutMethod = ViewGroup::class.java.getDeclaredMethod(\"suppressLayout\",\n                Boolean::class.javaPrimitiveType)\n            sSuppressLayoutMethod!!.isAccessible = true\n        } catch (e: NoSuchMethodException) {\n            Log.i(\"ViewGroupTivi\", \"Failed to retrieve suppressLayout method\", e)\n        }\n        sSuppressLayoutMethodFetched = true\n    }\n    if (sSuppressLayoutMethod != null) {\n        try {\n            sSuppressLayoutMethod!!.invoke(this, suppress)\n        } catch (e: IllegalAccessException) {\n            Log.i(\"ViewGroupTivi\", \"Failed to invoke suppressLayout method\", e)\n        } catch (e: InvocationTargetException) {\n            Log.i(\"ViewGroupTivi\", \"Error invoking suppressLayout method\", e)\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.transitions\n\nimport android.animation.Animator\nimport android.animation.ObjectAnimator\nimport android.animation.PropertyValuesHolder\nimport android.view.Gravity\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.transition.TransitionValues\nimport androidx.transition.Visibility\n\nclass BabySlide(\n    private val gravity: Int = Gravity.START,\n    private val babyFraction: Float = 2f\n) : Visibility() {\n\n    override fun onAppear(\n        sceneRoot: ViewGroup,\n        view: View,\n        startValues: TransitionValues?,\n        endValues: TransitionValues?\n    ): Animator {\n        setupTranslation(view)\n        view.alpha = 0f\n\n        return ObjectAnimator.ofPropertyValuesHolder(view,\n            PropertyValuesHolder.ofFloat(View.TRANSLATION_X, 0f),\n            PropertyValuesHolder.ofFloat(View.TRANSLATION_Y, 0f),\n            PropertyValuesHolder.ofFloat(View.ALPHA, 1f))\n    }\n\n    override fun onDisappear(\n        sceneRoot: ViewGroup,\n        view: View,\n        startValues: TransitionValues?,\n        endValues: TransitionValues?\n    ): Animator {\n        return ObjectAnimator.ofPropertyValuesHolder(view,\n            translatePropValForGravity(view),\n            PropertyValuesHolder.ofFloat(View.ALPHA, 0f))\n    }\n\n    private fun translatePropValForGravity(view: View): PropertyValuesHolder =\n        when (Gravity.getAbsoluteGravity(gravity, view.layoutDirection)) {\n            Gravity.TOP -> PropertyValuesHolder.ofFloat(View.TRANSLATION_Y, -view.height / babyFraction)\n            Gravity.RIGHT -> PropertyValuesHolder.ofFloat(View.TRANSLATION_X, view.width / babyFraction)\n            Gravity.BOTTOM -> PropertyValuesHolder.ofFloat(View.TRANSLATION_Y, view.height / babyFraction)\n            else -> PropertyValuesHolder.ofFloat(View.TRANSLATION_X, -view.width / babyFraction)\n        }\n\n    private fun setupTranslation(view: View) {\n        when (Gravity.getAbsoluteGravity(gravity, view.layoutDirection)) {\n            Gravity.TOP -> view.translationY = -view.height / babyFraction\n            Gravity.RIGHT -> view.translationX = view.width / babyFraction\n            Gravity.BOTTOM -> view.translationY = view.width / babyFraction\n            else -> view.translationX = -view.width / babyFraction\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.graphics\n\nimport android.graphics.ColorMatrix\nimport android.util.Property\nimport app.tivi.ui.animations.FloatProp\nimport app.tivi.ui.animations.createFloatProperty\n\n/**\n * An extension to [ColorMatrix] which implements the Material image loading pattern\n */\nclass ImageLoadingColorMatrix : ColorMatrix() {\n    private val elements = FloatArray(20)\n\n    var saturationFraction = 1f\n        set(value) {\n            if (value != field) {\n                System.arraycopy(array, 0, elements, 0, 20)\n\n                // Taken from ColorMatrix.setSaturation. We can't use that though since it resets the matrix\n                // before applying the values\n                val invSat = 1 - value\n                val r = 0.213f * invSat\n                val g = 0.715f * invSat\n                val b = 0.072f * invSat\n\n                elements[0] = r + value\n                elements[1] = g\n                elements[2] = b\n                elements[5] = r\n                elements[6] = g + value\n                elements[7] = b\n                elements[10] = r\n                elements[11] = g\n                elements[12] = b + value\n\n                set(elements)\n            }\n            field = value\n        }\n\n    var alphaFraction = 1f\n        set(value) {\n            if (value != field) {\n                System.arraycopy(array, 0, elements, 0, 20)\n                elements[18] = value\n                set(elements)\n            }\n            field = value\n        }\n\n    var brightnessFraction = 1f\n        set(value) {\n            if (value != field) {\n                System.arraycopy(array, 0, elements, 0, 20)\n\n                // We substract to make the picture look darker, it will automatically clamp\n                val darkening = (1 - value) * 255\n                elements[4] = -darkening\n                elements[9] = -darkening\n                elements[14] = -darkening\n\n                set(elements)\n            }\n            field = value\n        }\n\n    companion object {\n        private val saturationFloatProp: FloatProp<ImageLoadingColorMatrix> = object : FloatProp<ImageLoadingColorMatrix>(\"saturation\") {\n            override operator fun get(o: ImageLoadingColorMatrix): Float = o.saturationFraction\n            override operator fun set(o: ImageLoadingColorMatrix, value: Float) {\n                o.saturationFraction = value\n            }\n        }\n\n        private val alphaFloatProp: FloatProp<ImageLoadingColorMatrix> = object : FloatProp<ImageLoadingColorMatrix>(\"alpha\") {\n            override operator fun get(o: ImageLoadingColorMatrix): Float = o.alphaFraction\n            override operator fun set(o: ImageLoadingColorMatrix, value: Float) {\n                o.alphaFraction = value\n            }\n        }\n\n        private val brightnessFloatProp: FloatProp<ImageLoadingColorMatrix> = object : FloatProp<ImageLoadingColorMatrix>(\"darken\") {\n            override operator fun get(o: ImageLoadingColorMatrix): Float = o.brightnessFraction\n            override operator fun set(o: ImageLoadingColorMatrix, value: Float) {\n                o.brightnessFraction = value\n            }\n        }\n\n        val PROP_SATURATION: Property<ImageLoadingColorMatrix, Float> = createFloatProperty(saturationFloatProp)\n        val PROP_ALPHA: Property<ImageLoadingColorMatrix, Float> = createFloatProperty(alphaFloatProp)\n        val PROP_BRIGHTNESS: Property<ImageLoadingColorMatrix, Float> = createFloatProperty(brightnessFloatProp)\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport android.graphics.Outline\nimport android.view.View\nimport android.view.ViewOutlineProvider\nimport app.tivi.common.ui.R\n\nobject RoundRectViewOutline : ViewOutlineProvider() {\n    override fun getOutline(view: View, outline: Outline) {\n        val radius = view.resources.getDimension(R.dimen.image_round_rect_radius)\n        outline.setRoundRect(0, 0, view.width, view.height, radius)\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui\n\nimport android.view.View\nimport android.view.WindowInsets\n\nobject NoopApplyWindowInsetsListener : View.OnApplyWindowInsetsListener {\n    override fun onApplyWindowInsets(view: View, insets: WindowInsets): WindowInsets = insets\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.animations\n\nimport android.animation.Animator\nimport android.animation.AnimatorSet\nimport android.animation.ObjectAnimator\nimport android.graphics.ColorMatrixColorFilter\nimport android.graphics.drawable.Drawable\nimport android.view.View\nimport androidx.core.animation.doOnEnd\nimport androidx.interpolator.view.animation.FastOutSlowInInterpolator\nimport app.tivi.ui.graphics.ImageLoadingColorMatrix\nimport kotlin.math.roundToLong\n\nprivate val fastOutSlowInInterpolator = FastOutSlowInInterpolator()\n\nfun saturateDrawableAnimator(\n    current: Drawable,\n    duration: Long = SATURATION_ANIMATION_DURATION,\n    view: View? = null\n): Animator {\n    current.mutate()\n    view?.setHasTransientState(true)\n\n    val cm = ImageLoadingColorMatrix()\n\n    val satAnim = ObjectAnimator.ofFloat(cm, ImageLoadingColorMatrix.PROP_SATURATION, 0f, 1f)\n    satAnim.duration = duration\n    satAnim.addUpdateListener {\n        current.colorFilter = ColorMatrixColorFilter(cm)\n    }\n\n    val alphaAnim = ObjectAnimator.ofFloat(cm, ImageLoadingColorMatrix.PROP_ALPHA, 0f, 1f)\n    alphaAnim.duration = duration / 2\n\n    val darkenAnim = ObjectAnimator.ofFloat(cm, ImageLoadingColorMatrix.PROP_BRIGHTNESS, 0.8f, 1f)\n    darkenAnim.duration = (duration * 0.75f).roundToLong()\n\n    return AnimatorSet().apply {\n        playTogether(satAnim, alphaAnim, darkenAnim)\n        interpolator = fastOutSlowInInterpolator\n        doOnEnd {\n            current.clearColorFilter()\n            view?.setHasTransientState(false)\n        }\n    }\n}\n\nconst val SATURATION_ANIMATION_DURATION = 1000L",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.animations\n\nimport android.os.Build\nimport android.util.FloatProperty\nimport android.util.Property\n\n/**\n * A delegate for creating a [Property] of `float` type.\n */\nabstract class FloatProp<T>(val name: String) {\n    abstract operator fun set(o: T, value: Float)\n    abstract operator fun get(o: T): Float\n}\n\nfun <T> createFloatProperty(impl: FloatProp<T>): Property<T, Float> {\n    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n        object : FloatProperty<T>(impl.name) {\n            override fun get(o: T): Float = impl[o]\n\n            override fun setValue(o: T, value: Float) {\n                impl[o] = value\n            }\n        }\n    } else {\n        object : Property<T, Float>(Float::class.java, impl.name) {\n            override fun get(o: T): Float = impl[o]\n\n            override fun set(o: T, value: Float) {\n                impl[o] = value\n            }\n        }\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.ui.animations\n\nfun lerp(\n    startValue: Float,\n    endValue: Float,\n    fraction: Float\n) = startValue + fraction * (endValue - startValue)",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.home\n\nimport android.content.Context\nimport android.content.res.Resources\nimport android.graphics.Typeface\nimport androidx.core.content.res.ResourcesCompat\nimport androidx.core.text.buildSpannedString\nimport androidx.core.text.inSpans\nimport androidx.core.text.parseAsHtml\nimport app.tivi.common.ui.R\nimport app.tivi.data.entities.TiviShow\nimport app.tivi.data.views.FollowedShowsWatchStats\nimport app.tivi.inject.PerActivity\nimport app.tivi.ui.text.TypefaceSpan\nimport app.tivi.ui.text.textAppearanceSpanForAttribute\nimport javax.inject.Inject\n\nclass HomeTextCreator @Inject constructor(\n    @PerActivity private val context: Context\n) {\n    private var bodyTypeface: Typeface = Typeface.DEFAULT\n        get() {\n            if (field == Typeface.DEFAULT) {\n                try {\n                    ResourcesCompat.getFont(context, R.font.rubik_400)?.also { field = it }\n                } catch (nfe: Resources.NotFoundException) {\n                    // getFont will throw a NFE if the device if offline or doesn't have\n                    // Play Services. Lets not crash\n                }\n            }\n            return field\n        }\n\n    @JvmOverloads\n    fun showTitle(\n        context: Context = this.context,\n        show: TiviShow\n    ): CharSequence = buildSpannedString {\n        append(show.title)\n\n        show.firstAired?.also { firstAired ->\n            append(\" \")\n            inSpans(textAppearanceSpanForAttribute(context, R.attr.textAppearanceCaption),\n                TypefaceSpan(bodyTypeface)) {\n                append(\"(\")\n                append(firstAired.year.toString())\n                append(\")\")\n            }\n        }\n    }\n\n    fun showHeaderCount(count: Int, filtered: Boolean = false): CharSequence = when {\n        filtered -> context.resources.getQuantityString(R.plurals.header_show_count_filtered, count, count)\n        else -> context.resources.getQuantityString(R.plurals.header_show_count, count, count)\n    }.parseAsHtml()\n\n    fun followedShowEpisodeWatchStatus(stats: FollowedShowsWatchStats?): CharSequence {\n        return if (stats != null && stats.watchedEpisodeCount < stats.episodeCount) {\n            context.getString(R.string.followed_watch_stats_to_watch,\n                stats.episodeCount - stats.watchedEpisodeCount).parseAsHtml()\n        } else if (stats != null && stats.watchedEpisodeCount > 0) {\n            context.getString(R.string.followed_watch_stats_complete)\n        } else {\n            return \"\"\n        }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\nimport app.tivi.data.entities.TiviShow\nimport kotlinx.coroutines.channels.ConflatedBroadcastChannel\nimport kotlinx.coroutines.channels.sendBlocking\nimport kotlinx.coroutines.flow.asFlow\n\nclass ShowStateSelector {\n    private var selectedShowIds: Set<Long> = emptySet()\n    private val selectedShowIdsChannel = ConflatedBroadcastChannel(selectedShowIds)\n\n    private var isSelectionOpen = false\n    private val isSelectionOpenChannel = ConflatedBroadcastChannel(isSelectionOpen)\n\n    fun observeSelectedShowIds() = selectedShowIdsChannel.asFlow()\n\n    fun observeIsSelectionOpen() = isSelectionOpenChannel.asFlow()\n\n    fun getSelectedShowIds() = selectedShowIdsChannel.value\n\n    fun onItemClick(show: TiviShow): Boolean {\n        if (isSelectionOpen) {\n            val currentSelection = when {\n                show.id in selectedShowIds -> selectedShowIds.minus(show.id)\n                else -> selectedShowIds.plus(show.id)\n            }\n            isSelectionOpen = currentSelection.isNotEmpty()\n            selectedShowIds = currentSelection\n            dispatch()\n            return true\n        }\n        return false\n    }\n\n    fun onItemLongClick(show: TiviShow): Boolean {\n        if (!isSelectionOpen) {\n            isSelectionOpen = true\n\n            var currentSelection = selectedShowIds\n            if (show.id !in currentSelection) {\n                currentSelection = currentSelection.plus(show.id)\n            }\n\n            isSelectionOpen = currentSelection.isNotEmpty()\n            selectedShowIds = currentSelection\n            dispatch()\n            return true\n        }\n        return false\n    }\n\n    fun clearSelection() {\n        selectedShowIds = emptySet()\n        isSelectionOpen = false\n        dispatch()\n    }\n\n    private fun dispatch() {\n        selectedShowIdsChannel.sendBlocking(selectedShowIds)\n        isSelectionOpenChannel.sendBlocking(isSelectionOpen)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\nimport app.tivi.base.InvokeError\nimport app.tivi.base.InvokeStarted\nimport app.tivi.base.InvokeStatus\nimport app.tivi.base.InvokeSuccess\nimport app.tivi.base.InvokeTimeout\nimport java.util.concurrent.atomic.AtomicInteger\nimport kotlinx.coroutines.channels.ConflatedBroadcastChannel\nimport kotlinx.coroutines.channels.sendBlocking\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.asFlow\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.map\n\nclass ObservableLoadingCounter {\n    private val count = AtomicInteger()\n    private val loadingState = ConflatedBroadcastChannel(count.get())\n\n    val observable: Flow<Boolean>\n        get() = loadingState.asFlow().map { it > 0 }\n\n    fun addLoader() {\n        loadingState.sendBlocking(count.incrementAndGet())\n    }\n\n    fun removeLoader() {\n        loadingState.sendBlocking(count.decrementAndGet())\n    }\n}\n\nsuspend fun ObservableLoadingCounter.collectFrom(statuses: Flow<InvokeStatus>) {\n    statuses.collect {\n        if (it == InvokeStarted) {\n            addLoader()\n        } else if (it == InvokeSuccess || it == InvokeTimeout || it is InvokeError) {\n            removeLoader()\n        }\n    }\n}",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi\n\nimport android.app.Activity\nimport android.content.Intent\nimport android.os.Bundle\nimport androidx.core.view.doOnPreDraw\nimport app.tivi.util.Logger\nimport dagger.android.support.DaggerAppCompatActivity\nimport javax.inject.Inject\n\nabstract class TiviActivity : DaggerAppCompatActivity() {\n    // Dummy injection\n    @Inject lateinit var logger: Logger\n\n    private var postponedTransition = false\n\n    override fun onPostCreate(savedInstanceState: Bundle?) {\n        super.onPostCreate(savedInstanceState)\n        handleIntent(intent)\n    }\n\n    override fun onNewIntent(intent: Intent) {\n        super.onNewIntent(intent)\n        handleIntent(intent)\n    }\n\n    override fun postponeEnterTransition() {\n        super.postponeEnterTransition()\n        postponedTransition = true\n    }\n\n    override fun startPostponedEnterTransition() {\n        postponedTransition = false\n        super.startPostponedEnterTransition()\n    }\n\n    fun scheduleStartPostponedTransitions() {\n        if (postponedTransition) {\n            window.decorView.doOnPreDraw {\n                startPostponedEnterTransition()\n            }\n        }\n    }\n\n    open fun handleIntent(intent: Intent) {}\n\n    override fun finishAfterTransition() {\n        val resultData = Intent()\n        val result = onPopulateResultIntent(resultData)\n        setResult(result, resultData)\n\n        super.finishAfterTransition()\n    }\n\n    open fun onPopulateResultIntent(intent: Intent): Int = Activity.RESULT_OK\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport android.animation.Animator\nimport android.animation.AnimatorListenerAdapter\nimport android.animation.AnimatorSet\nimport kotlin.coroutines.resume\nimport kotlinx.coroutines.suspendCancellableCoroutine\n\nfun animatorSetOf(vararg animators: Animator, playTogether: Boolean = true) = AnimatorSet().apply {\n    if (playTogether) {\n        playTogether(*animators)\n    } else {\n        playSequentially(*animators)\n    }\n}\n\nfun animatorSetOf(animators: List<Animator>, playTogether: Boolean = true) = AnimatorSet().apply {\n    if (playTogether) {\n        playTogether(animators)\n    } else {\n        playSequentially(animators)\n    }\n}\n\nsuspend fun Animator.awaitEnd() = suspendCancellableCoroutine<Unit> { cont ->\n    // Add an invokeOnCancellation listener. If the coroutine is\n    // cancelled, cancel the animation too that will notify\n    // listener's onAnimationCancel() function\n    cont.invokeOnCancellation { cancel() }\n\n    addListener(object : AnimatorListenerAdapter() {\n        private var endedSuccessfully = true\n\n        override fun onAnimationCancel(animation: Animator) {\n            // Animator has been cancelled, so flip the success flag\n            endedSuccessfully = false\n        }\n\n        override fun onAnimationEnd(animation: Animator) {\n            // Make sure we remove the listener so we don't keep leak the coroutine continuation\n            animation.removeListener(this)\n\n            if (cont.isActive) {\n                // If the coroutine is still active...\n                if (endedSuccessfully) {\n                    // ..and the Animator ended successfully, resume the coroutine\n                    cont.resume(Unit)\n                } else {\n                    // ...and the Animator was cancelled, cancel the coroutine too\n                    cont.cancel()\n                }\n            }\n        }\n    })\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport android.view.ViewGroup\nimport androidx.core.view.doOnNextLayout\nimport androidx.core.view.doOnPreDraw\nimport androidx.fragment.app.Fragment\nimport app.tivi.TiviActivity\nimport java.util.concurrent.TimeUnit\n\nfun Fragment.scheduleStartPostponedTransitions() {\n    view?.doOnNextLayout {\n        (it.parent as? ViewGroup)?.doOnPreDraw {\n            startPostponedEnterTransition()\n        }\n    }\n\n    val activity = activity\n    if (activity is TiviActivity) {\n        activity.scheduleStartPostponedTransitions()\n    }\n}\n\nfun Fragment.postponeEnterTransitionWithTimeout(timeoutMs: Long = 5000) {\n    postponeEnterTransition(timeoutMs, TimeUnit.MILLISECONDS)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.content.res.ColorStateList\nimport android.graphics.Color\nimport android.graphics.drawable.Drawable\nimport androidx.annotation.AttrRes\nimport androidx.core.content.res.getDimensionPixelSizeOrThrow\nimport androidx.core.content.res.getResourceIdOrThrow\nimport androidx.core.content.res.use\n\n@SuppressLint(\"Recycle\")\nfun Context.resolveThemeColor(@AttrRes resId: Int, defaultColor: Int = Color.MAGENTA): Int {\n    return obtainStyledAttributes(intArrayOf(resId)).use {\n        it.getColor(0, defaultColor)\n    }\n}\n\n@SuppressLint(\"Recycle\")\nfun Context.resolveThemeColorStateList(@AttrRes resId: Int): ColorStateList? {\n    return obtainStyledAttributes(intArrayOf(resId)).use {\n        it.getColorStateList(0)\n    }\n}\n\n@SuppressLint(\"Recycle\")\nfun Context.resolveThemeReferenceResId(@AttrRes resId: Int): Int {\n    return obtainStyledAttributes(intArrayOf(resId)).use {\n        it.getResourceIdOrThrow(0)\n    }\n}\n\n@SuppressLint(\"Recycle\")\nfun Context.resolveThemeDimensionPixelSize(@AttrRes resId: Int): Int {\n    return obtainStyledAttributes(intArrayOf(resId)).use {\n        it.getDimensionPixelSizeOrThrow(0)\n    }\n}\n\n@SuppressLint(\"Recycle\")\nfun Context.resolveThemeDrawable(@AttrRes resId: Int): Drawable? {\n    return obtainStyledAttributes(intArrayOf(resId)).use { it.getDrawable(0) }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport android.graphics.Rect\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.core.view.OneShotPreDrawListener\nimport androidx.transition.AutoTransition\nimport androidx.transition.TransitionManager\nimport kotlin.coroutines.resume\nimport kotlinx.coroutines.suspendCancellableCoroutine\n\nfun ViewGroup.beginDelayedTransition(duration: Long = 200) {\n    TransitionManager.beginDelayedTransition(this, AutoTransition().apply { setDuration(duration) })\n}\n\nfun View.getBounds(rect: Rect) {\n    rect.set(left, top, right, bottom)\n}\n\n/**\n * Call [View.requestApplyInsets] in a safe away. If we're attached it calls it straight-away.\n * If not it sets an [View.OnAttachStateChangeListener] and waits to be attached before calling\n * [View.requestApplyInsets].\n */\nfun View.requestApplyInsetsWhenAttached() = doOnAttach {\n    it.requestApplyInsets()\n}\n\nfun View.doOnAttach(f: (View) -> Unit) {\n    if (isAttachedToWindow) {\n        f(this)\n    } else {\n        addOnAttachStateChangeListener(object : View.OnAttachStateChangeListener {\n            override fun onViewAttachedToWindow(v: View) {\n                f(v)\n                removeOnAttachStateChangeListener(this)\n            }\n\n            override fun onViewDetachedFromWindow(v: View) {\n                removeOnAttachStateChangeListener(this)\n            }\n        })\n    }\n}\n\n/**\n * Allows easy listening to layout passing. Return [true] if you need the listener to keep being\n * attached.\n */\ninline fun <V : View> V.doOnLayouts(crossinline action: (view: V) -> Boolean) {\n    addOnLayoutChangeListener(object : View.OnLayoutChangeListener {\n        @Suppress(\"UNCHECKED_CAST\")\n        override fun onLayoutChange(\n            view: View,\n            left: Int,\n            top: Int,\n            right: Int,\n            bottom: Int,\n            oldLeft: Int,\n            oldTop: Int,\n            oldRight: Int,\n            oldBottom: Int\n        ) {\n            if (!action(view as V)) {\n                view.removeOnLayoutChangeListener(this)\n            }\n        }\n    })\n}\n\n/**\n * Allows easy listening to layout passing. Return [true] if you need the listener to keep being\n * attached.\n */\ninline fun View.doOnSizeChange(crossinline action: (view: View) -> Boolean) {\n    addOnLayoutChangeListener(object : View.OnLayoutChangeListener {\n        override fun onLayoutChange(\n            view: View,\n            left: Int,\n            top: Int,\n            right: Int,\n            bottom: Int,\n            oldLeft: Int,\n            oldTop: Int,\n            oldRight: Int,\n            oldBottom: Int\n        ) {\n            if ((bottom - top) != (oldBottom - oldTop) || (right - left) != (oldRight - oldLeft)) {\n                if (!action(view)) {\n                    view.removeOnLayoutChangeListener(this)\n                }\n            }\n        }\n    })\n}\n\nsuspend fun View.awaitNextLayout() = suspendCancellableCoroutine<Unit> { cont ->\n    val listener = object : View.OnLayoutChangeListener {\n        override fun onLayoutChange(\n            view: View,\n            left: Int,\n            top: Int,\n            right: Int,\n            bottom: Int,\n            oldLeft: Int,\n            oldTop: Int,\n            oldRight: Int,\n            oldBottom: Int\n        ) {\n            // Remove the listener\n            view.removeOnLayoutChangeListener(this)\n            // And resume the continuation\n            cont.resume(Unit)\n        }\n    }\n    // If the coroutine is cancelled, remove the listener\n    cont.invokeOnCancellation { removeOnLayoutChangeListener(listener) }\n    // And finally add the listener to view\n    addOnLayoutChangeListener(listener)\n}\n\nsuspend fun View.awaitLayout() {\n    if (!isLaidOut) {\n        awaitNextLayout()\n    }\n}\n\nsuspend fun View.awaitPreDraw() = suspendCancellableCoroutine<Unit> { cont ->\n    val listener = OneShotPreDrawListener.add(this) {\n        cont.resume(Unit)\n    }\n    // If the coroutine is cancelled, remove the listener\n    cont.invokeOnCancellation {\n        listener.removeListener()\n    }\n}\n\nsuspend fun View.awaitAnimationFrame() = suspendCancellableCoroutine<Unit> { cont ->\n    val runnable = Runnable {\n        cont.resume(Unit)\n    }\n    // If the coroutine is cancelled, remove the callback\n    cont.invokeOnCancellation { removeCallbacks(runnable) }\n    // And finally post the runnable\n    postOnAnimation(runnable)\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport android.content.Intent\nimport android.util.SparseArray\nimport androidx.core.util.forEach\nimport androidx.core.util.set\nimport androidx.fragment.app.FragmentManager\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MutableLiveData\nimport androidx.navigation.NavController\nimport androidx.navigation.fragment.NavHostFragment\nimport app.tivi.common.ui.R\nimport com.google.android.material.bottomnavigation.BottomNavigationView\n\n/**\n * Manages the various graphs needed for a [BottomNavigationView].\n *\n * This sample is a workaround until the Navigation Component supports multiple back stacks.\n */\nfun BottomNavigationView.setupWithNavController(\n    navGraphIds: List<Int>,\n    fragmentManager: FragmentManager,\n    containerId: Int,\n    intent: Intent? = null\n): LiveData<NavController> {\n\n    // Map of tags\n    val graphIdToTagMap = SparseArray<String>()\n    // Result. Mutable live data with the selected controlled\n    val selectedNavController = MutableLiveData<NavController>()\n\n    var firstFragmentGraphId = 0\n\n    // First create a NavHostFragment for each NavGraph ID\n    navGraphIds.forEachIndexed { index, navGraphId ->\n        val fragmentTag = getFragmentTag(index)\n\n        // Find or create the Navigation host fragment\n        val navHostFragment = obtainNavHostFragment(\n            fragmentManager,\n            fragmentTag,\n            navGraphId,\n            containerId\n        )\n\n        // Obtain its id\n        val graphId = navHostFragment.navController.graph.id\n\n        if (index == 0) {\n            firstFragmentGraphId = graphId\n        }\n\n        // Save to the map\n        graphIdToTagMap[graphId] = fragmentTag\n\n        // Attach or detach nav host fragment depending on whether it's the selected item.\n        if (this.selectedItemId == graphId) {\n            // Update livedata with the selected graph\n            selectedNavController.value = navHostFragment.navController\n            attachNavHostFragment(fragmentManager, navHostFragment, index == 0)\n        } else {\n            detachNavHostFragment(fragmentManager, navHostFragment)\n        }\n    }\n\n    // Now connect selecting an item with swapping Fragments\n    var selectedItemTag = graphIdToTagMap[this.selectedItemId]\n    val firstFragmentTag = graphIdToTagMap[firstFragmentGraphId]\n    var isOnFirstFragment = selectedItemTag == firstFragmentTag\n\n    // When a navigation item is selected\n    setOnNavigationItemSelectedListener { item ->\n        // Don't do anything if the state is state has already been saved.\n        if (fragmentManager.isStateSaved) {\n            false\n        } else {\n            val newlySelectedItemTag = graphIdToTagMap[item.itemId]\n            if (selectedItemTag != newlySelectedItemTag) {\n                // Pop everything above the first fragment (the \"fixed start destination\")\n                fragmentManager.popBackStack(firstFragmentTag,\n                    FragmentManager.POP_BACK_STACK_INCLUSIVE)\n                val selectedFragment = fragmentManager.findFragmentByTag(newlySelectedItemTag)\n                    as NavHostFragment\n\n                // Exclude the first fragment tag because it's always in the back stack.\n                if (firstFragmentTag != newlySelectedItemTag) {\n                    // Commit a transaction that cleans the back stack and adds the first fragment\n                    // to it, creating the fixed started destination.\n                    fragmentManager.beginTransaction()\n                        .setCustomAnimations(R.anim.tivi_enter_anim, R.anim.tivi_exit_anim,\n                            R.anim.tivi_pop_enter_anim, R.anim.tivi_pop_exit_anim)\n                        .attach(selectedFragment)\n                        .setPrimaryNavigationFragment(selectedFragment)\n                        .apply {\n                            // Detach all other Fragments\n                            graphIdToTagMap.forEach { _, fragmentTagIter ->\n                                if (fragmentTagIter != newlySelectedItemTag) {\n                                    detach(fragmentManager.findFragmentByTag(firstFragmentTag)!!)\n                                }\n                            }\n                        }\n                        .addToBackStack(firstFragmentTag)\n                        .setReorderingAllowed(true)\n                        .commit()\n                }\n                selectedItemTag = newlySelectedItemTag\n                isOnFirstFragment = selectedItemTag == firstFragmentTag\n                selectedNavController.value = selectedFragment.navController\n                true\n            } else {\n                false\n            }\n        }\n    }\n\n    // Optional: on item reselected, pop back stack to the destination of the graph\n    setupItemReselected(graphIdToTagMap, fragmentManager)\n\n    // Handle deep link\n    if (intent != null) {\n        setupDeepLinks(navGraphIds, fragmentManager, containerId, intent)\n    }\n\n    // Finally, ensure that we update our BottomNavigationView when the back stack changes\n    fragmentManager.addOnBackStackChangedListener {\n        if (!isOnFirstFragment && !fragmentManager.isOnBackStack(firstFragmentTag)) {\n            this.selectedItemId = firstFragmentGraphId\n        }\n\n        // Reset the graph if the currentDestination is not valid (happens when the back\n        // stack is popped after using the back button).\n        selectedNavController.value?.let { controller ->\n            if (controller.currentDestination == null) {\n                controller.navigate(controller.graph.id)\n            }\n        }\n    }\n    return selectedNavController\n}\n\nprivate fun BottomNavigationView.setupDeepLinks(\n    navGraphIds: List<Int>,\n    fragmentManager: FragmentManager,\n    containerId: Int,\n    intent: Intent\n) {\n    navGraphIds.forEachIndexed { index, navGraphId ->\n        val fragmentTag = getFragmentTag(index)\n\n        // Find or create the Navigation host fragment\n        val navHostFragment = obtainNavHostFragment(\n            fragmentManager,\n            fragmentTag,\n            navGraphId,\n            containerId\n        )\n        // Handle Intent\n        if (selectedItemId != navHostFragment.navController.graph.id &&\n            navHostFragment.navController.handleDeepLink(intent)) {\n            selectedItemId = navHostFragment.navController.graph.id\n        }\n    }\n}\n\nprivate fun BottomNavigationView.setupItemReselected(\n    graphIdToTagMap: SparseArray<String>,\n    fragmentManager: FragmentManager\n) {\n    setOnNavigationItemReselectedListener { item ->\n        val newlySelectedItemTag = graphIdToTagMap[item.itemId]\n        val selectedFragment = fragmentManager.findFragmentByTag(newlySelectedItemTag)\n            as NavHostFragment\n        val navController = selectedFragment.navController\n        // Pop the back stack to the start destination of the current navController graph\n        navController.popBackStack(\n            navController.graph.startDestination, false\n        )\n    }\n}\n\nprivate fun detachNavHostFragment(\n    fragmentManager: FragmentManager,\n    navHostFragment: NavHostFragment\n) {\n    fragmentManager.beginTransaction()\n        .detach(navHostFragment)\n        .commitNow()\n}\n\nprivate fun attachNavHostFragment(\n    fragmentManager: FragmentManager,\n    navHostFragment: NavHostFragment,\n    isPrimaryNavFragment: Boolean\n) {\n    fragmentManager.beginTransaction()\n        .attach(navHostFragment)\n        .apply {\n            if (isPrimaryNavFragment) {\n                setPrimaryNavigationFragment(navHostFragment)\n            }\n        }\n        .commitNow()\n}\n\nprivate fun obtainNavHostFragment(\n    fragmentManager: FragmentManager,\n    fragmentTag: String,\n    navGraphId: Int,\n    containerId: Int\n): NavHostFragment {\n    // If the Nav Host fragment exists, return it\n    val existingFragment = fragmentManager.findFragmentByTag(fragmentTag) as NavHostFragment?\n    existingFragment?.let { return it }\n\n    // Otherwise, create it and return it.\n    val navHostFragment = NavHostFragment.create(navGraphId)\n    fragmentManager.beginTransaction()\n        .add(containerId, navHostFragment, fragmentTag)\n        .commitNow()\n    return navHostFragment\n}\n\nprivate fun FragmentManager.isOnBackStack(backStackName: String): Boolean {\n    val backStackCount = backStackEntryCount\n    for (index in 0 until backStackCount) {\n        if (getBackStackEntryAt(index).name == backStackName) {\n            return true\n        }\n    }\n    return false\n}\n\nprivate fun getFragmentTag(index: Int) = \"bottomNavigation#$index\"",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport android.view.ViewGroup\nimport androidx.recyclerview.widget.LinearSmoothScroller\nimport androidx.recyclerview.widget.RecyclerView\nimport app.tivi.ui.recyclerview.TiviLinearSmoothScroller\nimport kotlin.coroutines.resume\nimport kotlinx.coroutines.suspendCancellableCoroutine\n\nfun <VH : RecyclerView.ViewHolder> RecyclerView.Adapter<VH>.createAndBind(\n    parent: ViewGroup,\n    position: Int\n): VH {\n    val vh = onCreateViewHolder(parent, getItemViewType(position))\n    onBindViewHolder(vh, position)\n    return vh\n}\n\nfun RecyclerView.scrollToItemId(itemId: Long, animatedScroll: Boolean = false): Boolean {\n    val vh = findViewHolderForItemId(itemId)\n    if (vh != null) {\n        if (animatedScroll) {\n            smoothScrollToViewHolder(vh)\n        } else {\n            scrollToPosition(vh.adapterPosition)\n        }\n        return true\n    }\n    return false\n}\n\nfun RecyclerView.smoothScrollToViewHolder(vh: RecyclerView.ViewHolder) = TiviLinearSmoothScroller(\n    context,\n    snapPreference = LinearSmoothScroller.SNAP_TO_START,\n    scrollMsPerInch = 60f\n).apply {\n    targetPosition = vh.adapterPosition\n    targetOffset = vh.itemView.height / 3\n}.also {\n    layoutManager!!.startSmoothScroll(it)\n}\n\nfun RecyclerView.smoothScrollToItemPosition(position: Int) = TiviLinearSmoothScroller(\n    context,\n    snapPreference = LinearSmoothScroller.SNAP_TO_START,\n    scrollMsPerInch = 60f\n).apply {\n    targetPosition = position\n}.also {\n    layoutManager!!.startSmoothScroll(it)\n}\n\nsuspend fun RecyclerView.awaitScrollEnd() {\n    // If a smooth scroll has just been started, it won't actually start until the next\n    // animation frame, so we'll await that first\n    awaitAnimationFrame()\n    // Now we can check if we're actually idle. If so, return now\n    if (scrollState == RecyclerView.SCROLL_STATE_IDLE) return\n\n    suspendCancellableCoroutine<Unit> { cont ->\n        cont.invokeOnCancellation {\n            // If the coroutine is cancelled, stop the RecyclerView scrolling\n            stopScroll()\n        }\n\n        addOnScrollListener(object : RecyclerView.OnScrollListener() {\n            override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {\n                if (newState == RecyclerView.SCROLL_STATE_IDLE) {\n                    // Make sure we remove the listener so we don't keep leak the\n                    // coroutine continuation\n                    recyclerView.removeOnScrollListener(this)\n                    // Finally, resume the coroutine\n                    cont.resume(Unit)\n                }\n            }\n        })\n    }\n}\n\n/**\n * Finds the first item with the given [itemId] in the data set, or [RecyclerView.NO_POSITION] if\n * there is no item with the id.\n */\nfun <VH : RecyclerView.ViewHolder> RecyclerView.Adapter<VH>.findItemIdPosition(itemId: Long): Int {\n    return (0 until itemCount).firstOrNull { getItemId(it) == itemId } ?: RecyclerView.NO_POSITION\n}\n\n/**\n * Await an item in the data set with the given [itemId], and return its adapter position.\n */\nsuspend fun <VH : RecyclerView.ViewHolder> RecyclerView.Adapter<VH>.awaitItemIdExists(itemId: Long): Int {\n    val currentPos = findItemIdPosition(itemId)\n    // If the item is already in the data set, return the position now\n    if (currentPos >= 0) return currentPos\n\n    // Otherwise we register a data set observer and wait for the item ID to be added\n    return suspendCancellableCoroutine { cont ->\n        val observer = object : RecyclerView.AdapterDataObserver() {\n            override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {\n                (positionStart until positionStart + itemCount).forEach { position ->\n                    // Iterate through the new items and check if any have our itemId\n                    if (getItemId(position) == itemId) {\n                        // Remove this observer so we don't leak the coroutine\n                        unregisterAdapterDataObserver(this)\n                        // And resume the coroutine\n                        cont.resume(position)\n                    }\n                }\n            }\n        }\n        // If the coroutine is cancelled, remove the observer\n        cont.invokeOnCancellation { unregisterAdapterDataObserver(observer) }\n        // And finally register the observer\n        registerAdapterDataObserver(observer)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport androidx.constraintlayout.motion.widget.MotionLayout\nimport androidx.constraintlayout.motion.widget.TransitionAdapter\nimport androidx.constraintlayout.widget.ConstraintSet\nimport app.tivi.ui.widget.TiviMotionLayout\nimport kotlin.coroutines.resume\nimport kotlinx.coroutines.CancellationException\nimport kotlinx.coroutines.TimeoutCancellationException\nimport kotlinx.coroutines.suspendCancellableCoroutine\nimport kotlinx.coroutines.withTimeout\n\n/**\n * Applies the given function over each [ConstraintSet]\n */\ninline fun MotionLayout.updateConstraintSets(f: ConstraintSet.() -> Unit) {\n    for (id in constraintSetIds) {\n        updateState(id, getConstraintSet(id).apply { f() })\n    }\n}\n\n/**\n * Wait for the transition to complete so that the given [transitionId] is fully displayed.\n *\n * @param transitionId The transition set to await the completion of\n * @param timeout Timeout for the transition to take place. Defaults to 5 seconds.\n */\nsuspend fun TiviMotionLayout.awaitTransitionComplete(transitionId: Int, timeout: Long = 5000L) {\n    // If we're already at the specified state, return now\n    if (currentState == transitionId) return\n\n    var listener: MotionLayout.TransitionListener? = null\n\n    try {\n        withTimeout(timeout) {\n            suspendCancellableCoroutine<Unit> { cont ->\n                val l = object : TransitionAdapter() {\n                    override fun onTransitionCompleted(motionLayout: MotionLayout, currentId: Int) {\n                        if (currentId == transitionId) {\n                            removeTransitionListener(this)\n                            cont.resume(Unit)\n                        }\n                    }\n                }\n                // If the coroutine is cancelled, remove the listener\n                cont.invokeOnCancellation {\n                    removeTransitionListener(l)\n                }\n                // And finally add the listener\n                addTransitionListener(l)\n                listener = l\n            }\n        }\n    } catch (tex: TimeoutCancellationException) {\n        // Transition didn't happen in time. Remove our listener and throw a cancellation\n        // exception to let the coroutine know\n        listener?.let(::removeTransitionListener)\n        throw CancellationException(\"Transition to state with id: $transitionId did not\" +\n            \" complete in timeout.\", tex)\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport android.app.Activity\nimport android.os.Bundle\nimport android.view.View\nimport androidx.core.app.ActivityOptionsCompat\nimport androidx.core.util.Pair\nimport androidx.fragment.app.FragmentTransaction\nimport androidx.navigation.ActivityNavigatorExtras\nimport androidx.navigation.Navigator\nimport androidx.navigation.fragment.FragmentNavigator\nimport app.tivi.SharedElementHelper\n\nfun SharedElementHelper.toBundle(activity: Activity): Bundle? {\n    return toActivityOptions(activity)?.toBundle()\n}\n\nfun SharedElementHelper.toActivityOptions(activity: Activity): ActivityOptionsCompat? {\n    if (!isEmpty()) {\n        return ActivityOptionsCompat.makeSceneTransitionAnimation(\n            activity,\n            *sharedElements.map { Pair(it.key, it.value) }.toTypedArray()\n        )\n    }\n    return null\n}\n\nfun SharedElementHelper.applyToTransaction(tx: FragmentTransaction) {\n    for ((view, customTransitionName) in sharedElements) {\n        tx.addSharedElement(view, customTransitionName!!)\n    }\n}\n\nfun SharedElementHelper.toFragmentNavigatorExtras(): Navigator.Extras {\n    return FragmentNavigator.Extras.Builder()\n        .addSharedElements(sharedElements)\n        .build()\n}\n\nfun SharedElementHelper.toActivityNavigatorExtras(activity: Activity): Navigator.Extras {\n    return ActivityNavigatorExtras(toActivityOptions(activity))\n}\n\nfun sharedElementHelperOf(vararg elements: kotlin.Pair<View, String>) = SharedElementHelper().apply {\n    elements.forEach { (view, transitionName) -> addSharedElement(view, transitionName) }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport androidx.navigation.NavController\nimport androidx.navigation.NavDestination\nimport androidx.navigation.NavGraph\nimport androidx.navigation.navOptions\nimport app.tivi.common.ui.R\n\nfun NavController.navigateToNavDestination(itemId: Int, popUpToStart: Boolean = true): Boolean {\n    val options = navOptions {\n        launchSingleTop = true\n        anim {\n            enter = R.anim.tivi_enter_anim\n            exit = R.anim.tivi_exit_anim\n            popEnter = R.anim.tivi_pop_enter_anim\n            popExit = R.anim.tivi_pop_exit_anim\n        }\n        if (popUpToStart) {\n            popUpTo(graph.findStartDestination().id) {\n                inclusive = false\n            }\n        }\n    }\n\n    return try {\n        // TODO provide proper API instead of using Exceptions as Control-Flow.\n        navigate(itemId, null, options)\n        true\n    } catch (e: IllegalArgumentException) {\n        false\n    }\n}\n\nprivate fun NavGraph.findStartDestination(): NavDestination {\n    var startDestination: NavDestination = this\n    while (startDestination is NavGraph) {\n        val parent = startDestination\n        startDestination = parent.findNode(parent.startDestination)!!\n    }\n    return startDestination\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi\n\nimport android.os.Bundle\nimport com.airbnb.mvrx.MvRxView\nimport com.airbnb.mvrx.MvRxViewId\n\n/**\n * Base Activity class which supports LifecycleOwner and Dagger injection.\n */\nabstract class TiviActivityMvRxView : TiviActivity(), MvRxView {\n\n    private val mvrxViewIdProperty = MvRxViewId()\n    final override val mvrxViewId: String by mvrxViewIdProperty\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        mvrxViewIdProperty.restoreFrom(savedInstanceState)\n        super.onCreate(savedInstanceState)\n    }\n\n    override fun onSaveInstanceState(outState: Bundle) {\n        super.onSaveInstanceState(outState)\n        mvrxViewIdProperty.saveTo(outState)\n    }\n\n    override fun onStart() {\n        super.onStart()\n        // This ensures that invalidate() is called for static screens that don't\n        // subscribe to a ViewModel.\n        postInvalidate()\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi\n\nimport android.content.Context\nimport com.airbnb.mvrx.BaseMvRxFragment\nimport dagger.android.AndroidInjector\nimport dagger.android.DispatchingAndroidInjector\nimport dagger.android.HasAndroidInjector\nimport dagger.android.support.AndroidSupportInjection\nimport javax.inject.Inject\n\nabstract class TiviFragment : BaseMvRxFragment(), HasAndroidInjector {\n    @Inject lateinit var androidInjector: DispatchingAndroidInjector<Any>\n\n    override fun onAttach(context: Context) {\n        AndroidSupportInjection.inject(this)\n        super.onAttach(context)\n    }\n\n    override fun androidInjector(): AndroidInjector<Any> {\n        return androidInjector\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.api\n\nsealed class UiStatus\n\nobject UiIdle : UiStatus()\n\ndata class UiError(val exception: Throwable? = null) : UiStatus()\n\ndata class UiLoading(val fullRefresh: Boolean = true) : UiStatus()\n\nobject UiSuccess : UiStatus()",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi\n\nimport android.util.Log\nimport app.tivi.common.ui.BuildConfig\nimport com.airbnb.mvrx.Async\nimport com.airbnb.mvrx.BaseMvRxViewModel\nimport com.airbnb.mvrx.Fail\nimport com.airbnb.mvrx.Loading\nimport com.airbnb.mvrx.MvRxState\nimport com.airbnb.mvrx.Success\nimport io.reactivex.disposables.CompositeDisposable\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.catch\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.map\n\n/**\n * Simple ViewModel which exposes a [CompositeDisposable] which is automatically cleared/stopped when\n * the ViewModel is cleared.\n */\nabstract class TiviMvRxViewModel<S : MvRxState>(\n    initialState: S\n) : BaseMvRxViewModel<S>(initialState, debugMode = BuildConfig.DEBUG) {\n\n    protected suspend inline fun <T> Flow<T>.execute(\n        crossinline stateReducer: S.(Async<T>) -> S\n    ) = execute({ it }, stateReducer)\n\n    protected suspend inline fun <T, V> Flow<T>.execute(\n        crossinline mapper: (T) -> V,\n        crossinline stateReducer: S.(Async<V>) -> S\n    ) {\n        setState { stateReducer(Loading()) }\n\n        @Suppress(\"USELESS_CAST\")\n        return map { Success(mapper(it)) as Async<V> }\n            .catch {\n                if (BuildConfig.DEBUG) {\n                    Log.e(this@TiviMvRxViewModel::class.java.simpleName,\n                        \"Exception during observe\", it)\n                }\n                emit(Fail(it))\n            }\n            .collect { setState { stateReducer(it) } }\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.settings\n\ninterface TiviPreferences {\n\n    fun setup()\n\n    val themePreference: Theme\n\n    enum class Theme {\n        LIGHT,\n        DARK,\n        BATTERY_SAVER_ONLY,\n        SYSTEM\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\nimport kotlinx.coroutines.CoroutineDispatcher\n\ndata class AppCoroutineDispatchers(\n    val io: CoroutineDispatcher,\n    val computation: CoroutineDispatcher,\n    val main: CoroutineDispatcher\n)",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.util\n\ninterface Logger {\n    /** Log a verbose message with optional format args.  */\n    fun v(message: String, vararg args: Any?)\n\n    /** Log a verbose exception and a message with optional format args.  */\n    fun v(t: Throwable, message: String, vararg args: Any?)\n\n    /** Log a verbose exception.  */\n    fun v(t: Throwable)\n\n    /** Log a debug message with optional format args.  */\n    fun d(message: String, vararg args: Any?)\n\n    /** Log a debug exception and a message with optional format args.  */\n    fun d(t: Throwable, message: String, vararg args: Any?)\n\n    /** Log a debug exception.  */\n    fun d(t: Throwable)\n\n    /** Log an info message with optional format args.  */\n    fun i(message: String, vararg args: Any?)\n\n    /** Log an info exception and a message with optional format args.  */\n    fun i(t: Throwable, message: String, vararg args: Any?)\n\n    /** Log an info exception.  */\n    fun i(t: Throwable)\n\n    /** Log a warning message with optional format args.  */\n    fun w(message: String, vararg args: Any?)\n\n    /** Log a warning exception and a message with optional format args.  */\n    fun w(t: Throwable, message: String, vararg args: Any?)\n\n    /** Log a warning exception.  */\n    fun w(t: Throwable)\n\n    /** Log an error message with optional format args.  */\n    fun e(message: String, vararg args: Any?)\n\n    /** Log an error exception and a message with optional format args.  */\n    fun e(t: Throwable, message: String, vararg args: Any?)\n\n    /** Log an error exception.  */\n    fun e(t: Throwable)\n\n    /** Log an assert message with optional format args.  */\n    fun wtf(message: String, vararg args: Any?)\n\n    /** Log an assert exception and a message with optional format args.  */\n    fun wtf(t: Throwable, message: String, vararg args: Any?)\n\n    /** Log an assert exception.  */\n    fun wtf(t: Throwable)\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.inject\n\nimport javax.inject.Qualifier\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class Trakt\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class Tmdb\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class ForStore\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class MediumDate\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class MediumDateTime\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class ShortDate\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class ShortTime\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class PerActivity\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class PerApplication\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class ApplicationId\n\n@Retention(AnnotationRetention.RUNTIME)\n@Qualifier\n@MustBeDocumented\nannotation class ProcessLifetime",
        "/*\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport app.tivi.data.entities.ErrorResult\nimport app.tivi.data.entities.Result\nimport app.tivi.data.entities.Success\nimport java.io.IOException\nimport kotlinx.coroutines.delay\nimport retrofit2.Call\nimport retrofit2.HttpException\nimport retrofit2.Response\n\nfun <T> Response<T>.bodyOrThrow(): T {\n    if (!isSuccessful) throw HttpException(this)\n    return body()!!\n}\n\nfun <T> Response<T>.toException() = HttpException(this)\n\nsuspend inline fun <T> Call<T>.executeWithRetry(\n    defaultDelay: Long = 100,\n    maxAttempts: Int = 3,\n    shouldRetry: (Exception) -> Boolean = ::defaultShouldRetry\n): Response<T> {\n    repeat(maxAttempts) { attempt ->\n        var nextDelay = attempt * attempt * defaultDelay\n\n        try {\n            // Clone a new ready call if needed\n            val call = if (isExecuted) clone() else this\n            return call.execute()\n        } catch (e: Exception) {\n            // The response failed, so lets see if we should retry again\n            if (attempt == (maxAttempts - 1) || !shouldRetry(e)) {\n                throw e\n            }\n\n            if (e is HttpException) {\n                // If we have a HttpException, check whether we have a Retry-After\n                // header to decide how long to delay\n                val retryAfterHeader = e.response()?.headers()?.get(\"Retry-After\")\n                if (retryAfterHeader != null && retryAfterHeader.isNotEmpty()) {\n                    // Got a Retry-After value, try and parse it to an long\n                    try {\n                        nextDelay = (retryAfterHeader.toLong() + 10).coerceAtLeast(defaultDelay)\n                    } catch (nfe: NumberFormatException) {\n                        // Probably won't happen, ignore the value and use the generated default above\n                    }\n                }\n            }\n        }\n\n        delay(nextDelay)\n    }\n\n    // We should never hit here\n    throw IllegalStateException(\"Unknown exception from executeWithRetry\")\n}\n\nsuspend inline fun <T> Call<T>.fetchBodyWithRetry(\n    firstDelay: Long = 100,\n    maxAttempts: Int = 3,\n    shouldRetry: (Exception) -> Boolean = ::defaultShouldRetry\n) = executeWithRetry(firstDelay, maxAttempts, shouldRetry).bodyOrThrow()\n\nfun defaultShouldRetry(exception: Exception) = when (exception) {\n    is HttpException -> exception.code() == 429\n    is IOException -> true\n    else -> false\n}\n\nfun <T> Response<T>.isFromNetwork(): Boolean {\n    return raw().cacheResponse == null\n}\n\nfun <T> Response<T>.isFromCache(): Boolean {\n    return raw().cacheResponse != null\n}\n\n@Suppress(\"REDUNDANT_INLINE_SUSPEND_FUNCTION_TYPE\")\nsuspend fun <T> Response<T>.toResultUnit(): Result<Unit> = toResult { Unit }\n\n@Suppress(\"REDUNDANT_INLINE_SUSPEND_FUNCTION_TYPE\")\nsuspend fun <T> Response<T>.toResult(): Result<T> = toResult { it }\n\n@Suppress(\"REDUNDANT_INLINE_SUSPEND_FUNCTION_TYPE\")\nsuspend fun <T, E> Response<T>.toResult(mapper: suspend (T) -> E): Result<E> {\n    return try {\n        if (isSuccessful) {\n            Success(data = mapper(bodyOrThrow()), responseModified = isFromNetwork())\n        } else {\n            ErrorResult(toException())\n        }\n    } catch (e: Exception) {\n        ErrorResult(e)\n    }\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nfun CharSequence?.isLongerThan(other: CharSequence?) = lengthOrZero() > other.lengthOrZero()\n\nfun CharSequence?.lengthOrZero() = this?.length ?: 0",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport java.util.concurrent.ConcurrentHashMap\nimport java.util.concurrent.atomic.AtomicBoolean\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Deferred\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.async\nimport kotlinx.coroutines.awaitAll\nimport kotlinx.coroutines.channels.Channel\nimport kotlinx.coroutines.coroutineScope\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.FlowCollector\nimport kotlinx.coroutines.flow.flatMapLatest\nimport kotlinx.coroutines.flow.flowOf\nimport kotlinx.coroutines.flow.map\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.supervisorScope\n\nsuspend fun <A, B> Collection<A>.parallelMap(\n    concurrency: Int = defaultConcurrency,\n    block: suspend (A) -> B\n): List<B> = supervisorScope {\n    val semaphore = Channel<Unit>(concurrency)\n    map { item ->\n        async {\n            semaphore.send(Unit) // Acquire concurrency permit\n            try {\n                block(item)\n            } finally {\n                semaphore.receive() // Release concurrency permit\n            }\n        }\n    }.awaitAll()\n}\n\nsuspend fun <A> Collection<A>.parallelForEach(\n    concurrency: Int = defaultConcurrency,\n    block: suspend (A) -> Unit\n) {\n    parallelMap(concurrency) { block(it) }\n}\n\nfun <T, R> Flow<T?>.flatMapLatestNullable(transform: suspend (value: T) -> Flow<R>): Flow<R?> {\n    return flatMapLatest { if (it != null) transform(it) else flowOf(null) }\n}\n\nfun <T, R> Flow<T?>.mapNullable(transform: suspend (value: T) -> R): Flow<R?> {\n    return map { if (it != null) transform(it) else null }\n}\n\nprivate val defaultConcurrency by lazy(LazyThreadSafetyMode.NONE) {\n    Runtime.getRuntime().availableProcessors().coerceAtLeast(3)\n}\n\nval deferreds = ConcurrentHashMap<Any, Deferred<*>>()\nval deferredsCleanLaunched = AtomicBoolean()\n\nsuspend inline fun <T> asyncOrAwait(\n    key: Any,\n    crossinline action: suspend CoroutineScope.() -> T\n): T = coroutineScope {\n    val deferred = deferreds[key]?.takeIf { it.isActive }\n        ?: async { action() }.also { deferreds[key] = it }\n\n    if (deferreds.size > 100 && !deferredsCleanLaunched.getAndSet(true)) {\n        launch {\n            // Remove any complete entries\n            deferreds.entries.removeAll { it.value.isCompleted }\n            deferredsCleanLaunched.set(false)\n        }\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    deferred.await() as T\n}\n\nval jobs = ConcurrentHashMap<Any, Job>()\nval jobsCleanLaunched = AtomicBoolean()\n\nsuspend inline fun launchOrJoin(\n    key: Any,\n    crossinline action: suspend CoroutineScope.() -> Unit\n) = coroutineScope {\n    val job = jobs[key]?.takeIf { it.isActive }\n        ?: launch { action() }\n            .also { jobs[key] = it }\n\n    if (jobs.size > 100 && !jobsCleanLaunched.getAndSet(true)) {\n        launch {\n            // Remove any complete entries\n            jobs.entries.removeAll { it.value.isCompleted }\n            jobsCleanLaunched.set(false)\n        }\n    }\n\n    job.join()\n}\n\n/**\n * Returns a [Flow] whose values are generated by [transform] function that process the most recently emitted values by each flow.\n *\n * The receiver of the [transform] is [FlowCollector] and thus `transform` is a\n * generic function that may transform emitted element, skip it or emit it multiple times.\n */\n@Suppress(\"UNCHECKED_CAST\")\ninline fun <T1, T2, T3, T4, T5, T6, R> combine(\n    flow: Flow<T1>,\n    flow2: Flow<T2>,\n    flow3: Flow<T3>,\n    flow4: Flow<T4>,\n    flow5: Flow<T5>,\n    flow6: Flow<T6>,\n    crossinline transform: suspend (T1, T2, T3, T4, T5, T6) -> R\n): Flow<R> = kotlinx.coroutines.flow.combine(flow, flow2, flow3, flow4, flow5, flow6) { args: Array<*> ->\n    transform(\n        args[0] as T1,\n        args[1] as T2,\n        args[2] as T3,\n        args[3] as T4,\n        args[4] as T5,\n        args[5] as T6\n    )\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.extensions\n\nimport kotlin.properties.ObservableProperty\nimport kotlin.properties.ReadWriteProperty\nimport kotlin.reflect.KProperty\n\ninline fun <T> observable(\n    initialValue: T,\n    crossinline onChange: () -> Unit\n): ReadWriteProperty<Any?, T> = object : ObservableProperty<T>(initialValue) {\n    override fun afterChange(property: KProperty<*>, oldValue: T, newValue: T) = onChange()\n}",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.actions\n\ninterface ShowTasks {\n    fun syncShowWatchedEpisodes(showId: Long)\n    fun syncFollowedShows()\n    fun syncFollowedShowsWhenIdle()\n    fun setupNightSyncs()\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.data.entities\n\nsealed class Result<T> {\n    open fun get(): T? = null\n\n    fun getOrThrow(): T = when (this) {\n        is Success -> get()\n        is ErrorResult -> throw throwable\n    }\n}\n\ndata class Success<T>(val data: T, val responseModified: Boolean = true) : Result<T>() {\n    override fun get(): T = data\n}\n\ndata class ErrorResult<T>(val throwable: Throwable) : Result<T>()",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.base\n\nsealed class InvokeStatus\n\nobject InvokeIdle : InvokeStatus()\nobject InvokeStarted : InvokeStatus()\n\nobject InvokeSuccess : InvokeStatus()\n\ndata class InvokeError(val throwable: Throwable) : InvokeStatus()\nobject InvokeTimeout : InvokeStatus()",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi\n\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport androidx.databinding.ViewDataBinding\nimport app.tivi.util.Logger\nimport javax.inject.Inject\n\nabstract class TiviFragmentWithBinding<V : ViewDataBinding> : TiviFragment() {\n    // Fake injected variable to force Dagger to create the factory\n    @Inject lateinit var logger: Logger\n\n    var binding: V? = null\n        private set\n\n    final override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        return createBinding(inflater, container, savedInstanceState)\n            .also { binding = it }\n            .root\n    }\n\n    final override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        onViewCreated(requireBinding(), savedInstanceState)\n    }\n\n    abstract fun onViewCreated(binding: V, savedInstanceState: Bundle?)\n\n    protected fun requireBinding(): V = requireNotNull(binding)\n\n    final override fun invalidate() = invalidate(requireBinding())\n\n    protected abstract fun invalidate(binding: V)\n\n    protected abstract fun createBinding(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): V\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        binding = null\n    }\n}",
        "/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.databinding\n\nimport android.view.View\nimport androidx.databinding.BindingMethod\nimport androidx.databinding.BindingMethods\nimport androidx.swiperefreshlayout.widget.SwipeRefreshLayout\nimport app.tivi.ui.widget.PopupMenuButton\n\n@BindingMethods(\n    BindingMethod(type = View::class, attribute = \"outlineProviderInstance\", method = \"setOutlineProvider\"),\n    BindingMethod(type = SwipeRefreshLayout::class, attribute = \"isRefreshing\", method = \"setRefreshing\"),\n    BindingMethod(type = View::class, attribute = \"clipToOutline\", method = \"setClipToOutline\"),\n    BindingMethod(type = View::class, attribute = \"activated\", method = \"setActivated\"),\n    BindingMethod(type = View::class, attribute = \"selected\", method = \"setSelected\"),\n    BindingMethod(type = View::class, attribute = \"onLongClick\", method = \"setOnLongClickListener\"),\n    BindingMethod(type = PopupMenuButton::class, attribute = \"popupMenuClickListener\", method = \"setMenuItemClickListener\"),\n    BindingMethod(type = PopupMenuButton::class, attribute = \"popupMenuListener\", method = \"setPopupMenuListener\")\n)\nclass TiviBindingMethods",
        "/*\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage app.tivi.databinding\n\nimport android.content.res.Resources\nimport android.graphics.Outline\nimport android.graphics.Typeface\nimport android.view.Gravity\nimport android.view.View\nimport android.view.ViewOutlineProvider\nimport android.widget.ImageView\nimport android.widget.TextView\nimport androidx.core.content.res.ResourcesCompat\nimport androidx.core.view.isGone\nimport androidx.core.view.isVisible\nimport androidx.databinding.BindingAdapter\nimport app.tivi.extensions.requestApplyInsetsWhenAttached\nimport app.tivi.extensions.resolveThemeReferenceResId\nimport app.tivi.ui.MaxLinesToggleClickListener\nimport app.tivi.ui.NoopApplyWindowInsetsListener\nimport app.tivi.ui.ScrimUtil\nimport kotlin.math.roundToInt\n\n@BindingAdapter(\"visibleIfNotNull\")\nfun visibleIfNotNull(view: View, target: Any?) {\n    view.isVisible = target != null\n}\n\n@BindingAdapter(\"visible\")\nfun visible(view: View, value: Boolean) {\n    view.isVisible = value\n}\n\n@BindingAdapter(\"textOrGoneIfEmpty\")\nfun textOrGoneIfEmpty(view: TextView, s: CharSequence?) {\n    view.text = s\n    view.isGone = s.isNullOrEmpty()\n}\n\n@BindingAdapter(\"goneIfNull\")\nfun goneIfNull(view: View, value: Any?) {\n    view.isGone = value == null\n}\n\n@BindingAdapter(\"srcRes\")\nfun imageViewSrcRes(view: ImageView, drawableRes: Int) {\n    if (drawableRes != 0) {\n        view.setImageResource(drawableRes)\n    } else {\n        view.setImageDrawable(null)\n    }\n}\n\n@BindingAdapter(\"maxLinesToggle\")\nfun maxLinesClickListener(view: TextView, oldCollapsedMaxLines: Int, newCollapsedMaxLines: Int) {\n    if (oldCollapsedMaxLines != newCollapsedMaxLines) {\n        // Default to collapsed\n        view.maxLines = newCollapsedMaxLines\n        // Now set click listener\n        view.setOnClickListener(MaxLinesToggleClickListener(newCollapsedMaxLines))\n    }\n}\n\n@BindingAdapter(\"backgroundScrim\")\nfun backgroundScrim(view: View, oldColor: Int, color: Int) {\n    if (oldColor != color) {\n        view.background = ScrimUtil.makeCubicGradientScrimDrawable(color, 16, Gravity.BOTTOM)\n    }\n}\n\n@BindingAdapter(\"foregroundScrim\")\nfun foregroundScrim(view: View, oldColor: Int, color: Int) {\n    if (oldColor != color) {\n        view.foreground = ScrimUtil.makeCubicGradientScrimDrawable(color, 16, Gravity.BOTTOM)\n    }\n}\n\n@BindingAdapter(\"topCornerOutlineProvider\")\nfun topCornerOutlineProvider(view: View, oldRadius: Float, radius: Float) {\n    view.clipToOutline = true\n    if (oldRadius != radius) {\n        view.outlineProvider = object : ViewOutlineProvider() {\n            override fun getOutline(view: View, outline: Outline) {\n                outline.setRoundRect(0, 0, view.width, view.height + radius.roundToInt(), radius)\n            }\n        }\n    }\n}\n\n@BindingAdapter(\"roundedCornerOutlineProvider\")\nfun roundedCornerOutlineProvider(view: View, oldRadius: Float, radius: Float) {\n    view.clipToOutline = true\n    if (oldRadius != radius) {\n        view.outlineProvider = object : ViewOutlineProvider() {\n            override fun getOutline(view: View, outline: Outline) {\n                outline.setRoundRect(0, 0, view.width, view.height, radius)\n            }\n        }\n    }\n}\n\n@BindingAdapter(\"textAppearanceAttr\")\nfun textAppearanceAttr(\n    view: TextView,\n    oldTextAppearanceStyleAttr: Int,\n    textAppearanceStyleAttr: Int\n) {\n    if (oldTextAppearanceStyleAttr != textAppearanceStyleAttr) {\n        view.setTextAppearance(view.context.resolveThemeReferenceResId(textAppearanceStyleAttr))\n    }\n}\n\n@BindingAdapter(\"fontFamily\")\nfun fontFamily(view: TextView, oldFontFamily: Int, fontFamily: Int) {\n    if (oldFontFamily != fontFamily) {\n        view.typeface = try {\n            ResourcesCompat.getFont(view.context, fontFamily)\n        } catch (nfe: Resources.NotFoundException) {\n            null\n        } ?: Typeface.DEFAULT\n    }\n}\n\n@BindingAdapter(\"noopInsets\")\nfun noopApplyWindowInsets(view: View, enabled: Boolean) {\n    if (enabled) {\n        view.setOnApplyWindowInsetsListener(NoopApplyWindowInsetsListener)\n        view.requestApplyInsetsWhenAttached()\n    } else {\n        view.setOnApplyWindowInsetsListener(null)\n    }\n}"
    ]
};